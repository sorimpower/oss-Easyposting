<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet href="http://rss.egloos.com/style/blog.xsl" type="text/xsl" media="screen"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
	<title>art.oriented</title>
	<link>http://minjang.egloos.com</link>
	<description>debugging the world</description>
	<language>ko</language>
	<pubDate>Mon, 21 Oct 2013 22:18:59 GMT</pubDate>
	<generator>Egloos</generator>
	<image>
		<title>art.oriented</title>
		<url>http://pds9.egloos.com/logo/200804/19/29/d0033129.jpg</url>
		<link>http://minjang.egloos.com</link>
		<width>80</width>
		<height>53</height>
		<description>debugging the world</description>
	</image>
  	<item>
		<title><![CDATA[ A7의 성능과 64비트 CPU 성능 ]]> </title>
		<link>http://minjang.egloos.com/3052820</link>
		<guid>http://minjang.egloos.com/3052820</guid>
		<description>
			<![CDATA[ 
  <p align="justify">역시 애플이 나서야 하는가. 모바일에서도 분명 64비트가 필요하긴 하지만, 2015년 정도라고 생각했는데, 애플이 아이폰 5S에서 64비트 A7 SOC를 내놓았다. 애플이 이렇게 64비트를 내놓으니 일반인들까지 64비트 이야기를 하게 되었다. 나는 애플의 이 64비트 전환을 아주 긍정적으로 생각한다. 그래야 다른 경쟁자들도 빨리 64비트를 내놓아 개발 생태계도 64비트로 옮겨갈 수 있고, 더 높은 성능의 장치와 응용을 기대할 수 있어서이다. 한편, A7 SOC의 ARM 프로세서 성능이 매우 인상 깊다. 이 이야기와 일반적인 64비트 성능 이야기를 좀 해보자.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>iPhone 5S A7의 놀라운 성능 향상</strong></p>  <p align="justify">AnandTech의 <a href="http://www.anandtech.com/show/7335/the-iphone-5s-review/6">A7 CPU의 성능을 보면 매우 놀랍다</a>. 물론, 벤치마크 점수에 <a href="http://anandtech.com/show/7384/state-of-cheating-in-android-benchmarks">온갖 꼼수가 다 들어간 건</a> 다 알고 있지만, 여기서는 같은 아이폰에서의 결과이고 절대적인 점수보다 상대적인 발전을 본다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201310/04/29/d0033129_524e2815e625c.png" width="484" height="444" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201310/04/29/d0033129_524e2815e625c.png', 484, 444);" /></div></p>  <p align="justify">이전 세대 A6 (iPhone 5)에 비해 A7 (5S)의 Geekbench 점수는 50%, 64비트는 거의 두 배 가까이 향상 되었다. 아니 지금이 클럭 속도가 두 배씩 올라 성능 역시 마구 두 배씩 증가하는 시절인가?? 그런데 클럭 속도는 A6, A7 모두 1.3GHz로 동일하다. 결국 이 성능 차이는 메모리 성능, L2 캐시 성능, 마이크로아키텍처 차이 외에는 설명이 안 된다. L2 캐시 크기는 역시 모두 1MB로 같으나 레이턴시 등은 얼마든지 개선될 수 있다. 참고로 iPhone 4S는 클럭 속도가 800MHz 였다.</p>  <p align="justify">인텔은 상당히 세부적인 CPU 구조도 개발자 포럼 등으로 공개를 한다. 하지만 이넘의 모바일 프로세서들은 공개된 자료가 너무나 제한적이다. 회사 내에 안드로이드 드라이버 만드는 분의 이야기를 들었는데, 프로세서 버그로 의심되는 것이 보여 그 쪽 팀에 물으니 절대 이메일로 안 알려주고 전화로만 알려준다고 한다. 제품의 개발 주기가 데스크탑 시절보다 훨씬 짧고, 경쟁이 치열하다 보니 같은 회사 내에서도 구체적인 내용이 공유가 안 되는 것 같다. 아시다시피 A6/A7은 모두 애플이 직접 설계한 구조이다. 아무리 애플의 보안이 예전 같지 않다 하더라도 A7의 자세한 파이프라인 구조를 알 길은 거의 없어 보인다. 물론 거시적인 구조는 예측이 되지만 인텔 프로세서 내부 만큼 알 수가 없다.</p>  <p align="justify">그렇다면 도대체 같은 클럭에서 이렇게 성능이 개선된 이유가 뭘까. </p>  <p align="justify">대충 나의 짐작으론 아직 모바일 영역에서 비순차 프로세서가 도입된 것이 얼마 되지 않았기에 개선의 여지가 꽤 있는 것 같다. 모바일에서는 아직 데스크탑 수준의 비순차 실행, 그러니까 가능한 모든 명령에 대해 최대한 비순차 실행이 제대로 다 안 되는 걸로 알고 있다. 다른 몇몇 이야기도 들었지만 여기서 쓰기는 그렇고, 대략 아직 동 클럭 내에서 성능 향상의 여지가 있다고 봐도 좋을 것이다.</p>  <p align="justify">그래도 클럭과 발열이라는 강력한 제한이 있는 모바일에서 앞으로도 이런 두 배 - 두 배라는 정의가 매우 모호하지만 - 씩 증가하는 성능을 언제까지 보여줄지는 회의적이다. 과거 펜티엄 4에서 Core로 넘어올 땐 엄청난 싱글 스레드 성능 향상이 있었는데, 이제는 그런 것을 기대할 수 없다. 최신 Haswell이 이전 Ivy Bridge에 비해 같은 클럭 당 성능이 50%씩 증가하는 건 아니다.</p>  <p align="justify">어쨌거나 벤치마크 점수만 보면 애플은 ARM 모바일 프로세서에서도 거의 최고 수준의 설계 능력을 가지고 있음을 보여줬다. 현 스냅드래곤(Krait)의 다음 세대가 나오는 내년이 되어봐야 얼마나 A7의 위치를 판단할 수 있을 것이다. 그런데 64비트를 당장에 준비하지 않은 걸로 알고 있는데 경쟁사들의 대응이 어떻게 될지 궁금하다. 날짜를 앞당겨서라도 경쟁사들도 내년에 64비트 칩을 내놓을 것 같다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>A7 32비트 벤치마크 점수 자세히 보기</strong></p>  <p align="justify">벤치마크 점수에는 치팅을 차치하고서라도 늘 맹점이 있음을 유의해야 한다. Geekbench 기준, 전체 점수로는 32비트 기준 50%의 향상이 있었다. Geekbench를 살펴보니 C 아니면 C++로 만들어진 네이티브 벤치마크이고 정수/실수/메모리 성능을 <a href="http://support.primatelabs.com/kb/geekbench/geekbench-3-benchmarks">작은 벤치마크를 여러 돌려서</a> 전체 점수를 합한다. 여기에는 압축(Bzip2, JPEG, PNG), 암호(AES, SHA1), 그래프 연산(Dijkstra), <a href="http://en.wikipedia.org/wiki/Stencil_code">스텐실 연산</a>(Sharpen/Blur filters) 등이 있다.</p>  <p align="justify"><a href="http://www.anandtech.com/show/7335/the-iphone-5s-review/4">아난드텍</a>과 Geekbench에서 <a href="http://browser.primatelabs.com/geekbench3/98142">공개된 A6 자료</a>로 각 세부 벤치마크 별 A6 (32-bit) 대비 A7 (32-bit)의 성능 향상 정도를 비교해봤다. 무려… 엑셀로 그렸다. 참고로 MT가 붙은 것은 멀티스레드로 작동한 버전을 가리킨다.</p>  <p align="justify"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201310/04/29/d0033129_524e2818a4b26.png" width="500" height="194.444444444" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201310/04/29/d0033129_524e2818a4b26.png', 864, 336);" /></div></p>  <p align="center">A6 대비 A7의 성능 향상: A7 성능/A6 성능으로 구함. 클럭은 모두 1.3GHz로 같음. 붉은 선 아래는 성능 하락. 녹색 선은 전체 평균.</p>  <p align="justify">기하 평균으로 정수 프로그램에서는 1.4배, 실수 프로그램에서는 1.7배, 전체적으로 약 1.5배 정도 나온다. 그래프에서 보다시피 붉은 선 아래에 있는 오히려 성능이 떨어진 프로그램도 하나 있었고, 전체 기하 평균인 녹색 선 아래에 있는 벤치마크가 더 많다. 별로 놀랍지 않는 사실이다. 보통은 몇몇 프로그램에서 큰 성능 개선이 이뤄져서 전체 평균이 높아지는 경향이 있다. 이런 통계/평균의 맹점을 고려하더라도 같은 클럭에서 이 정도의 성능 향상은 사실 정말 대단한 것이다. 20-30%의 성능 향상이 대부분에 걸쳐 나타난다. 물론, 절대 치팅이나 소프트웨어 속임수를 하지 않는다고 가정이 필요하다.</p>  <p align="justify">정수 프로그램에서 특별히 빨라진 것은 <a href="http://en.wikipedia.org/wiki/Sobel_operator">Sobel</a> (경계 추출 이미지 프로세싱 알고리즘), Lua (루아 스크립트 코드), JPEG 해제이다. Dijkstra 그래프 알고리즘도 40%나 빨라진 것도 매우 인상 깊다. 하지만 왜 <a href="http://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot 벤치마크</a> 성능이 하락했는지 상당히 궁금하다. 자세한 마이크로아키텍처를 모르니 이런 변화를 별 설명할 길이 없다. 그냥 전체적으로 빡세게 잘 만든 것 같다….</p>  <p align="justify">참고로 나는 자바스크립트/안드로이드 자바 벤치마크가 그다지 CPU의 원 성능을 가늠하는 좋은 잣대라고 생각하지 않는다. 자바스크립트는 웹브라우저의 자바스크립트 엔진(JIT 컴파일러)의 성능에 매우 많은 영향을 받는다. 안드로이드 기반 벤치마크 역시 그러하다. 물론 비 NDK 앱에 한해서이다. 특히, <a href="https://play.google.com/store/apps/details?id=com.aurorasoftworks.quadrant.ui.standard&amp;hl=en">Quadrant 벤치마크</a> 같은 경우는 핵심 루프가 매우 짧다. 여기서 자바 컴파일러가 최적화를 어떻게 하냐에 따라 점수가 큰 폭으로 변하기 쉽다. 그래서 벤치마크가 JIT 기반인 것은 늘 주의해서 봐야 한다. 간단하게 말하면 소프트웨어의 영향을 심하게 받을 수 있다. 완벽하게 동일한 웹브라우저와 순정 안드로이드가 아니면 소프트웨어로 인한 차이가 클 수 있다. 이에 비해 네이티브 기반 벤치마크는 CPU의 원 성능을 더 잘 드러낸다. 물론 컴파일러가 당연히 영향을 줄 수 있고, 컴파일러 수준에서 치팅도 가능하다.</p>  <p align="justify">이미 말했듯이 모든 회사들은 이런 벤치마크 점수에 굉장히 민감하다. 온갖 최적화, 어떨 때는 도를 넘어서 속임수도 쓴다. 모바일 같이 발열/배터리가 중요한 곳에서는 벤치마크가 작동할 때 그냥 더 빡세게 하드웨어를 돌리는 것으로 치팅을 하기도 하지만, 더 심한 치팅도 과거에 많았다. 그래픽 드라이버에서 특정 게임이 실행되면 몇몇 작업을 빼버려 점수를 더 잘나오게 한다거나, 아주 심한 건 자바 컴파일러가 특정 벤치마크의 패턴을 인식해 ‘정답’을 내놓기도 한다. 컴파일러가 하기 어려우니 손으로 최적화한 정답 코드로 바꿔치기 하는 것이다. 물론 이런 부정은 사라져야 한다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>A7 32비트에서 64비트의 성능 향상</strong></p>  <p align="justify">이번에는 같은 A7에서 같은 벤치마크에서 32비트에서 64비트 변환 시 성능 향상이다. 4개의 벤치마크 성능이 대폭으로 향상이 되어 통계 값이 왜곡이 많이 된다. 원 자료는 아래와 같다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds26.egloos.com/pds/201310/04/29/d0033129_524e281c297c0.png" width="500" height="194.444444444" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201310/04/29/d0033129_524e281c297c0.png', 864, 336);" /></div></p>  <p align="justify">보다시피 AES가 너무 튄다. 그래프 상한선을 2배까지로 제한해서 좀 사실적인 결과를 보자.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201310/04/29/d0033129_524e281f308ed.png" width="500" height="194.444444444" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201310/04/29/d0033129_524e281f308ed.png', 864, 336);" /></div></p>  <p align="justify">전체적으로는 1.4배 정도의 성능 향상이 있었으나 <strong>특별히 많이 오른 AES/SHA/DGEMM/SFFT를 제외하면 64비트의 성능 향상은 1.1배이다</strong>. 대략 10%의 향상인데, 그러니까 컴파일만 64비트에 새로 해서 10% 성능이 오른 것이다. 물론 Geekbench 제작자가 64비트 전용 최적화를 손수 했는지는 모른다. 그랬으면 이야기가 좀 달라지겠지만, 큰 노력을 안 하고 64비트로 재컴파일만 해서 얻은 10% 성능 향상은 분명 의미 있다. 하지만 나빠지는 결과도 있다. Dijkstra가 특히 성능이 많이 하락하였다. 몇몇 벤치마크는 성능이 하락하기도 하지만 대략 5~10% 정도의 성능 향상은 x86에서도 보통 볼 수 있는 수치이다 (<a href="http://www.ece.neu.edu/groups/nucar/publications/SWC06.pdf">참고 논문 하나</a>). 이 큰 폭의 성능 상승/하락은 뒤에서 설명한다.</p>  <p align="justify">먼저, 일반적인 32비트에서 64비트 프로세서의 전환의 의미를 알아보자.</p>  <p align="justify">CPU가 가장 빨리 수행할 수 있는 연산은 정수 덧셈/뺄셈/비트연산이다. 이 정수의 크기가 32비트에서는 32비트이고 64비트에서는 64비트가 된다. 64비트 정수 계산을 명령어 하나로 지원하려면 레지스터 크기 역시 64비트가 되어야 하며, 데이터패쓰(datapath) 내 버스도 두 배 늘려야 한다. 이 덕분에 메모리 주소를 가리키는 포인터 역시 64비트가 되어 사용 가능한 메모리가 4GB에서 2^64라는 숫자까지 된다. 32비트 시절에도 우회적인 방법으로 4GB 이상의 메모리를 쓸 수 있었지만, 64비트는 이런 임시 방편 필요 없이 깔끔하게 해결된다. 64비트의 완전한 구현은 부담이 되기도 한다. 특히 페이지 테이블이나 캐시는 64비트 주소를 다뤄야 한다. 그래서 인텔이나 ARM이나 64비트 주소 공간을 지금 당장 쓰는 건 아니고 48비트까지만 허용한다.</p>  <p align="justify">이 변화는 그냥 일반적인 64비트의 장점이다. 요약하면 32비트에서는 최소 두 개 이상의 연산이 필요한 64비트 연산이 하나로 되고, 4GB 넘는 메모리를 쉽게 쓸 수 있다.</p>  <p align="justify">그런데 이왕 64비트 같은 새로운 아키텍처로 넘어갈 때 다른 부분도 개선을 같이 하면 좋을 것이다. ARM이나 x86처럼 매우 널리 쓰이는 구조는 하위호환성이 생명이므로 새로운 명령어를 추가하는 것 같은 제한적인 진보만 할 수 있다. 그래서 64비트 같이 모드가 바뀌는 시점이 좋은 기회이다. x86 역시 그러했고 ARM 역시 그러하다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds25.egloos.com/pds/201310/04/29/d0033129_524e2823b624d.png" width="500" height="383.540372671" onclick="Control.Modal.openDialog(this, event, 'http://pds25.egloos.com/pds/201310/04/29/d0033129_524e2823b624d.png', 644, 494);" /></div></p>  <p align="center">ARMv8 Technology Preview에서 가져옴. (<a href="http://www.arm.com/files/downloads/ARMv8_Architecture.pdf">링크</a>) </p>  <p align="justify">ARM의 64비트 구조는 ARMv8라 불리며 당연히 예전 32비트 모드를 지원한다. 단순히 64비트로의 이전 외에 ARMv8가 이전 구조에 비해 개선된 점은 대략 이러하다.</p>  <ul>   <li>     <div align="justify">범용 목적 레지스터(GPR, general purpose register) 개수가 32비트 시절의 16개에서 거의 두 배가 되어 31개.</div>   </li>    <li>     <div align="justify">SIMD 명령어 강화: 128비트 레지스터가 기존의 16개에서 32개로 증가. Double 형 지원.</div>   </li>    <li>     <div align="justify">AES 암호, SHA 해시 명령어 추가</div>   </li> </ul>  <p align="justify">이 변화로 위 벤치마크 점수 변화를 설명할 수 있다. AES/SHA가 각각 9배, 3.5배 증가한 것은 “64비트”가 되어서가 아니라 64비트 ARM 구조에서 AES/SHA 가속이 되어서이다. 아난드텍의 분석에 따르면 DGEMM/SFFT는 double을 쓰는데 ARMv8의 개선된 SIMD가 double을 지원해서이다. 따라서 이 4개 벤치마크를 제외해야 레지스터 두 배 증가와 64비트 연산의 이득/손실을 볼 수 있다. SIMD나 암호 연산은 굳이 64비트 전환이 아니더라도 언제든지 추가할 수 있기 때문이다.</p>  <p align="justify">Dijkstra 프로그램이 거의 25% 정도 성능이 하락했다. Dijkstra 벤치마크는 그래프 자료구조에서 최단 거리를 찾는 알고리즘인데, 그래프가 행렬로 표현이 되었다면 이런 큰 손실은 없을 것이다. 아마 노드 기반이고, 노드 크기가 여기서 크지 않으므로, 결국 두 배 커지는 포인터가 큰 부담이 된다. 포인터 기반 자료구조는 생각보다 64비트에서 메모리 사용량이 크게 늘 수 있다. 결국 이것으로 캐시 성능이 나빠지니 전체적인 성능 하락으로 연결된다. 나도 이 문제로 고생을 많이 하였는데, 그래서 64비트 포인터에서 아직 쓰지 않는 상위 16비트에 다른 정보를 저장해 메모리를 아끼는 짓도 해보았다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>간단한 프로그램으로 64비트 성능 비교</strong></p>  <p align="justify">64비트 CPU의 성능 차이를 시각화 해보고자… 간단한 프로그램을 만들어서 그냥 x86 컴퓨터에서 돌려보았다. 검증할 건 레지스터의 개수 차이와 64비트 연산이다. x86에서도 64비트로 가면서 범용 목적 레지스터가 두 배 늘었다 (8개 –&gt; 16개). 그래서 ARM도 이 결과와 비슷할 것이다.</p>  <ul>   <li>     <div align="justify">두 배가 된 레지스터 영향: Register spill(레지스터가 부족해 스택 메모리로 잠시 변수 값을 보냄)이 64비트에서는 안 나고 32비트에서는 나는 코드를 만들어 봄.</div>   </li>    <li>     <div align="justify">64비트 정수 연산의 영향: 그냥 변수 연산을 할 때 32비트냐 64비트로 조절.</div>   </li> </ul>  <p align="justify">코드는 무지 간단한데 <a href="http://pastebin.com/AAmB8T2D">여기서 볼 수 있다</a>. (코드에 대해 부연 설명을 하면: 의도적으로 for 루프 안에 여러 변수들에 대해 정수 연산을 할 때 직렬로 이루어지도록 의존성을 차례대로 걸었다. +을 안 쓰고 &amp;-^|를 쓴 이유는 x86 컴파일러는 +이 있으면 add 보다 lea를 이용해 코드를 생성한다. 보기가 안 좋아 +는 안 썼다. 컴파일러는 Visual Studio 2013 RC 버전을 이용했고 최적화는 최대한으로. 레지스터를 최대로 쓰고자 omit frame pointer 최적화도 켬.)</p>  <p align="justify">이쯤 되니 너무 귀찮아져서 그냥 절대 수행시간으로 그래프를 그렸다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds21.egloos.com/pds/201310/04/29/d0033129_524e2826a8bcc.png" width="500" height="255.381604697" onclick="Control.Modal.openDialog(this, event, 'http://pds21.egloos.com/pds/201310/04/29/d0033129_524e2826a8bcc.png', 511, 261);" /></div></p>  <p align="justify">보다시피 같은 코드인데 어떤 것은 성능이 똑같고 어떤 것은 3배까지 벌어졌다. 각 경우를 살펴보면 이러하다.</p>  <p align="justify">(1) 붉은 색 막대끼리 비교: 64비트 모드에서는 32비트/64비트 정수 연산에 속도 차이는 없다. (단, 곱셈/나눗셈은 테스트 안 함.)</p>  <p align="justify">(2) 맨 왼쪽 No Spill + 32비트 연산: 레지스터 스필이 나지 않고 32비트 연산만 하면 64비트 코드와 성능 차이는 없다.</p>  <p align="justify">(3) 두 번째 그룹, No Spill + 64비트 연산: 성능이 거의 3배 나빠졌다 (2초 =&gt; 6초). 32비트에서 64비트 연산을 하려고 하니 상위 32비트/하위 32비트로 나누어서 계산하니 두 배 이상이 드는 것은 예측이 된다. 그런데 3배까지 나빠진 이유를 보니 이 나누어서 연산하는 과정에서 레지스터가 더 필요해서 예상치 않은 스필이 일어났다. 그 영향을 빼면 성능 하락은 두 배가 된다.</p>  <p align="justify">(4) 세 번째 그룹, Spill + 32비트 연산: 64비트 연산에 대한 패널티가 없는 상황에서 레지스터 스필만 일어나도록 했는데 대략 4초에서 12초까지 성능이 2.7배 정도 차이가 났다. 어차피 레지스터 스필이 일어나도 스택은 모두 캐시 적중이 되니 실제 메모리에 갈 일은 없다고 봐도 되니 L1 캐시 접근 영향이 더해 진다. 2배 정도라고 예상했는데 생각보다 컸다.</p>  <p align="justify">(5) 마지막 그룹, Spill + 64비트 연산: 32비트 컴퓨터에서 최악의 상황이다. 연산도 64비트를 해야하고 레지스터 스필도 난다. 약 3배 정도 성능 하락이 있다.</p>  <p align="justify">x86-64에서 64비트 모드는 스택 포인터를 제외하고 최대 15개까지 범용 레지스터를 쓸 수 있다. 그런데 시간 측정 변수를 희한하게 컴파일러가 계속 레지스터에 담아 두도록 레지스터 할당을 해서 14개까지 쓸 수 있었다. 최상의 경우에 어셈블리 코드를 보면 아래와 같다. 보다시피 레지스터 스필이 하나도 없이 루프 전체가 모두 레지스터에서 계산이 된다.</p>  <div style="overflow: auto; cursor: text; font-size: 8pt; border-top: silver 1px solid; font-family: 'Courier New', courier, monospace; border-right: silver 1px solid; border-bottom: silver 1px solid; padding-bottom: 4px; direction: ltr; text-align: left; padding-top: 4px; padding-left: 4px; margin: 20px 0px 10px; border-left: silver 1px solid; line-height: 12pt; padding-right: 4px; max-height: 200px; width: 97.5%; background-color: #f4f4f4">   <div style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">     <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   1:</span> <span style="color: #0000ff">for</span> (uint32_t i = 0; i &lt; numeric_limits&lt;uint32_t&gt;::max() / 2; ++i) {</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   2:</span>   t1 = t1 | tC;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   3:</span> 0000013F6612D0  or          rdi,r10  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   4:</span>   t2 = t2 &amp; t1;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   5:</span> 0000013F6612D3  and         rsi,rdi  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   6:</span>   t3 = t3 - t2;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   7:</span> 0000013F6612D6  sub         rbp,rsi  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   8:</span>   t4 = t4 ^ t3;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   9:</span> 0000013F6612D9  xor         r14,rbp  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  10:</span>   t5 = t5 | t4;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  11:</span> 0000013F6612DC  or          r15,r14  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  12:</span>   t6 = t6 &amp; t5; <span style="color: #008000">// &lt;== Fits x86 registers w/o spill</span></pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  13:</span> 0000013F6612DF  and         r12,r15  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  14:</span>   t7 = t7 - t6;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  15:</span> 0000013F6612E2  sub         r13,r12  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  16:</span>   t8 = t8 ^ t7;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  17:</span> 0000013F6612E5  xor         rax,r13  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  18:</span>   t9 = t9 | t8;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  19:</span> 0000013F6612E8  or          rcx,rax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  20:</span>   t0 = t0 &amp; t9;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  21:</span> 0000013F6612EB  and         rdx,rcx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  22:</span>   tA = tA - t0;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  23:</span> 0000013F6612EE  sub         r8,rdx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  24:</span>   tB = tB ^ tA;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  25:</span> 0000013F6612F1  xor         r9,r8  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  26:</span>   tC = tC | tB;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  27:</span> 0000013F6612F4  or          r10,r9  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  28:</span> 0000013F6612F7  dec         r11  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  29:</span> 0000013F6612FA  jne         main+60h (013F6612D0h)  </pre></div></div><p>반면 최악의 경우인 32비트 모드에서 64비트 계산과 레지스터 스필까지 동시에 나면 코드는 매우 지저분해진다.</p><div style="overflow: auto; cursor: text; font-size: 8pt; border-top: silver 1px solid; font-family: 'Courier New', courier, monospace; border-right: silver 1px solid; border-bottom: silver 1px solid; padding-bottom: 4px; direction: ltr; text-align: left; padding-top: 4px; padding-left: 4px; margin: 20px 0px 10px; border-left: silver 1px solid; line-height: 12pt; padding-right: 4px; max-height: 200px; width: 97.5%; background-color: #f4f4f4">  <div style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4">    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   1:</span> 47:     t0 = t0 &amp; t9;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   2:</span> 00FD137C  mov         ecx,dword ptr [esp+44h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   3:</span> 00FD1380  and         ecx,eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   4:</span> 00FD1382  mov         dword ptr [esp+4Ch],eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   5:</span> 00FD1386  mov         eax,dword ptr [esp+48h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   6:</span> 00FD138A  and         eax,dword ptr [esp+24h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   7:</span> 48:     tA = tA - t0;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">   8:</span> 00FD138E  sub         dword ptr [esp+20h],ecx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">   9:</span> 00FD1392  mov         dword ptr [esp+44h],ecx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  10:</span> 00FD1396  mov         ecx,dword ptr [esp+40h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  11:</span> 00FD139A  sbb         ecx,eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  12:</span> 00FD139C  mov         dword ptr [esp+48h],eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  13:</span> 49:     tB = tB ^ tA;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  14:</span> 00FD13A0  mov         eax,dword ptr [esp+3Ch]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  15:</span> 00FD13A4  xor         eax,dword ptr [esp+20h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  16:</span> 00FD13A8  xor         dword ptr [esp+1Ch],ecx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  17:</span> 50:     tC = tC | tB;</pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  18:</span> 00FD13AC  or          esi,eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  19:</span> 00FD13AE  or          edi,dword ptr [esp+1Ch]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  20:</span> 00FD13B2  dec         dword ptr [esp+68h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  21:</span> 00FD13B6  mov         dword ptr [esp+40h],ecx  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  22:</span> 00FD13BA  mov         ecx,dword ptr [esp+70h]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  23:</span> 00FD13BE  mov         dword ptr [esp+3Ch],eax  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: #f4f4f4"><span style="color: #606060">  24:</span> 00FD13C2  mov         eax,dword ptr [esp+6Ch]  </pre>    <pre style="border-top-style: none; overflow: visible; font-size: 8pt; border-left-style: none; font-family: 'Courier New', courier, monospace; border-bottom-style: none; color: black; padding-bottom: 0px; direction: ltr; text-align: left; padding-top: 0px; border-right-style: none; padding-left: 0px; margin: 0em; line-height: 12pt; padding-right: 0px; width: 100%; background-color: white"><span style="color: #606060">  25:</span> 00FD13C6  jne         main+0B0h (0FD1300h)  </pre></div></div><p align="justify">이 벤치마크는 극단적인 상황을 가정해서 같은 코드에서도 성능 차이가 전혀 없게도, 혹은 3배까지도 나게 만들 수 있었다. 하락하는 경우는 앞서 설명했듯이 포인터 기반 자료구조를 빡세게 돌리는 코드면 볼 수 있다.</p><p align="justify">결국 64비트 프로그램에서 이러한 현상이 얼마나 자주 일어나느냐가 프로그램 성능 향상의 관건이 될 것이다. 일반적으로 64비트 CPU의 정수 연산에 대해서만 정리하면 다음과 같이 말할 수 있다.</p><ul>  <li>    <div align="justify">메모리/캐시에 큰 압박을 주지 않는다면 64비트 연산을 최대한 활용하는 것이 좋다.</div>  </li>  <li>    <div align="justify">포인터 기반 자료구조에서 실제 데이터보다 포인터 오버헤드가 커지면 성능이 하락할 수도 있다.</div>  </li>  <li>    <div align="justify">범용 레지스터가 늘어나면, 소위 레지스터 압력(register pressure)가 높은 루프에서 효과를 볼 수 있다. 쉽게 말해 긴 루프의 수행 성능이 좋아질 수 있다. (변수가 어떤 구간 동안 계속 살아 있어 사용이 되면 최대한 레지스터에 놓는 것이 좋다. 컴파일러의 레지스터 할당 알고리즘은 이걸 최대한으로 보장하려고 하는데, 여기서 레지스터 개수가 늘어나니 성능 향상에 이득이 된다.)</div>  </li></ul><p align="justify">&nbsp;</p><p align="justify">3줄 요약:</p><ul>  <li>    <div align="justify">벤치마크 점수로 본 A7의 성능은 놀랍다. 도대체 무슨 짓을 한 것인가.</div>  </li>  <li>    <div align="justify">모바일에서도 64비트는 필요하다.</div>  </li>  <li>    <div align="justify">32비트에서 64비트로의 성능 변화는 그때 그때 마다 다르다.</div>  </li></ul>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3052820#comments</comments>
		<pubDate>Fri, 04 Oct 2013 02:30:00 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 아이폰 5S 모션 코프로세서 M7에서 보는 두 가지 ]]> </title>
		<link>http://minjang.egloos.com/3048780</link>
		<guid>http://minjang.egloos.com/3048780</guid>
		<description>
			<![CDATA[ 
  <p align="justify">아이폰 5S에는 (모바일로서는 최초의) ARM 64 비트 프로세서(SoC) A7이 탑재된다. 모바일에서 64비트 컴퓨팅이라는 것도 흥미롭지만, 나는 M7이라는 모션 코프로세서가 더 흥미로웠다. 아직까지 내가 정확하게 M7 코프로세서가 어떤 기능을 제공하는지 모르지만, 현재 모바일 컴퓨팅에서 중요한 두 대목을 읽을 수 있다. 트위터에 쓸만한 내용은 아닌 것 같아 짧막하게 오랜만에 블로그에 써본다. 일러두자면 이 포스팅 내용은 순전히 나의 개인적 의견이다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201309/12/29/d0033129_5230beeeee5f9.jpg" width="500" height="334.437086093" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201309/12/29/d0033129_5230beeeee5f9.jpg', 604, 404);" /></div></p>  <p align="center">&nbsp;</p>  <p align="justify"><strong>에너지를 아끼자: 늘 계산하는 작업</strong></p>  <p align="justify">키노트 슬라이드에서 첫 내용은 “Continuously measures motion data”. 여기서 핵심은 ‘항상’ 어떤 데이터를 수집해 계산한다는 것이다. 늘 계산을 한다는 이야기는 결과적으로 에너지 소비가 크다는 이야기이다. 아마도 지금까지는 이 모션 정보 처리를 CPU에서 했을 것이다. 그렇다면 에너지(=배터리) 소비가 당연히 클 수밖에 없다. 그래서 이 계산만을 위한 특화된 프로세서를 만들면 (쉽게 설명하면 모션 정보 처리 소프트웨어 알고리즘을 전용 하드웨어로 구현하는 것) 계산 성능, 소비 전력, 소비 에너지를 모두 개선할 수 있다.</p>  <p align="justify">(모호하게 모션 정보 계산이 ‘전력’이 크다고 말하는 것은 정확한 표현이 아니다. 모션 데이터 계산하는데 엄청난 전력(Watt)가 필요한 것은 아닐 것이다. 다만 작은 전력이더라도 오랜 시간 동안 돌아가야 하니 에너지(Wh = J), 즉 베터리가 쉽게 닳는다는 이야기이다. 에너지와 전력은 확연히 구분해서 생각해야 하고, 보통 모바일에서는 에너지가 중요한 경우가 훨씬 많다. 물론 소비 전력은 발열과 관련이 깊어 역시나 중요하다. 사실 전력과 에너지는 애매모호하게 연관이 되어있어 어렵다.)</p>  <p align="justify">모바일 환경에서 늘 계산을 요구하는 응용은 활용도가 상당히 높다. M7에서 보듯이 사용자의 위치와 움직임을 최소한의 에너지로 계산할 수 있으면 응용 분야가 크게 늘 것이다. GPS가 포함되어있지는 않는 것 같은데, GPS도 있다면 역시 응용 분야는 더욱 커질 수 있다.</p>  <p align="justify">아마도 이런 분야에서 중요한 예는 아마 음성인식일 것이다. 지금은 반드시 버튼을 눌러야 Siri나 구글 나우 같은 음성 인식이 된다. 그런데 만약 스마트폰이 계속 주변의 소리를 들을 수 있다면? 그러면 그냥 스마트폰을 부르기만 하면 명령 실행이 될 수 있을 것이다. 물론, 주변 노이즈가 있는 상황에서 음성 인식이 알고리즘적으로 어렵겠지만, 컴퓨터 구조적으로 많은 에너지를 소비하는 것도 큰 장벽이다. 음성 인식 자체는 큰 전력이 필요한 연산은 아니지만, 늘 켜 있기에는 배터리 소비가 클 수밖에 없다. 그렇다면 이 부분 역시 M7 같은 코프로세서가 있다면 실현 가능성을 한층 높일 수 있을 것이다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>헤테로지니어스 컴퓨팅</strong></p>  <p align="justify">헤테로지니어스 컴퓨팅이라는 단어는 2006년 유학 준비하면서 처음 들어본 단어였다. 비로소 요즘에 - 특히 모바일 분야에서 – 헤테로지니어스 컴퓨팅이 더욱 중요하게 되었다. <a href="http://en.wikipedia.org/wiki/Heterogeneous_computing">헤테로지니어스 컴퓨팅</a>은 멀티코어 만큼이나 정확하게 정의하기가 모호하다. 특히 최근 ARM이 big.LITTLE을 헤테로지니어스라고 주장하는 바람에 더더욱 그러하다. 일반적으로 컴퓨터 구조 분야에서 간주되는 헤테로지니어스 컴퓨팅의 정의는 “다른 명령어(<a href="http://en.wikipedia.org/wiki/Instruction_set">ISA</a>)”를 처리하는 프로세서들이 모인 것이다. (빅리틀은 같은 명령어를 사용한다.)</p>  <p align="justify">CPU와 GPU가 아마도 가장 널리 알려진 헤테로지니어스 컴퓨팅의 예일 것이다. GPU가 과거 고정된 그래픽 파이프라인만 처리하다가 점차 프로그래밍이 되는 것으로 진화하면서 본격 헤테로지니어스 컴퓨팅의 문을 열었다.</p>  <p align="justify">모바일에서는 더욱 흥미롭다. GPU 뿐만 아니라 DSP (디지털 시그널 프로세서)가 중요한 컴퓨팅 자원이다. DSP라고 하면 정말 시그널 프로세싱 같은 곳에서만 쓰이는 줄 알았는데 아니다. DSP, 예를 들어 <a href="http://en.wikipedia.org/wiki/Qualcomm_Hexagon">Hexagon DSP</a> 같은 것은 그냥 CPU와 동일하다. 컴퓨터 구조 용어를 빌어 설명하면 VLIW 기반에 하드웨어 멀티스레딩과 SIMD 연산이 지원되는 프로세서이다. 여기에 직접 프로그래밍을 할 수 있고 <a href="https://github.com/llvm-mirror/llvm/tree/master/lib/Target/Hexagon">컴파일러도 있다</a>. DSP는 클럭이 낮게 돌아가므로 빠른 계산에는 적합하지 않지만 낮은 에너지를 쓰기에 계속 돌아가야 하는 응용에 적합할 수 있다.</p>  <p align="justify">CPU/GPU/DSP 외에 M7 같이 완전히 특수 목적으로 만들어진 코프로세서가 주목을 받는 부분이다. 솔직히 나는 하드웨어 전공이 아니라 잘 모르지만 이들은 <a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit">ASIC</a> 또는 <a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGA</a>로 구현된다. 아니면, 많은 연구가 진행 중인 <a href="http://en.wikipedia.org/wiki/Reconfigurable_computing">reconfigurable computing</a>도 좋은 대안일 것이다.</p>  <p align="justify">일례로 YouTube 동영상을 모바일 기기에서 돌려보면 극히 배터리 소비가 적음을 관찰할 수 있다. 이건 CPU도 GPU도 아닌 동영상 디코딩만 따로 하는 별도의 하드웨어 장치가 있어서이다. (이걸 GPU에서 처리한다고 말할 수도 있다.)</p>  <p align="justify">좀 극단적인 아이디어이지만, 모바일 기기에서 가장 사용 빈도가 높은 응용은 아마도 웹브라우징일 것이다. 여기에는 HTML을 분석하는 작업이 필수적인데, 이 부분은 병렬화하기도 매우 어렵고, 강도 높은 연산이 필요하다. 만약 이런 부분을 하드웨어로 만든다면? 물론 쉽지는 않은 얘기지만 점점 헤테로지니어스화 되는 모바일 SoC에서 전혀 허황된 이야기는 아닐 수도 있다.</p>  <p align="justify">여기서 다시 한번 헤테로지니어스 컴퓨팅이 모바일에서 각광을 받는 이유는 저전력과 저에너지임을 알 수 있다.</p>  <p align="justify">(이런 관점에서 나는 그다지 big.LITTLE 기반의 옥타 코어가 효과적이라고 생각하지 않는다. 비록 빅과 리틀이 서로 상이한 특징이 있더라도 이들은 여전히 ARM 프로세서이다. 그 공간을 차라리 다른 특화된 가속기에 투입하는 것이 더 효과적일지도 모른다. <a href="http://en.wikipedia.org/wiki/Big.LITTLE">빅리틀의 MP 모드</a>에서 2개 정도는 빅에서 2개 정도는 리틀에서 돌려 전력/에너지를 크게 개선할 수 있는 일감을 모바일 환경에서 찾기란 쉽지 않을 것이다. 아, 너무 빅리틀을 비난하는 것 같은데, 분명 이런 시도도 큰 의미가 있고, 좋은 결과가 있는지 나도 사실 매우 궁금하다.)</p>  <p align="justify">&nbsp;</p>  <p align="justify">결론: 아무리 적게 팔린다고 예상되더라도 천 만대가 기본이다 보니 이렇게 자기 맘대로 커스텀 코프로세서도 만들 수 있구나…</p>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3048780#comments</comments>
		<pubDate>Wed, 11 Sep 2013 19:05:25 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 잦아든 멀티코어 열풍.. 모바일 열풍..! ]]> </title>
		<link>http://minjang.egloos.com/3030000</link>
		<guid>http://minjang.egloos.com/3030000</guid>
		<description>
			<![CDATA[ 
  <p align="justify">짧은 글은 거의 구글 플러스에다 쓰는 바람에 블로그 글 쓰기가 요즘 너무 귀찮아졌다. 그래서 구플에서 쓰듯이 아무렇게 써본다. 물론 구플에 이런 긴 글을 쓰자니 벅차서 블로그에다가 쓰는 것.</p>  <p align="justify">&nbsp;</p>  <p align="justify">2006년 여름, 유학 관계로 출국을 준비하고 있었는데, 나는 막 출시된 인텔 <a href="http://ark.intel.com/products/27249" target="_blank">Core 2 Duo E6400</a> 이라는 ‘듀얼코어’ 프로세서를 구하느라 용산에서 삽질을 하고 있었다. AMD가 이미 듀얼코어 CPU를 내놓았지만 인텔로서는 이 제품이 제대로 된 최초의 멀티코어였다. 이걸로 AMD를 순식간에 역전하고 무엇보다 본격적으로 멀티코어의 시대를 열었다.</p>  <p align="justify">이 멀티코어 열풍 덕에 대학원에 오니 연구주제도 멀티코어/병렬처리 분야가 가장 뜨거웠다. 컴퓨터 아키텍처는 멀티코어 이야기를 하면 안 되는 분위기였다. 컴파일러/프로그래밍 언어/소프트웨어 엔지니어링 분야에서도 병렬프로그래밍과 관련된 연구 논문이 쏟아져 나오기 시작했다. 내 분야는 아니지만 시스템이나 알고리즘 분야도 역시 멀티코어/병렬처리 관련 주제는 제일 활발한 분야라고 볼 수 있었다.</p>  <p align="justify">이 시절의 핵심 문제는 (1) 어떻게 효율적인 멀티코어 컴퓨터를 만들고 활용할 것인가, (2) 어떻게 하면 어려운 병렬 프로그래밍을 프로그래머가 쉽게 할 수 있도록 도와줄까. 아마 이렇게 축약할 수 있다. 나도 그런 시대의 흐름에 맞춰 병렬 프로그래밍 관련 주제로 어떻게 겨우 졸업을 했다.</p>  <p align="justify">대략 6-7년이 지난 요즘은 그 당시 대단했던 멀티코어 열풍은 분명 잦아든 느낌이다. 일단, 언뜻 보기에도 전산/컴퓨터 공학의 주요 학회에서도 멀티코어 자체가 더 이상 버즈워드(buzzword, 유행처럼 자주 남용되는 단어)는 아닌 것 같다(<em>citation needed</em>). 특히 2008년에 버클리가 시작한 <a href="http://parlab.eecs.berkeley.edu/endofproject" target="_blank">패러럴 컴퓨팅 연구소(ParLab)</a>의 프로젝트가 최근 종료 되었다. 마치 ‘멀티코어’ 열풍의 끝을 알리는 사건인 것 같기도 하다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">그렇다면 그 자리를 채운 것은? 바로 모바일, 클라우드, 빅데이터이다. 요즘은 정말 이와 관련된 주제가 아닌 논문은 잘 나가는 학회에 출판하기도 어려울 것 같다. 컴퓨터 아키텍처 이야기를 하자면 멀티코어 자체 보다는 모바일/클라우드 환경에 적합한 에너지 효율적인 구조가 핵심이다. 학계 뿐만 아니라 기업체도 그렇다. 인텔이 새롭게 내놓은 Haswell (하스웰/해즈웰) 역시 핵심은 에너지(=배터리 수명) 절약이다. (이것은 이미 최소 3-4년전부터 에너지 절약을 중점적으로 예상하고 연구/개발을 했다는 이야기) 시스템이나 다른 분야로 가면 말할 것도 없다. 웹 관련 분야는 모바일이 촉발한 SNS/빅데이터가 핵심인 것 같다.</p>  <p align="justify">나 역시 회사에 와서 이런 버즈워드 속에서 일을 하고 있긴 하다. 모바일/에너지 효율/<a href="http://en.wikipedia.org/wiki/Heterogeneous_computing" target="_blank">헤테로지니어스</a> 컴퓨팅이 아마도 지금 내가 하는 일을 대표할 수 있는 버즈워드이다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">그런데 따져보면 혁명적으로 새로운 것은 없다. 이렇게 말한다고 해서 지금 뜨는 분야를 결코 무시하는 것이 아니다. 오히려 그 문제의 본질을 보면 결국 근본적인 전산학 문제로 귀결된다. 게다가 그 문제를 푸는 방법론 역시 비슷한 것이 많다.</p>  <p align="justify">일단, 지금은 잦아들었다고 말한 멀티코어는 새로운 문제였던가? 아니다. 이미 수퍼 컴퓨터 시절에 있었던 문제가 데스크탑 수준으로 내려온 것이다. 병렬 프로그래밍은 과거에도 있었는데 이제는 일반 프로그래머도 해야 하니 더 관심이 커졌다.</p>  <p align="justify">모바일 역시 그러하다. 데스크탑에서 풀던 문제를 이제 모바일 규모로 풀어야 하니 새로운 변수가 추가된 것이다. 과거에는 성능(얼마나 빨리 계산할 수 있는가)이 제 1의 평가 잣대였다면, 이제는 전력/에너지 소비라는 기준이 더해졌다. 클라우드? 분명 과거에는 해보지 않았던 규모이기는 하지만 <a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=20130610090358">클라우드 컴퓨팅이 가진 문제</a> 중 상당 수는 효율적인 자원의 배치와 사용인데, 이런 문제는 전산학 역사에서 빠진 적이 없었다. 빅데이터 혹은 머신러닝? 역시 핵심은 수학과 통계에 있다.</p>  <p align="justify">컴퓨터 분야는 늘 빠르게 변화하는 곳이라고 말한다. 정말 그렇기는 하다. 대학원 시작할 때와 졸업할 때, 이렇게 유행하는 주제가 확 바뀌었으니. 그런데 말했듯이 그 문제의 본질은 결국 우리가 늘 풀어왔던 문제들이다. 그 응용이 계속 바뀌는 것이지 기본 기술이 바뀐 것은 아니다. 클라우드 서버를 지탱하는 가장 근원적인 운영체제 기술은 30년 전과 다를 바가 없다. 모바일에 들어가는 프로세서 역시 기본구조는 1970년대에 나온 최초의 마이크로프로세서와 맥락을 같이한다. 빅데이터는 내가 문외한이라 말을 하기 겁나는데 수학과 통계에서 회귀분석의 역사는 아마 100년은 되지 않았을까?</p>  <p align="justify">또, 멀티코어 열풍이 지나갔다고 말했지만, 이건 어디까지 논문 쓰는 것에 최적화된 학계의 이야기이다. 실제 회사에서는 여전히 이 문제는 중요하다. 모바일/클라우드/빅데이터에도 멀티코어는 어디를 가나 쓰이므로 죽은 문제는 결코 아니다. 다만, 논문 리뷰하는 교수와 친구들이 덜 흥미를 가지고 잘 떨어뜨리겠지. 논문으로 <strike>대충</strike> 내놓은 결과 말고, 정말 돌아가는 결과물은 이제부터가 시작이라 할 수 있다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">무슨 말을 하는지 왔다리 갔다리 하는데, 버즈워드에 대해 너무 쉽게 휘둘리는 것은 경계를 하는 것이 좋다. 물론, 논문이 당장 급한 대학원생들은 그런 시대 흐름을 잘 좇아야 한다 ㅎㅎ 아, 회사는 말할 것도 없고.</p>  <p align="justify">90년대 말에는 자바가 가장 뜨거운 키워드였다고 한다. 아마 지금으로부터 3-4년이 지나면 모바일/클라우드/빅데이터 열풍이 분명 수그러 들 것이다. 그냥 늘 있는 문제로 바뀌게 될 것이다. 그 뒤에는 또 무엇이 나오려나? 그러나 그 어떤 열풍이 있어도 여전히 (비교에 기반한) 정렬 문제는 O(nlogn) 보다 빠를 수는 없다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">교훈: 응용은 유행을 타지만 문제의 핵심과 방법론은 천천히 움직인다. 나는 버즈워드인 모바일에서 일은 하지만 구닥다리 C++로 최소 15년은 된 것 같은 논문 속의 알고리즘을 보고 있다.</p>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3030000#comments</comments>
		<pubDate>Mon, 10 Jun 2013 07:29:27 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 2013년의 베트남, 1988년의 대한민국의 코딩 교육 ]]> </title>
		<link>http://minjang.egloos.com/3026418</link>
		<guid>http://minjang.egloos.com/3026418</guid>
		<description>
			<![CDATA[ 
  <p align="justify">창조경제 덕분인지 프로그래밍/코딩 교육 논쟁이 일고 있다. (프로그래밍과 코딩은 같은 단어라고 생각하므로 이하 코딩으로 씀.) 정부에 계신 분들도 나름 다 잘 먹고 잘 살아보겠다고 하는 일이니 너무 비난조로만 말할 것은 아닌 것 같고, 여러 분야의 의견을 구해 좋은 방향으로 진행이 되면 좋겠다. 최근에 읽은 충격적인 베트남의 전산 교육과 내가 초등학교 시절에 배웠던 프로그래밍 수업에 대한 경험담으로 나의 생각을 간단하게 말해보고자 한다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>2013년, 베트남의 전산/코딩 교육</strong></p>  <p align="justify">두 달 전, 상당히 <a href="http://neil.fraser.name/news/2013/03/16/" target="_blank">놀라운 블로그 글을 읽었다</a>. 이 글의 내용을 먼저 옮겨본다. 구글의 교육 부서에서 일하는 Neil Fraser 씨는 베트남에 가서 어떻게 학교에서 전산(computer science)이 교육되고 있는지 탐방을 하고 그 경험담을 적었다.</p>  <p align="justify">베트남에서는 초등학교 2학년부터 컴퓨터 교육이 시작된다는데 시작은 웃기다. 플로피 디스켓이 나온다! 초등학교 3학년은 윈도우와 워드 사용 법을 배운다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds27.egloos.com/pds/201305/24/29/d0033129_519edce8ea8ef.jpg" width="406" height="284" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201305/24/29/d0033129_519edce8ea8ef.jpg', 406, 284);" /></div>&nbsp;<div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds21.egloos.com/pds/201305/24/29/d0033129_519edcec47392.jpg" width="429" height="284" onclick="Control.Modal.openDialog(this, event, 'http://pds21.egloos.com/pds/201305/24/29/d0033129_519edcec47392.jpg', 429, 284);" /></div></p>  <p align="center">(사진은 모두 <a href="http://neil.fraser.name/news/2013/03/16/" target="_blank">Neil Fraser</a> 씨의 블로그에서 가져옴.)</p>  <p align="justify">여기까지 봤을 때는 그냥 베트남 컴퓨터 교육을 비판하려고 하는 것인가 했다. 그런데 4학년부터 <a href="http://ko.wikipedia.org/wiki/%EB%A1%9C%EA%B3%A0_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%96%B8%EC%96%B4)" target="_blank">Logo라는 프로그래밍 언어</a>로 코딩을 시작한다고 한다. 그리고 5학년이 되면 제법 복잡한 그림도 그린다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds27.egloos.com/pds/201305/24/29/d0033129_519edcef27841.jpg" width="351" height="234" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201305/24/29/d0033129_519edcef27841.jpg', 351, 234);" /></div>&nbsp;<div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201305/24/29/d0033129_519edcf1f171c.jpg" width="484" height="234" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201305/24/29/d0033129_519edcf1f171c.jpg', 484, 234);" /></div></p>  <p align="justify">여기서 Neil Fraser 씨는 미국의 전산 교육과 간단히 비교한다. 그가 샌프란시스코의 몇몇 학교에 가서 과학과 컴퓨터를 가르쳐보니 11-12학년 (우리의 고2-3)인 학생들이 HTML 이미지 태그와 씨름하고 있었다고 한다. 순환문/조건문 같은 프로그래밍의 기본 개념에 대해 잘 이해하지 못했다고 한다. 전산 관련 숙제는 학교에서 금지되고 있었다.</p>  <p align="justify">이어 Fraser 씨는 그 베트남 학교에 무엇을 도와줄 수 있느냐고 물었는데, 의외로 교육용 소프트웨어가 부족하다는 답변을 들었다. 그래서 <a href="http://blockly-demo.appspot.com/blockly/apps/maze/index.html" target="_blank">Blocky Maze라는 프로그램을 만들었다</a>. 나도 직접 프로그램을 가지고 놀아봤는데 기초적인 프로그래밍의 개념인 명령, 조건, 순환 문의 개념을 심어줄 수 있는 훌륭한 프로그램이었다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds27.egloos.com/pds/201305/24/29/d0033129_519edcf4d335c.png" width="500" height="462.786259542" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201305/24/29/d0033129_519edcf4d335c.png', 524, 485);" /></div></p>  <p align="center">미로를 찾아가는 알고리즘을 명령, 조건 분기문, 순환문의 블럭을 조합해 코딩함.</p>  <p align="justify">이 프로그램을 받은 학교는 이걸 토대로 전산 수업을 더 만들 것이라고 약속했다. 그런데 두 명의 전산 교사를 구할 돈이 없었다. 전산 교사의 한 달 월급은 단 미화 100달러. Fraser 씨는 바로 돈을 뽑아 학교에 주고 내년까지 수업을 할 수 있도록 도왔다.</p>  <p align="justify">그렇다면 베트남의 11학년 (대략 고2)는 어떤 수준의 내용을 배울 것인가? 그래서 Fraser 씨는 한 고등학교의 전산 수업에 사전 통지 없이 불쑥 찾아 갔다고 한다. 그랬더니 아이들은 아래와 같은 놀라운 문제를 풀고 있었다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds26.egloos.com/pds/201305/24/29/d0033129_519edcf846d96.jpg" width="500" height="357.61589404" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201305/24/29/d0033129_519edcf846d96.jpg', 604, 432);" /></div></p>  <p align="center">이 프로그래밍 문제의 입력 파일은 <a href="http://neil.fraser.name/news/2013/cs-vn/data.txt" target="_blank">여기서 받을 수 있다</a>.</p>  <p align="justify">문제를 해석해보면 루트 2 길이의 막대를 한 변이 1인 격자에 대각선으로 놓아 미로를 만든다. 막대로 둘러 쌓인 공간은 사방이 모두 막힌 닫힌 공간도 있을 것이고 열린 공간도 있을 것이다. 여기서 닫힌 공간의 총 개수를 구하고 그 중에서 가장 큰 것의 넓이를 구하라는 것.</p>  <p align="justify">헐… 이건 도대체 무엇인가. 이 문제를 본 동료 구글 원은 상당히 어려운 축에 속한다고 평가했다. 나도 문제를 좀 보고 생각해봤는데, 바로 즉석 코딩을 하라면 벅찰 것 같았다. 그런데 만나본 베트남의 11학년 아이들의 대부분은 이 문제를 파스칼(Pascal) 프로그래밍 언어로 45분 정도에 다 구현하고 풀었다고 한다.</p>  <p align="justify">(나의 생각: 유사한 문제로 훈련을 했다면 충분히 가능하다. 마치 어려운 미적분학 문제도 연습만 하면 척척 풀 수 있듯이. 따라서 이 문제 자체를 풀었다는 것에 너무 놀랄 필요는 없다고 본다.)</p>  <p align="justify">Fraser 씨는 자신의 경험을 베트남의 고등학교에 알려주려고 했는데 오히려 배웠다고 한다. 베트남은 어떻게 전산 교육이 이뤄져야 하는지 잘 보여주는 예라고 칭송한다. <strong>그는 모든 학생들에게 일찍 코딩 교육을 시킬 것을 주문하고, 코딩에 열정적인 학생들에겐 성장할 수 있는 무한한 기회를 줘야 한다고 주장한다. </strong>(원 블로그에 강조가 되어있길래 나도 강조를 함.)</p>  <p align="justify">베트남의 이런 전산 교육이 도입된 것은 얼마 되지 않은 일이라고 한다. Fraser 씨는 아직까지는 대학교의 전산 교육 과정에 대해서는 좋은 인상을 못 받았다. 그런데, 이제 어려서부터 전산을 배운 학생들이 대학교에 가면 크게 바뀔 것이라고 이야기 한다.<span style="font-size: 9pt;">&nbsp;</span></p>  <p align="justify">Fraser 씨는 이제 강도 높게 미국의 전산 교육에 대해 비판한다. 전산은 수학/물리/영어 같은 중심 과목이 아니다. 학교와 선생님들은 전산학 교육을 해야 할 필요성을 못 느끼고 웹 페이지 만드는 것을 컴퓨터 교육으로 착각하고 있다. 학부모는 대학교 입시와 직접 상관이 없으므로 반대하고, 학생들 역시 전산은 너드(…)라는 인식이 있어 기피한다. Fraser 씨는 구글에서 컴퓨터 교육 관련 일을 하고 있는데 막대한 투자와 노력을 하였지만 미미한 영향만 있었다고 실토한다. 그러면서 현재 미국에서 전산 교육을 전체적으로 바꿀 희망은 적다고 한탄한다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>1988년, 대한민국의 코딩 교육</strong></p>  <p align="justify">이제는 내 경험담을 써보자. 벌써 25년 전이다. 1998년, 내가 초등학교(국민학교) 저학년일 때 학교에 삼보 애플 II 호환 컴퓨터 30-40여 대가 들어왔다. 컴퓨터 수업을 배우고 싶은 학생들이 방과 후 수업으로 컴퓨터를 배울 수 있었다. 당시 컴퓨터는 8비트였으며 모니터는 녹색의 단색이었다. 나는 그때 컴퓨터를 어떻게 영어로 쓰는지도 몰랐다. 그런 애들 데려다 놓고 학교에서 가르친 것이 뭐냐면 그 유명한 <a href="http://en.wikipedia.org/wiki/GW-BASIC" target="_blank">BASIC 프로그래밍 언어</a>였다. 그렇게 처음 컴퓨터 프로그래밍을 접했다.</p>  <p align="justify"></p>  <div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px">   <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px">10 PRINT HELLO<br />
20 <span style="color: #0000ff">FOR</span> I = 1 <span style="color: #0000ff">TO</span> 10 <span style="color: #0000ff">STEP</span> 1<br />
30 SUM = SUM + I<br />
40 <span style="color: #0000ff">NEXT</span> I<br />
50 PRINT I</pre><br />
</div><p align="justify">때마침 1989년부터 개인용 컴퓨터(PC) 열풍이 불었다. 바로 XT라고 불리는 16비트 컴퓨터의 등장과 함께.</p><p align="center"><img src="http://img2.ruliweb.com/img/img_link6/249/248282_2.jpg" width="640" height="433" /></p><p align="justify">위 그림에 있는 16비트 ‘금성’ PC 파트너를 89년에 구입하고 집에서 열심히 코딩을 했던 기억이 난다. 분명 내 기억에 초등학교 실과 같은 과목에서 간단히 컴퓨터 코딩하는 것이 있었다. 프로그램을 만들고 디스켓에 SAVE로 저장하던 기억이 난다. 컴퓨터 학원도 그 당시에 유행을 했었는데 학원에서 배운 건 GW-BASIC이었다.</p><p align="justify">&nbsp;</p><p align="justify"><strong>2013년, 대한민국의 코딩 교육? 있기는 있지만…</strong></p><p align="justify">아직 초등학교 교사이신 어머니께 요즘에는 학교에서 코딩 같은 거 배우냐고 물어봤다. 지금은 프로그래밍은 없고 웹 페이지와 워드 프로세서 같은 것을 가르친다고 한다. 위에서 얘기했듯이 미국의 현실과 비슷한 것 같다.</p><p align="justify">별로 놀랄만한 사실은 아니라고 본다. 인터넷과 멀티미디어가 되는 컴퓨터의 보급 이후, 뚜렷한 목표가 없는 단순 코딩 교육보다는 컴퓨터 활용이 더 시급한 컴퓨터 교육의 목표가 될 수 있다고 본다.</p><p align="justify">1988년에는 컴퓨터가 인터넷에 연결된 것도 아니고, 멀티미디어가 되던 것도 아니고, 워드 프로세서가 있던 것도 아니었다. 어린 아이가 할 수 있는 것이라곤 BASIC 프로그래밍과 조잡한 게임 밖에 없었다. 특별히 그 당시 코딩이 중요함을 인식해서 코딩 교육을 했다고 생각하지는 않는다. 어쩌다 보니 그냥 자연스럽게 “컴퓨터 교육” = “코딩 교육”이 되었다. 그래서 그런가 75~85년 생 중에 어려서 프로그래밍을 시작한 사람들이 많고 이제는 우리나라 개발자의 주축을 이루는 나이가 되었다. (여기서, 한탄을 해야 하는 건가?)</p><p align="justify">그런데, 현재 일부 실업계 고교에 한정된 이야기지만, 수학능력 시험에 직업탐구라는 과목이 있어서 코딩 교육을 하기는 한다. 하지만 수학능력 “직업탐구 프로그래밍”시험에 출제되는 문제를 보면, 좀 답답하긴 하다. 거의 쓰이지도 않는 Visual Basic 6과 국제표준과 현업과 거리가 먼 학교 시험용 C 프로그래밍을 가르치고 있다.</p><p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201305/24/29/d0033129_519edd006f3f4.png" width="500" height="369.328493648" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201305/24/29/d0033129_519edd006f3f4.png', 551, 407);" /></div></p><p align="center">2013년도 대학수학능력 직업탐구영역 (프로그래밍)의 한 시험 문제: int main()도 아닌 void main()을 보라…</p><p align="justify">그렇다면 일반 교육 과정에선 정말 코딩 교육이 없는 것일까? 아니다. 나는 형태는 다르지만 어느 정도 있다고 생각한다.</p><p align="justify">컴퓨터 프로그래밍에서 프로그래밍 언어의 문법을 익히는 것도 중요하지만, 그 보다는 프로그래밍을 하는데 필요한 사고능력, 즉 <a href="http://en.wikipedia.org/wiki/Computational_thinking" target="_blank">전산적 사고능력</a>(computational thinking)을 기르는 것이 더 중요하다고 본다. 전산학과 같으면 자료구조/알고리즘 같은 과목이 이것을 다룬다고 볼 수 있지만, 이미 우리는 수학시간에 훌륭한 이 사고능력을 배우고 있다. 바로 수학적 귀납법과 순서도에서.</p><p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds26.egloos.com/pds/201305/24/29/d0033129_519edd0391ef3.jpg" width="500" height="376.146788991" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201305/24/29/d0033129_519edd0391ef3.jpg', 654, 492);" /></div></p><p align="center">책꽂이에 있는 1994년에 출판된 “수학의 정석”을 직접 사진 찍음.</p><p align="justify">고교시절에 분명 수학적 귀납법과 순서도를 배웠고 <a href="http://ko.wikipedia.org/wiki/%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD%EC%9D%98_%EA%B3%A0%EB%93%B1%ED%95%99%EA%B5%90_%EC%88%98%ED%95%99_%EA%B5%90%EA%B3%BC%EB%AA%A9" target="_blank">지금도 수학 교과과정에 잘 있다</a>. 20년 전에 공부한 수학의 정석만 봐도 순서도 단원이 있고, 왼쪽 아래에 “알고리즘(algorithm)”의 의미를 설명하고 있다. 이 단원을 보면 프로그래밍에 핵심적인 개념을 사실상 다 포함하고 있다: (1) 명령의 개념, (2) 순차적 실행, (3) 조건문, (4) 반복문. 초등학교 시절 GW-BASIC이라도 한 사람은 이 단원은 솔직히 거저 먹는 것과 다름이 없었다. (문제는 시험에서 비중이 매우 낮지만) 또, 수학 선택 과목 중에 이산수학도 있다. <a href="http://ko.wikipedia.org/wiki/%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD%EC%9D%98_%EA%B3%A0%EB%93%B1%ED%95%99%EA%B5%90_%EC%88%98%ED%95%99_%EA%B5%90%EA%B3%BC%EB%AA%A9#.EC.9D.B4.EC.82.B0_.EC.88.98.ED.95.99" target="_blank">보다시피 전산학과에서</a> 배우는 자료구조/알고리즘과 같다. (역시 문제는 이걸 선택하는 학생이 얼마나 될까.)</p><p align="justify">하지만 안타깝게도 이 단원이 프로그래밍의 핵심적인 내용이라는 점이 잘 인지 안 되고 있다. 코딩 교육은 별거 없다. 이런 수학 단원에서 나오는 것만 직접 컴퓨터로 작성해도 된다. (어떤 언어를 쓸 것인지도 중요한 선택이지만 그것까지 여기서 논하기는 벅차다.) 뿐만 아니라 수학/통계/물리 시간에도 얼마든지 적극적으로 코딩을 활용할 수 있는 분야가 많다.</p><p align="justify">&nbsp;</p><p align="justify"><strong>코딩 교육은 필요한가? 전산 교육은 필요한가?</strong></p><p align="justify">논쟁의 초점은 좁게는 코딩/프로그래밍 교육, 약간 넓게는 전산과학을 정규 교육 과정에 넣느냐 마느냐인 것 같다. 결론부터 말하면 나는 기초적인 전산/코딩 교육은 이제는 어느 정도는 해야 한다고 생각한다. 그 이유는 단순하다. 이제 컴퓨터의 활용 능력이 수학/물리를 배우는 것 만큼이나 이제 중요해졌기 때문이다.</p><p align="justify">학교에서 수학/물리/화학 등을 고교 필수 과정으로 배우는 건, 나중에 그걸 전공하지 않더라도, 일상 생활에 그 지식이 유용하다는 합의가 있어서이다.&nbsp; 컴퓨터 프로그래밍도 그 수준에 도달했다고 본다. F=ma가 중요하다고 믿는다면, 이제는 전산적 사고 능력과 그것을 컴퓨터가 실행하게 만드는 코딩 능력도 중요해졌다는 것이 나의 생각이다.</p><p align="justify">컴퓨터에서 웹페이지 만들고 워드 프로세서를 배우는 것도 분명 컴퓨터의 활용 방법이다. 그런데, 프로그래밍 언어와 코딩은 컴퓨터를 가장 효과적으로, 창의적으로 (=창조적으로) 사용할 수 있게 해주는 강력한 도구이다. 컴퓨터 소프트웨어로 세상이 얼마나 혁신적으로 바뀔 수 있는지 우리는 매일 보면서 살고 있다. 그 밑거름에는 코딩이 있다. 더 나가 소프트웨어를 작동 시키는 디지털 컴퓨터는 보통 하드웨어라고 생각하지만, 그 속에는 소프트웨어적인 사고 방식이 적용되어있다. 결국 컴퓨터 하드웨어/소프트웨어 모두 밑거름에는 전산 원리가 있다.</p><p align="justify">컴퓨터 코딩은 이미 수학, 통계, 과학 영역에서 핵심적으로 사용되고 있다. 수학/통계에 필수로 쓰이는 프로그램(매쓰매티카, 매트랩, R)은 그냥 하나의 프로그래밍 언어이다. 물리/화학 전공하는 사람 중에도 코딩을 반드시 해야만 되는 실험 및 연구 분야도 많다.</p><p align="justify">이런 직접적인 필요가 아닌, 그저 교양 지식의 일부로라도 배울 필요가 있다. F=ma에서도 이야기 했지만, 최신 현대 물리는 몰라도 교육 과정에서 배우는 기초 물리 덕에 만유인력이나 뉴튼의 법칙은 알게 되었다. 아직까지 컴퓨터 기술이 화학이나 인쇄술 만큼 유비쿼터스하게 퍼져있지는 않다고 본다. 그렇지만 컴퓨터는 거의 모든 일상 생활에 자리잡고 있다. 이 컴퓨터를 작동시키는 것이 바로 프로그램이고, 코딩 능력이 있어야 프로그램을 만들 수 있다. 컴퓨터를 작동 시키는 핵심 원리를 학교에서 배우는 것은 그 자체만으로도 이제 가치가 있다.</p><p align="justify">&nbsp;</p><p align="justify"><strong>거창한 구호는 제발. 코딩/전산 교육의 목표는 단순하고 장기적이어야 한다.</strong></p><p align="justify">정부가 코딩/전산 교육을 한다고 하는데, 부디 “제2의 빌 게이츠, 제2의 저커버그” 와 같은 거창한 구호는 안 보았으면 한다. 수학이나 과학 교육 과정을 만드는데 필즈상이나 노벨상을 목표로 하지는 않는다. 기초적인 소양을 갖추기 위해서다. 코딩/전산 교육이 정규 교육이 된다면 딱 이 정도면 된다. 21세기 컴퓨터가 도처에 깔린 세상을 사는데 필요한 - 마치 수학과 과학 같은 - 지식을 더 쌓는 것이다.</p><p align="justify">물론, 거창한 구호를 내놓는 이유를 이해 못하는 것은 아니다. 분명 수업 부담이 될 수 있으므로 많은 사람의 동의를 얻으려면 뭔가 그럴듯한 목표가 필요 하다. 이러한 측면에서 코딩 교육을 과장하여 광고하는 건 이해할 수 있지만, 실제 교육 과정을 만든다면, 정권의 눈치를 보며 단기 목표에 급급할 것이 아니라, 기초 수학, 과학 과정을 만들듯이 큰 틀에서 생각해야 한다.</p><p align="justify">결국 코딩 교육의 목적은 제2의 스티브 잡스 같은 허황된 목표가 아닌 단순해야 한다. 특히 어린 아이들에게는 컴퓨터 프로그래밍에 흥미를 가지도록 유도하는 것이 중요하다. 재미 없는 아이들은 정규 과목에서 배우는 정도만 공부하면 되고, 흥미를 가지는 아이들에게는 집중적으로 여러 교육의 기회를 주면 된다. 물론, (요즘 같이 이공계가 더 이상 인기가 아닌 시절에 얼마나 성공적일지는 나도 걱정이지만…)</p><p align="justify">혹자는 코딩 교육에 대해 또 다른 사교육이니 학업 부담이 된다고 하는데, 나도 인정한다. 하지만 해결할 수 있는 방법은 있다. 방금 이야기 했듯이 공허한 구호 속에 근시안적으로 진행하지 말고, 기존의 수학/과학 시간을 점차적으로 활용하는 방법으로 추진하면, 코딩 교육을 교육과정에 안착시킬 수 있다고 본다. 다른 과목의 부담을 줄이는 방법도 있다. 수학이 너무 지나치게 미적분학에 집중된 느낌인데, 이 부분을 조금 줄이고, 점점 중요해지는 통계와 전산적 사고 능력을 키울 수 있는 이산 수학을 조금이라도 포함시키면 어떨까 한다.</p><p align="justify">&nbsp;</p><p align="justify">간단한 요약:</p><ul>  <li>베트남이 최근 실시한 프로그래밍/전산 교육은 좀 많이 무섭다. </li>  <li>우리나라도 과거에는 프로그래밍을 하였으나 요즘에는 웹페이지/워드프로세서 위주. 미국도 그러하다. </li>  <li>하지만, 수학적 귀납법/순서도/이산수학에서 이미 어느 정도 프로그래밍의 핵심 개념은 가르친다고 볼 수 있다.</li>  <li>코딩은 컴퓨터를 가장 효과적으로, 창의적으로, 그리고 창조적으로 사용할 수 있게 한다.</li>  <li>코딩 수업의 목표는 제2의 저커버그, 빌 게이츠, 스티브 잡스가 돼서는 안 된다. 건실한 교육과정과 흥미에 초점을 맞춰야 한다.</li></ul><p>다시 한 줄 요약:</p><ul>  <li>F=ma가 중요하다고 생각하는가? 그렇다면 컴퓨터를 작동 시킬 수 있는 코딩 지식도 이제는 그 만큼 중요해졌다.</li></ul>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3026418#comments</comments>
		<pubDate>Fri, 24 May 2013 03:22:44 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 내가 좋아하지 않는 C/C++의 레거시 ]]> </title>
		<link>http://minjang.egloos.com/3011317</link>
		<guid>http://minjang.egloos.com/3011317</guid>
		<description>
			<![CDATA[ 
  <p align="justify">C 언어는 컴퓨팅 파워가 매우 척박했던 시절에 만들어진 언어였다. 이후 C99에 이르러 상당히 많은 진화를 하긴 했지만, 워낙 옛날부터 널리 쓰였기에 아무리 발전을 하여도 여전히 적지 않은 레거시(legacy)가 많은 이들에게 고통을 주고 있다. 하위 호환성 유지라는 이유도 있지만 솔직히 “귀찮다. 그냥 냅두자.”와 같은 귀차니즘도 분명 큰 이유다. C의 최대 레거시라면 단연 문자열 형의 부재를 꼽고 싶다. 하지만 C 언어가 나왔을 당시를 생각하면 문자열의 길이를 저장할 공간 조차 배부른 사치였으므로 이해는 한다. 그 다음으로 꼽고 싶은 것은 복잡한 컴파일/빌드 과정과 전처리기이다. 이건 C++에도 고스란히 적용된다. 오늘은 여기에 대한 잡생각.</p>  <div align="justify">   <div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">     <div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet">       <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum1">   1:</span> <span style="color: #008000">// Defined getFoo()</span></pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum2">   2:</span> <span style="color: #cc6633">#include</span> <span style="color: #006080">"foo.h"</span></pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum3">   3:</span>&nbsp; </pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum4">   4:</span> <span style="color: #0000ff">extern</span> <span style="color: #0000ff">int</span> getMagic();</pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum5">   5:</span>&nbsp; </pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum6">   6:</span> <span style="color: #0000ff">int</span> main(<span style="color: #0000ff">void</span>) {</pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum7">   7:</span> <span style="color: #cc6633">#ifdef</span> SUPER_MAGIC</pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum8">   8:</span>   <span style="color: #0000ff">return</span> getMagic();</pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum9">   9:</span> <span style="color: #cc6633">#else</span></pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum10">  10:</span>   <span style="color: #0000ff">return</span> getFoo();</pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum11">  11:</span> <span style="color: #cc6633">#endif</span></pre>      <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum12">  12:</span> }</pre></div>  </div></div><p align="justify">썰렁한 위의 C/C++ 코드를 보고 어떻게 실행될 것인지 예측할 수 있을까?</p><p align="justify">잠시 딴 소리를 해보자면, C/C++ 언어는 정적 혹은 렉시컬 스코핑(lexical scoping) 언어라서 소스 코드만 보면 이 변수가 어디서 값을 가져 오는지 대부분 알 수 있고 고로 프로그램의 실행 결과도 일반적으로 예측 가능하다. 반대 개념이 동적 스코핑인데, 이를 지원하는 언어는 변수 값의 결정이 실행 시간의 함수 호출 문맥에 달려있다. 그래서 컴파일 시간에는 그 값의 예측이 어렵다. 물론, 지금 이 썰렁한 코드는 정적/동적 스코핑과 아무런 상관이 없다. 그런데 아무리 정적 스코핑인 언어라 하더라도 이 코드만 봐서는 수행을 예측하기 어렵다. 정적 스코핑의 장점을 고스란히 날려버리는 것이다.</p><p align="justify"><br />
</p><p align="justify">코드 해석을 어렵게 하는 레거시 요소를 나열하면 다음과 같다:</p><p align="justify">(1) 라인 2: “foo.h”가 어디서 오는지 명확히 알 수 없다. 아주 초보자 시절에는 “따옴표는 현재 디렉토리에서 파일을 찾는다”라고 배웠으니 foo.h 파일이 지금 이 소스 파일과 같은 디렉토리에 있을 것이라고 예측할 수 있다. 하지만 현실은 이러하지 않다는 걸 잘 안다. 컴파일러 –I 옵션으로 검색할 #include 디렉토리 목록을 따로 지정할 수 있다. 예를 들어, “foo.h”가 foo라는 디렉토리 밑에 있을 수도 있고 goo라는 디렉토리 밑에 있을 수 있다. 극단적인 예로, “foo.h” 파일이 다른 이름의 디렉토리 밑에 모두 있고, 컴파일러 옵션에서 –I 의 값을 바꿈으로써 다르게 인쿠르드 되는 것도 가능하다. 실제로 이런 경우를 봤다! 더 난해한 경우도 있다. 예를 들어, “foo.h” 파일이 어떤 파서에 의해 빌드시 생성되는 부산물일 수 있다. 그리고 이 파일의 위치는 소스 트리가 아니라 빌드 디렉토리 내에 있을 수 있다. 실제로 이런 경우가 있다. 그러면 아무리 “foo.h”를 소스 트리 내에서 뒤져도 안 나온다.</p><div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper"><span style="font-size: 8pt; line-height: 12pt;">/src/foo/foo.h</span><br />
<pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet">/src/goo/foo.h<br />
/build/generated_code/foo.h</pre></div><p align="justify">(2) 라인 4: getMagic이 다른 곳에 정의가 되어있다. 링크 시간에 이 정의를 찾아야 하는데 어떤 오브젝트 파일 또는 라이브러리에서 참조해야 하는지 알 수가 없다. 역시 컴파일/링킹 시 옵션에 따라 라이브러리를 바꿔치기 하면 다른 결과가 나올 수 있다. (동적 라이브러리면 더 복잡하겠지만)</p><p align="justify">(3) 라인 8이 실행될지 라인 10이 실행될지는 SUPER_MAGIC 이라는 #define 값에 의존적이다. 이 소스 코드만 봐서는 SUPER_MAGIC이 정의 되는지 알기 어렵다. 일단, “foo.h”와 “foo.h”가 다시 포함하는 모든 파일을 뒤져야 한다. 있으면 다행인데 없어도 얼마든지 Makefile에서 –D 컴파일러 옵션으로 지정될 수 있다.</p><p align="justify">이렇게 소스 코드에서 보이지 않는 컴파일링/빌딩 과정에서 코드 해석에 영향을 주는 변수가 많다. 요약하면:</p><ul><li><div align="justify">-I 로 주어지는 #include 탐색 폴더 목록</div></li><li><div align="justify">-D 로 주어지는 각종 #define 값들</div></li><li><div align="justify">링크될 라이브러리</div></li></ul><p align="justify">약간 부연 설명하면 이러하다.</p><p align="justify">-I 옵션은 생각보다 매우 남발된다. 대규모의 프로젝트는 소스 파일이 디렉토리 구조로 이루어져있다. 그런데 많은 곳에서 귀찮으니 각 폴더를 –I 로 해버리고 파일 이름만 #include에 적곤 한다. 이러면 쓰는 사람은 디렉토리 구조를 안 적어도 되는 약간의 편리함이 있다. 또, “../../” 같은 지저분한 상대 경로를 피할 수 있는 장점도 있다. 하지만 처음 접하는 사람에겐 당장 이 헤더 파일이 어디에 있는지부터 찾아야 한다. 당연히 편집기에서 이 파일을 바로 열 수도 없다.</p><p align="justify">위에서 언급한 –I, –D, 라이브러리 목록은 주로 Makefile에서 정의 된다. 문제는 이 Makefile이 매우 복잡할 수 있다는 것이다.</p><p align="justify">간단히 하나의 Makefile만 있으면 모르겠는데, Makefile.common 부터 시작해, 복잡한 디렉토리 구조마다 각각 자식 Makefile이 있다. Makefile의 호출 역시 “make FOO=true” 처럼 주어질 수 있다. 그러면 이 FOO 변수에 따라 또 복잡하게 $(CXX_FLAGS) 같은 값이 변경될 수 있다. 그래서 최종적으로 특정 파일이 어떤 컴파일 옵션으로 빌드 되는지 쉽게 알 수 없다. 특히, 남이 만들어 놓은 복잡하고 지저분한 Makefile의 해독은 암호 수준이다. 결국 Makefile을 돌려보면서 무수한 출력 더미 속에서 찾아 내기 일쑤다. 예를 들어, LLVM의 한 소스에 주어지는 컴파일 옵션은 이러하다. (천만 다행으로 Visual Studio에서는 매우 간편히 각 소스 파일이 최종적으로 받는 모든 컴파일 옵션을 볼 수 있다.)</p><p align="justify"></p><div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">  <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet">/MP /we<span style="color: #006080">"4238"</span> /we<span style="color: #006080">"4239"</span> /GS /TP /W3 /wd<span style="color: #006080">"4065"</span> /wd<span style="color: #006080">"4146"</span> /wd<span style="color: #006080">"4180"</span>/wd<span style="color: #006080">"4181"</span><br />
/wd<span style="color: #006080">"4351"</span> /wd<span style="color: #006080">"4355"</span> /wd<span style="color: #006080">"4503"</span> /wd<span style="color: #006080">"4551"</span> /wd<span style="color: #006080">"4624"</span> /wd<span style="color: #006080">"4715"</span> /wd<span style="color: #006080">"4800"</span><br />
/Zc:<span style="color: #0000ff">wchar_t</span> /I<span style="color: #006080">"C:/Users/minjang/Downloads/build/lib/Analysis"</span><br />
/I<span style="color: #006080">"C:/Users/minjang/Downloads/llvm-3.2.src/llvm-3.2.src/lib/Analysis"</span><br />
/I<span style="color: #006080">"C:/Users/minjang/Downloads/build/include"</span><br />
/I<span style="color: #006080">"C:/Users/minjang/Downloads/llvm-3.2.src/llvm-3.2.src/include"</span><br />
/Zi /Gm- /Od /Ob0 /Fd<span style="color: #006080">"C:/Users/minjang/Downloads/build/lib/Debug/LLVMAnalysis.pdb"</span><br />
/fp:precise /D <span style="color: #006080">"WIN32"</span> /D <span style="color: #006080">"_WINDOWS"</span> /D <span style="color: #006080">"_DEBUG"</span> /D <span style="color: #006080">"_VARIADIC_MAX=10"</span><br />
/D <span style="color: #006080">"_CRT_SECURE_NO_DEPRECATE"</span> /D <span style="color: #006080">"_CRT_SECURE_NO_WARNINGS"</span> /D <span style="color: #006080">"_CRT_NONSTDC_NO_DEPRECATE"</span><br />
/D <span style="color: #006080">"_CRT_NONSTDC_NO_WARNINGS"</span> /D <span style="color: #006080">"_SCL_SECURE_NO_DEPRECATE"</span><br />
/D <span style="color: #006080">"_SCL_SECURE_NO_WARNINGS"</span> /D <span style="color: #006080">"__STDC_CONSTANT_MACROS"</span> /D <span style="color: #006080">"__STDC_FORMAT_MACROS"</span><br />
/D <span style="color: #006080">"__STDC_LIMIT_MACROS"</span> /D <span style="color: #006080">"_HAS_EXCEPTIONS=0"</span> /D <span style="color: #006080">"CMAKE_INTDIR=\"Debug\""</span><br />
/D <span style="color: #006080">"_MBCS"</span> /errorReport:prompt /WX- /Zc:forScope /RTC1 /GR- /Gd /MDd /Fa<span style="color: #006080">"Debug"</span><br />
/nologo /Fo<span style="color: #006080">"LLVMAnalysis.dir\Debug\" /Fp"</span>LLVMAnalysis.dir\Debug\LLVMAnalysis.pch" </pre></div><p align="justify">사실 분석하면 별 거 아니긴 하다. 하지만 이런 미세한 옵션 하나하나가 프로그램 결과에 영향을 줄 수도 있다.</p><p align="justify">그래도 이건 양반이다. Makefile? 까짓 것 그냥 하나하나 한줄한줄 읽어가며 머릿 속으로 빌드하면 된다. 그런데 안드로이드의 복잡한 빌드 시스템이라면? 실제 이런 걸로 엄청 고생하기도 했다. 안드로이드 빌드 파일(.mk)에서 –D 옵션 설정이 내 예상과 달리 작동해 엄청 고생했다. 더 이상의 자세한 설명은 생략 한다… (CMake도 플랫폼 독립적으로 기술한다는 장점이 있지만 Makefile이 가지는 어려움을 본질적으로 감추지는 못한다고 생각한다.)</p><p align="justify">&nbsp;</p><p align="justify"><strong>그래서 해결책은?</strong></p><p align="justify">이런 문제는 결국 C/C++의 Makefile 기반의 빌드 시스템과 전처리기가 굉장히 낡았기 때문이다. 거기에 익숙한 개발자들은 이런 걸 고치려 하지 않는다. 그렇지만 최대한 이런 어려움을 줄일 수 있는 방법은 분명 있다. 기본 철학은 이러하다.</p><blockquote><p align="justify"><font face="맑은 고딕">소스 코드에 최대한 많이 빌딩(컴파일/링킹) 정보를 유추할 수 있도록 하여 소스 하나만 봐도 쉽게 이해할 수 있도록 한다.</font></p></blockquote><p align="justify">(1) –I 는 최소한으로 한다.</p><p align="justify">-I 를 전혀 쓰지 않으면 언급했듯이 “../../” 같은 상대 경로를 써야 하므로 오히려 지저분해진다. 그래서 대안으로 소스 프로젝트의 루트 위치, 혹은 대표 상위 몇 개만 최소한으로 지정한다. 그리고 헤더 파일은 그 루트를 시작으로 디렉토리 구조를 다 적어가며 쓴다. 좋은 예로 페이스북의 HipHop PHP 컴파일러를 들 수 있다. <a href="https://github.com/facebook/hiphop-php/blob/master/hphp/compiler/construct.cpp">소스 파일 하나</a>를 살펴보면:</p><div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper"><div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet">    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum1">   1:</span> <span style="color: #cc6633">#include</span> &lt;compiler/construct.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum2">   2:</span> <span style="color: #cc6633">#include</span> &lt;compiler/parser/parser.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum3">   3:</span> <span style="color: #cc6633">#include</span> &lt;util/util.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum4">   4:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum5">   5:</span> <span style="color: #cc6633">#include</span> &lt;compiler/analysis/file_scope.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum6">   6:</span> <span style="color: #cc6633">#include</span> &lt;compiler/analysis/function_scope.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum7">   7:</span> <span style="color: #cc6633">#include</span> &lt;compiler/analysis/class_scope.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum8">   8:</span> <span style="color: #cc6633">#include</span> &lt;compiler/analysis/analysis_result.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum9">   9:</span> <span style="color: #cc6633">#include</span> &lt;compiler/analysis/ast_walker.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum10">  10:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum11">  11:</span> <span style="color: #cc6633">#include</span> &lt;compiler/statement/function_statement.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum12">  12:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum13">  13:</span> <span style="color: #cc6633">#include</span> &lt;compiler/expression/simple_function_call.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum14">  14:</span> <span style="color: #cc6633">#include</span> &lt;compiler/expression/simple_variable.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum15">  15:</span> <span style="color: #cc6633">#include</span> &lt;compiler/expression/closure_expression.h&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum16">  16:</span> <span style="color: #cc6633">#include</span> &lt;iomanip&gt;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum17">  17:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum18">  18:</span> <span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span> HPHP;</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum19">  19:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum20">  20:</span> <span style="color: #008000">///////////////////////////////////////////////////////////////////////////////</span></pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum21">  21:</span>&nbsp; </pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum22">  22:</span> Construct::Construct(BlockScopePtr scope, LocationPtr loc)</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum23">  23:</span>     : m_blockScope(scope), m_flagsVal(0), m_loc(loc),</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum24">  24:</span>       m_containedEffects(0), m_effectsTag(0) {</pre>    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: white; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px"><span style="color: #606060" id="lnum25">  25:</span> }</pre><!--CRLF--></div></div><p align="justify">보다시피 상당히 깔끔하다. 실제 소스 폴더 구조는 hphp 라는 루트 폴더 아래에 compiler, utils, hhvm 등이 있다. compiler 아래에는 다시 analysis, statement 등이 있다. #include 만 봐도 바로 위치를 알 수 있고 어떤 목적으로 포함했는지도 쉽게 유추할 수 있다.</p><p align="justify">부디 복잡한 폴더 구조가 있음에도 -I로 다 때려 넣고 달랑 헤더 파일 이름만 적는 만행은 하지 말자.</p><p align="justify">&nbsp;</p><p align="justify">(2) Makefile에서 정의되는 –D 역시 최소한으로 한다. 아, 그냥 #ifdef 자체를 줄이는 것이 좋다.</p><p align="justify">C/C++은 컴파일러가 묵시적으로 포함하는 #define 값이 있다. 예를 들어, GCC의 C 컴파일러는 <a href="http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html">이런 값을 미리 정의하고 있다</a>. 이런 것은 어쩔 수 없다고 치자. 또, 상당히 범용으로 쓰이는 일부 직관적인 #define 값은 소스 파일 외부에서 정의되어도 큰 어려움이 없다. 대표적인 녀석들로 NDEBUG, DEBUG, ASSERT 같은 걸 들 수 있다. 그런데 그 외의 값은 정말 Makefile에서 마구 정의하는 것을 줄이도록 해보자.</p><p align="justify">보통 Makefile에는 여러 빌드 구성(configuration)이 있고 여기에 따라 –D 값이 바뀌는 것이 일반적이므로 Makefile에서 –D를 하는 것은 사실 자연스럽다. 하지만 최상위 값 하나, 또는 최소한만 –D로 넘어오도록 하고 영향을 받는 나머지 값들은 얼마든지 소스 코드 내에서 정의되도록 할 수 있다. 예를 들어, Makefile에서는 BUILD_FOO, BUILD_GOO 같은 것만 내려 보낸다. 그리고 이 값으로 globalDefines.h 같은 곳에 필요한 값이 정의되도록 한다.</p><p align="justify">그런데 무엇보다 아예 #define 값에 의존적인 조건부 컴파일 자체를 최소화 해야 한다. 하지만 옛날 코드를 보면 쓰이는 곳이 많다. 또, 코드 크기와 성능 문제로 조건부 컴파일을 어쩔 수 없이 해야 할 때가 여전히 빈번하다.</p><p>&nbsp;</p><p>(3) 링크될 정보 역시 소스 파일에 기록하자. 안 되면 주석이라도 달자.</p><p>어떤 함수를 외부에서 끌어다 쓸 때 별도의 링크할 라이브러리가 필요하면 어떻게 해서든 그걸 소스 파일에 드러내는 것이 좋다고 생각한다. 사실 이건 빈번한 경우가 아니니 사소하다고 볼 수 있지만 거대한 프로젝트에서 발생되는 외부 심볼 못 찾는 링크 에러는 시간 잡아 먹기 좋은 레거시다. 윈도우에서 코딩할 때는 프로젝트 옵션 (일종의 Makefile)에 같이 링킹할 .lib 목록을 적지 않고 소스 코드에 바로 적는 방법을 썼다:</p><div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">  <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #cc6633">#pragma</span> comment(lib, “foo.lib”) </pre></div><p>이 방법은 비표준 방법이라 이식성이 없다. MSVC는 <a href="http://msdn.microsoft.com/en-us/library/7f0aews7(v=vs.110).aspx">#pragma comment 기능</a>으로 링크할 라이브러리를 지정할 수 있다. GCC 대응은 안 찾아봤다.</p><p>비슷한 예로 특정 소스 파일에서 링커 최적화 옵션을 조작하고 싶을 때가 있었다. <a href="http://msdn.microsoft.com/en-us/library/bxwfs976(v=vs.110).aspx">COMDAT folding</a> 이라는 링커 최적화를 반드시 꺼야 할 때가 있었다. 역시 나는 프로젝트 세팅에 기입하지 않고 #pragma comment(linker, …)을 활용하였다.</p><p>&nbsp;</p><p><strong>정리</strong></p><p>사실 상 모든 큰 프로젝트의 C/C++ 소스 파일은 파일 하나만 봐서는 어떻게 컴파일 되는지, 어떻게 작동되는지 알기 매우 어렵다. 나는 최대한 많은 정보를 소스 파일에 적었으면 한다. 그래서 정말 궁극적으로는 파일 하나만 에디터에 올려도 코드 분석과 컴파일(오브젝트 파일로)이 되는 정도가 되면 좋겠다.</p><p>하지만… 이런 일은 10년이 지나도, 20년이 지나도 이뤄지지 않을 것 같다. 세상은 터치에, 레티나에, 이제는 눈동자의 움직임도 인식하는 세상인데, 여전히 이곳은 구닥다리 커맨드 라인 인터페이스가 지배하고 있으니…</p><p>p.s. C#이나 다른 고급 언어는 어떠한지는 잘 몰라서 비교 분석을 하지 못한 것이 아쉽다. 그래도 설마 C/C++ 만큼이나 지저분할까.</p>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3011317#comments</comments>
		<pubDate>Thu, 21 Mar 2013 06:15:22 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 황당한 신용점수 하락 경험담 ]]> </title>
		<link>http://minjang.egloos.com/3008064</link>
		<guid>http://minjang.egloos.com/3008064</guid>
		<description>
			<![CDATA[ 
  <p align="justify">오랜만에 컴퓨터와 관련 없는 이야기.</p>  <p align="justify">우리나라처럼 미국도 개인의 신용을 점수화해서 대출 이자 결정이나 카드 발급에 활용한다. <a href="http://en.wikipedia.org/wiki/Credit_score_in_the_United_States">미국의 신용점수</a>는 FICO Score라고도 불리는데, 좀 놀라운 것은 신용점수가 하나가 아니라 무려 3군데 기관(Experian, Equifax, TransUnion)에서 관리하는 점수가 있다.</p>  <p align="justify">작년 말, 결과적으로 내가 잘못한 것은 전혀 없는데, 엉뚱한 사람의 채무 기록이 내 신용기록에 올라와 신용점수가 크게 하락했고 그 오류를 바로 잡는데 적지 않은 시간적 정신적 고통이 뒤따랐다. 여기에 대한 경험담. </p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>사건의 발견</strong></p>  <p align="justify">미국 코스트코는 현금카드(debit card)와 아멕스 신용카드만 받는다. 그냥 현금카드만 쓰다가 갑자기 아멕스 신용카드를 만들고 싶어서 신청을 했다. 그런데 신용점수가 낮다고 거절을 당했다. 미국에 6년 정도 있으면서 자동차 할부 구입 같은 것은 없었지만, 사고친 것이 전혀 없고, 신용카드도 착실히 잘 썼으므로 신용점수는 그래도 700점 중반으로 좋은 편에 속했다. 2010년에 무료로 점수했을 때 나와 아내 모두 700점 초중반대의 점수였다. 그런데 신용점수가 부족하다고? 의아해서 당장 무료로 확인할 수 있는 곳에서 신용점수를 조회해보았다. 놀랍게도… 내가 2010년에 확인한 점수보다 무려 100점이나 하락한 600점 초반이었다. 정확하게 말하면 3대 신용점수 중 2군데의 점수가 크게 하락하였고 나머지 하나는 괜찮았다.</p>  <p align="justify">너무 당황스러웠지만 진정하고 신용기록을 자세히 살펴봤다. 신용점수가 크게 하락한 이유를 보니 돈을 내지 않은 기록이 신용정보 회사에 올려졌기 때문이었다. 두 개의 미납 채무 기록이 있었다. 하나는 무려 채무 금액이 5천불에 가까웠고 하나는 130불. 신용점수 보고서를 보면 이러하다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201303/06/29/d0033129_5136ed21c1e9a.png" width="463" height="504" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201303/06/29/d0033129_5136ed21c1e9a.png', 463, 504);" /></div></p>  <p align="justify">이 무시무시한 내용을 읽으면 식은 땀이 흐른다: “심각하게 납기일 지났음. 변호사와 추심업체에 의뢰했음”. 도대체 내가 큰 실수라도 했나? 사기라도 당했나? 이게 말로만 듣던 명의도용(identity theif)인가? </p>  <p align="justify">이 기록에서 Fidelity Info Corporation은 돈을 받아내는 추심업체이다. 갑자기 영화 똥파리가 생각난다… 그런데 내가 빚을 진 곳, “Original Creditor”는 어떤 아파트인데, 놀랍게도 여기는 내가 2010년 보스턴 근교에서 3개월간 인턴을 하면서 머물렀던 아파트이다. 하지만 나는 이 아파트와 정식 계약을 한 것이 아니라 이 아파트에 사는 어떤 한국인 학생 아파트를 잠시 빌린 것이다 (보통 서브렛이라고 말함). 아파트와 나는 전혀 어떤 계약을 한 것도 없었다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>사건의 이해</strong></p>  <p align="justify">그러니 더욱 머리가 아프다. 혹시 이 아파트가 내가 잠시 살았던 것을 알고 렌트비를 청구한 것인가? 원래 한 달 렌트비가 1800불에 달했으니 5천불이면 3달 정도의 렌트비와 비슷하다. 엄밀히 말하면 보통 아파트 계약을 다른 사람에 다시 세를 주는 것은 보통 금지되긴 한다. 그래도 이 아파트가 무슨 수로 내가 여기서 산 걸 알아냈는지도 의아하고 분명 착오라고 생각했다. 안타깝게도 원 주인 한국학생은 한국으로 돌아가 군대를 가서(…) 연락할 방법이 없었다.</p>  <p align="justify">문제를 해결하고자 아파트로 전화를 걸어보니 어떤 여직원이 받던데 자초지종을 설명했음에도 전혀 자신들은 알려줄 수 없다며 끊었다. 몇 번 거니 아예 전화를 받지도 않는다. 하는 수없이 아파트 관리회사의 홈페이지를 찾아 높은 직급의 사람의 이메일 주소를 알아내어 이메일을 보냈다. 답장이 바로 왔는데 이유가 너무 어처구니 없었다.</p>  <blockquote>   <p align="justify"><font face="맑은 고딕">당신과 이름이 비슷한 사람이 돈을 안 내었네요. 당신은 전혀 저희에게 빚을 진 것이 없습니다.</font></p> </blockquote>  <p align="justify">그래서 도대체 어떤 이름이냐고 물었더니 그건 사생활 보호 차원에서 안 된다고 말했다. 이해한다. 몇 차례 메일을 주고 받았는데 도대체 이 사람은 사과의 말도 없었다. 그래서 너희들이 잘못해서 내가 이렇게 고생했는데 사과라도 해야 하지 않냐 라고 물어보니…</p>  <blockquote>   <p align="justify"><font face="맑은 고딕">우리 잘못 아님. 우리는 원래 빚진 사람의 이름을 신용 업체에 보고했을 뿐이고, 신용 업체가 잘못해서 너 기록에 올린 것임.</font></p> </blockquote>  <p align="justify">아… 이제 대충 감이 잡히기 시작했다. Kim이야 흔하고 민으로 시작하는 이름도 흔하니 그렇게 된 것이다. 그런데 잠깐, 그렇다고 해서 어떻게 신용 정보 회사가 내가 이 아파트에 산 걸 알았지? 그 때서야 비로소 기억이 났다. 저 아파트에 살 당시, 지갑을 잃어버려서 저 아파트 주소로 카드를 새로 발급 받았다. 소위 billing address를 저 잠시 산 아파트로 한 것. 청구지 주소는 모두 신용 기록에 남는다.</p>  <p align="justify">그러니 아파트는 “김민X” 머 이런 이름의 인간이 돈을 안 낸 기록을 신용 회사에 보고를 했고, 신용 회사는 100% 정보가 일치하는 사람을 못 찾으니 대략 이름이 비슷하고 주소도 있는 내 정보에다가 “너 돈 안냈음” 이런 기록을 올린 것이다.</p>  <p align="justify">저 추심 업체에도 물어봤다. 물어보니 저 사람의 생년월일도 당연히 나랑 다르고, 아파트 호수도 당연히 다르고(!!), 무엇보다 저 사람은 소셜번호(주민등록번호와 유사)도 없었다. 정말 어처구니 없는 일이 아닐 수가 없다. 어떻게 이렇게 엉성하게 신용 기록 정보를 관리하는 것일까.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>사건의 해결</strong></p>  <p align="justify">이 문제를 풀려면 결국 신용 정보 회사에 이의 신청(dispute)을 해야 한다. 다행히 이런 황당한 짓을 저지른 회사(Experian)는 FreeCreditScore 라는 사이트에서 간편하게 온라인으로 수정 요청을 할 수 있었다. 그런데 이런 엉뚱한 신용 정보 기록을 이의 신청하는 것이 매우 빈번해서 따로 메뉴도 잘 마련이 되어 있었다…</p>  <p align="justify">다행히 온라인으로 이의 신청을 하니 1주일도 걸리지 않아 삭제가 되었다고 통보를 받았고 신용 점수도 바로 회복이 되었다.</p>  <p align="justify">비슷하게 130불짜리도 전혀 내 잘못이 아니었다. 이동통신비 채납 기록이던데 그 당시는 나는 그 이통사를 쓰지도 않았다. 추심업체에 전화를 걸어 이게 내 정보와 다름을 확인할 수 있었다. 역시나 소셜번호/생년월일이 모두 내 기록과 다른 엉뚱한 사람의 채무 기록이었다.</p>  <p align="justify">다만 이 잘못된 기록이 올라간 신용 정보 회사는 온라인 항의 접수가 되지가 않았다. 우편/팩스로 보내서 정말 딱 한 달을 기다린 후에 처리가 되었고 신용 점수가 회복되었다.</p>  <p align="justify">이 사건으로 받은 시간적 정신적 손실은 적지 않았다. 이런 일을 처음 겪어서 난 정말 내가 무슨 큰 실수를 한 줄 알았다. 어쨌든 이런 일이 터져도 그냥 차분히 대처하면 된다…라는 소중한 경험을 얻었다. 미국의 온라인 결제 시스템이 무척 허술해서 (편하기는 하지만) 카드 도용이 매우 빈번한데, 신용 기록 조차 이렇게 허술하게 관리되다니.</p>  <p align="justify">&nbsp;</p>  <p align="justify">3줄 요약:</p><div><ul><li>미국에서 있는 사람은 매년 무료로 할 수 있는 신용점수를 3기관 모두 체크한다.</li><li>혹시나 엉뚱한 사람의 채무 기록이 올라와있어도 당황하지 말고 차분히 전화/팩스/우편/온라인 등으로 해결한다.</li><li>저희 신용 회사는 엉뚱한 기록을 올려도 잘못이 없습니다. 니가 알아서 잘 챙겨.</li></ul></div>			 ]]> 
		</description>
		<category>나머지</category>

		<comments>http://minjang.egloos.com/3008064#comments</comments>
		<pubDate>Wed, 06 Mar 2013 07:15:46 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 대학교/대학원에서 배우는 전산학은 가치가 있는가 없는가 ]]> </title>
		<link>http://minjang.egloos.com/3003484</link>
		<guid>http://minjang.egloos.com/3003484</guid>
		<description>
			<![CDATA[ 
  <p align="justify">진작에 쓸려고 했던 내용인데 이제서야 정리해서 올려본다. 사실 올릴까 말까 고민도 많이 했다.</p>  <p align="justify"><a title="http://www.82cook.com/entiz/read.php?num=1486099" href="http://www.82cook.com/entiz/read.php?num=1486099">http://www.82cook.com/entiz/read.php?num=1486099</a></p>  <p align="justify">한 1-2주 전에 화제가 된 글이다. 조회수는 3만에 가까우며 300개의 댓글이 달렸다. 많이들 보셨겠지만 요약하면 이러하다:</p>  <ul>   <li>     <div align="justify">외고를 졸업하는 아들이 고려대(인문학부)와 경찰대에 합격.</div>   </li>    <li>     <div align="justify">하지만 <a href="http://www.nhnnext.org/index.nhn" target="_blank">NHN Next</a>로 가겠다고 해서 아들과 의견 충돌.</div>   </li>    <li>     <div align="justify">아버지와 아들은 계속 (학위 인증도 안 되는 이제 막 1기를 뽑은) Next로 가겠다고 함. 어떡하나요?</div>   </li> </ul>  <p align="justify">82cook의 댓글은 압도적으로 대학교에 가라는 조언이 많다. 게임코디에는 현직 게임 개발자 분들이 많이 오시는데 <a href="http://www.gamecodi.com/board/zboard.php?id=GAMECODI_Talk&amp;page=1&amp;sn1=&amp;divpage=5&amp;sn=off&amp;ss=on&amp;sc=on&amp;select_arrange=headnum&amp;desc=asc&amp;no=22175" target="_blank">이 분들의 의견 역시 그러하다</a>. 트위터에서도 정말 많은 이야기가 오고 갔다. 더러 개발자 중 사이에서도 대학교가 왜 필요하냐 라고 말 하는 사람도 있는 것 같다.</p>  <p align="justify">남의 집 자식에 훈수 둘 생각은 전혀 없고, 저 친구가 무얼 선택하던 존중은 해주고 싶지만, 내 동생이라면 아래를 추천한다. <strike>아니, 반드시 그렇게 하도록 한다. 혹 말을 듣지 않으면 두들겨 패서라도 시킬 것이다.</strike></p>  <ul>   <li>     <div align="justify">경찰대학교는 전혀 다른 적성이니 고려하지 않음.</div>   </li>    <li>     <div align="justify">안암동 소재의 대학에 일단 등록함. (등록이라도 해야 나중에 재입학이라도 됨)</div>   </li>    <li>     <div align="justify">인문학부라도 얼마든지 전공을 바꿀 수 있는 기회는 있음. 컴퓨터 관련 과목을 수강신청 하도록 함.</div>   </li> </ul>  <p align="justify">이 문제를 세속적인 명문대나 학벌의 문제로 얘기할 생각은 전혀 없다. 내가 얘기하고 싶은 이야기는 훌륭한 소프트웨어 엔지니어가 되는데 있어 대학교 혹은 그 이상의 학위가 가치가 있느냐 없느냐이다.</p>  <p align="justify">나는 비전공자로서 컴퓨터 프로그래머로 일을 해본 경험도 있고, 그 뒤 전공을 전산학으로 바꿔 지금은 대학원에서 배운 지식을 가지고 일을 하고 있다. 두 가지 경험 모두 해본 나의 시각에서 이 문제를 좀 얘기해볼까 한다. 그리고 뒤에는 유명하신 분들의 인터뷰 내용도 발췌해봤다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">   </p><p></p>  <p align="justify"><b>자신의 적성을 이른 나이에 알기란 쉽지 않다</b></p><p align="justify">사실 나도 저 친구의 맘을 충분히 이해한다. 컴퓨터가 좋아서 당장에 프로그래머가 되고 싶은 그 맘을 내가 누구보다 더 잘 안다. 나도 그랬으니까.</p>  <p align="justify">구구절절 이야기하긴 그렇고 간단히 요약하면 나도 많은 삽질을 하였다. 어려서부터 프로그래밍을 좋아했다. 아마 또래 중에서는 많이 한 축에 속할 것이다. PC 통신에도 연결되어있지 않은 구닥다리 286 컴퓨터이지만 나름 혼자서 습작을 꽤 했다. 하지만 진로선택에 있어 부족한 정보로 전혀 전산학과로 갈 생각을 하지 못했다. 나는 항공우주공학과를 가고 싶어했다(…)</p>  <p align="justify">그런데 대학교 오니 전공 공부는 뒷전이고 코딩만 했다. 때마침 닷컴 열풍 덕에 프로그래밍 아르바이트와 3년간의 산업기능요원으로 코딩을 많이 할 수 있었다. 나는 이 경험을 아주 소중하게 여긴다. 그리고 본격적으로 컴퓨터로 전공을 바꿔야겠다고 맘먹고 복수전공도 시작하였다. 그런데, 복학을 하니 너도나도 전부 다 의대 간다고 난리더라. 잠시 치과전문대학교 준비를 하는 삽질도 하였다. 그러나 결국 컴퓨터를 다시 해야겠다고 맘을 먹고 유학을 오게 되었고 이렇게까지 시간이 흘렀다. 유학 결과 기다릴 때 면접도 봐서 이 글에서 언급이 되는 N모 회사로 갈 기회도 있었다.</p>  <p align="justify">여기서 내가 얻은 교훈은 어려서는 - 특히 고교시절에 - 내 적성이라고 생각했던 것이 아닐 수 있다는 것이다.</p>  <p align="justify">어려서 바로 세부적인 목표를 정해놓고 배우는 것도 좋을 수 있다. 하지만 이건 다른 진로 탐색의 가능성을 줄일 수도 있다. 그래서 대학교에서 잠시 여유를 두고 자신의 적성을 탐색할 수 있는 기회를 가지는 것은 의미가 있다. 시행착오를 해도 큰 좌절을 겪지 않을 수 있다.</p>  <p align="justify">&nbsp;</p>  <p align="justify">   </p><p align="justify"><b>개발자에게 있어 대학 교육</b></p><p align="justify">나는 절대 훌륭한 소프트웨어 개발자가 되는데 대학교 혹은 대학교 이상의 학위가 필요하다고 말하고 싶지 않다. 분명 학위 같은 거 없이도 뛰어난 소프트웨어 만드는 사람도 많다.</p>  <p align="justify">하지만 대학교(대학원이 아니라)에서 전산학을 배운다고 해서 유능한 프로그래머가 되는데 손해가 될 것 역시, 거의 혹은 전혀 없다.</p>  <p align="justify">오히려 세부 전공 지식을 요구하는 소프트웨어 직업 군으로 갈 수 있는 가능성을 더 얻을 수 있다. 특히 연구 성격이 가미된 개발 일을 할 때는 현실적으로 대학원 이상의 학위를 요구한다 (대학교 교수는 말할 필요도 없고). 그리고 나의 경험에 비춰보면 정말 대학원에서 배운 연구 경험이 회사에서도 그대로 적용된다.</p>  <p align="justify">여기서 고학력/고학위를 요구하는 소프트웨어 직군이 더 낫다라고 말하는 것은 결코 아니다. 당장 나부터 밤 세어가며 개발하는 것을 좋아했던 사람이다. 대학원 연구가 질린 적이 아주 많다. 실제 세상에는 적용도 힘든 공상 소설 같은 연구 주제로 구현 보다 글 쓰기에 집중할 때가 많았다. 비록 박사 과정은 기회 비용 손실이 엄청나 별도로 생각해야 하지만, 적어도 석사는 약간의 연구도 할 수 있는 경험을 얻게 되니 여러 진로 가능성을 탐색할 수 있는 기회를 얻을 수 있다.</p>  <p align="justify">사실 소프트웨어 관련 일을 두부 자르듯이 학위에 따라 나누는 것이 별 의미가 없다. 개발 구현 중심이라 하더라도 얼마든지 어려운 문제가 많이 나오고 그걸 해결하려면 고도의 노력과 아이디어가 필요하다. 대용량 게임서버를 만드는데 필요한 알고리즘과 개발능력이 대학원에서 하는 것과, 적어도 수준이라는 측면에서는, 별 차이가 없다고 본다. 마찬가지로 대학원에서도 허무맹랑한 논문만 쓰는 것도 아니고 매우 구체적인 수준의 구현과 실험에 목숨을 걸어야 할 때도 많다.</p>  <p align="justify">결국 개발/구현 중심의 일과 연구 중심의 일에서 수준을 논의하는 것은 적절치 않다. 다만 성격이 다른 일이다. 그리고 둘 다 모두 중요하다. 구글의 검색 엔진은 두 박사 과정 학생이 만들었지만 그걸 실제 서비스로 구현하려면 다른 성격의 난관을 뚫어야 한다. 매우 뛰어난 프로그래머가 있었기에 가능했을 것이다.</p>  <p align="justify">이렇게 소프트웨어 개발자에는 여러 가지 길이 있고 대학교와 석사까지는 기회와 가능성을 높일 확률이 높다. (박사는 도로 까먹으니까 주의가 필요.)</p>  <p align="justify">&nbsp;</p>  <p align="justify"></p>  <p align="justify">   </p><p></p>  <p align="justify"><b>기업에서 직접 교육을 해야 하는가</b></p><p align="justify">NHN의 훌륭한 분들이 자신들의 철학으로 만든 NHN Next을 비판하는 글이 되어 두렵다. 특히 NHN Next에 입학한 학생들에게도 괜히 기분 나쁜 이야기를 하는 꼴이 되어 죄송할 따름이다. 그러니 그런 이런 의견도 있다 정도로 받아들였으면 좋겠다.</p>  <p align="justify">아마도 NHN은 현 대학교의 전산학 교육에 심각한 문제가 있음을 느끼고 직접 교육에 나선 것 같다. 맞다. 대학교 교육에 문제가 많다. 비단 한국뿐만 아니라 미국도 그러하다. 대학원 조교를 하면서 printf를 이용하는 디버깅도 못 하는 “전산학과 대학원생”을 한 두 번 본 것이 아니다. 지도교수님은 C++ 코딩만 잘해도 돈 줘가며 연구조교 시키겠다고 하실 정도였다.</p>  <p align="justify">하지만 이 문제에 대한 최선의 해결책이 NHN Next 같은 자신만의 교육 기관이라는 점은 적극 동의하기 어렵다. 정말 교육 개선에 관심이 있으면 특성화 고교, 대학교, 대학원에 투자를 해야 하지 않을까.</p>  <p align="justify">잠시 미국 이야기를 해보자. 일러두자면 SW 최대 강국인 미국의 예를 한국 상황과 비교하는 것은 적절치 않다는 것을 나는 너무 잘 안다. 인구/산업 규모가 크게 차이 나니 미국의 예가 한국에 바로 적용되는 것은 아니다. 그래도 잠깐 이야기를 해보자.</p>  <p align="justify">미국의 유명 IT 기업들은 대학교와 대학원 교육에 투자를 한다. 물질적으로는 대학교에 건물을 기증한다. 스탠포드 대학교의 <a href="http://en.wikipedia.org/wiki/Gates_Computer_Science_Building,_Stanford" target="_blank">Gates 빌딩</a>, 워싱턴 주립대학의 <a href="http://www.cs.washington.edu/building/" target="_blank">Paul Allen Center</a>가 아마 대표적일 것이다. 대학원에는 교수와 대학원생이 연구할 수 있도록 장비와 연구비를 지원한다. 기업체에서 주는 연구 펀딩도 컴퓨터 분야에는 많다. 기업체가 고민하는 문제를 대학교와 공유하면서 해결책을 찾는다.</p>  <p align="justify">그리고 무엇보다 미국 기업들은 인턴 기회를 대학(원)생에게 많이 준다. 인턴을 하면서 직접 개발/연구 과정을 경험하고 문화도 배운다. 기업들은 인턴에게 당장의 큰 결과물을 기대하는 것이 아니다. 결국 투자인 셈이다. 대학교에서 얻기 어려운 실제 개발 경험을 보완하는 것이다.</p>  <p align="justify">그런데 아직까지 마이크로소프트, 구글, IBM 등이 자신만의 교육 기관을 만들겠다는 이야기를 들어본 적은 없다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><a href="http://nullmodel.egloos.com/3928581" target="_blank">NHN Next의 교육과정</a>을 보니 이러하다. (<a href="http://www.nhnnext.org/curriculum/feature.nhn" target="_blank">NHN Next 소개 링크</a>)</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds25.egloos.com/pds/201302/15/29/d0033129_511dfa08bd53d.png" width="500" height="320.291777188" onclick="Control.Modal.openDialog(this, event, 'http://pds25.egloos.com/pds/201302/15/29/d0033129_511dfa08bd53d.png', 754, 483);" /></div></p>  <p align="justify">교육과정을 보니 분명 기존의 학원과는 달라 보인다. 분명 전문대학교 수준은 충분히 되고 꽤 높은 대학교 수준도 될 것이다. 자료구조/알고리즘도 있고 (2학기에 걸쳐 배워도 신통치 않을 과목을 한 과목으로 했다는 것을 차치하더라도), 기초 수학과 물리도 있고, 무엇보다 인문사회학(!)도 있다.</p>  <p align="justify">그런데 눈에 띄는 건 결국 게임/모바일/UI 프로그래밍이다. 직설적으로 말하면 NHN이 “지금” 필요한 인력을 양성하는 <strike>학원</strike> 학교 같다라는 인상이다. 왜 꼭 굳이 게임 프로그래밍이나 게임서버 프로그래밍이 저렇게 명확한 목표가 되어야 할까. (물론, 우리나라 SW에서 게임이 차지하는 비중이 큰 것을 잘 압니다.) 이 점에서 나는 NHN Next이 대학교와 아주 큰 차이를 보인다고 생각한다. 대학교에서는 명확한 목표는 잠시 미뤄두고 기초 과목 자체에 집중할 수 있다. 운영체제면 운영체제 자체에, 알고리즘이면 알고리즘 자체에 목표를 둔다. 그걸 가지고 어떤 큰 그림을 그릴 것인가는 학생들의 몫이다. 그런데 NHN Next의 교육 과정은 마치 밑그림이 그려져 있고 색깔만 칠하도록 하는 것 같다.</p>  <p align="justify">NHN은 우리나라 최대 SW 회사이다. “Next”를 생각하려면 페이스북의 그래프 서치나 구글의 검색 엔진처럼 새로운 기술을 발굴해야 하지 않을까. (아, 배부른 소리인 거 잘 압니다) 그런데 NHN Next의 교육과정을 보면 그런 기대를 하기에는 조금 무리가 있어 보인다</p>  <p align="justify">물론, 될 놈은 어딜 가도 되므로 대학교 가지 않고 NHN Next에 가서도 얼마든지 창업으로 대박을 터뜨릴 수도 있고, NHN에 입사하여 초특급 개발자가 될 수도 있다.</p>  <p align="justify">하지만 NHN Next만 경험한다면 앞서 얘기한 다른 성격의 소프트웨어 직군으로 가기는 현실적으로 난관이 많다. 대학교에 전산학을 공부하면 여전히 게임 프로그래밍도 할 수 있고, 전산학 전공 지식이 필요한 직군으로도 갈 수 있다.</p>  <p align="justify">&nbsp;</p>    <p align="justify"><b>전산학 학위에 대한 여러 유명인의 생각</b></p><p align="justify">자세히 다 읽지는 않았지만 “<b><a href="http://www.yes24.com/24/goods/7537901?scode=032&amp;OzSrank=1">프로그래머로 사는 법</a></b>”이라는 책을 최근에 군데군데 읽었다.</p><p align="justify"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds25.egloos.com/pds/201302/22/29/d0033129_5126c1ce9e842.jpg" width="275" height="400" onclick="Control.Modal.openDialog(this, event, 'http://pds25.egloos.com/pds/201302/22/29/d0033129_5126c1ce9e842.jpg', 275, 400);" /></div></p><p align="justify"></p><p align="justify">여기에 여러 유명인사의 인터뷰가 있는데 특히 대학원 교육에 대한 답변이 여럿 있었다. 한번 읽어 볼만한 것 같아 옮겨본다. (직접 타이핑을 했는데 이게 저작권에 위반이나 안 되었으면 한다.) 사실, 아래 인터뷰 내용은 학부 학위는 당연히 가정하고 대학원 석/박사의 가치를 얘기하고 있기는 하다.</p><p align="justify"></p><p align="justify">1. <a href="http://en.wikipedia.org/wiki/Mark_Russinovich" target="_blank">마크 루시노비치</a>, 윈도우 프로그래밍을 하시는 분 중에 이 분 이름을 모르는 건 말이 안될 정도로 유명한 분. 현재 마이크로소프트의 펠로우이며 환상적인 윈도우 내부 관련 툴을 만들어 많은 프로그래머들에게 지대한 영향을 주신 분. <a href="http://blogs.technet.com/b/markrussinovich/" target="_blank">이분의 블로그 글</a>을 보면서 늘 감탄을 하곤 했는데 공교롭게도 아래 두 질문의 답변은 정말 내 생각과 100% 일치한다. 그래서 길어도 다 옮겨본다.</p>  <p align="justify"><em>컴퓨터 공학으로 석박사 학위를 받으셨는데요, 석사나 박사 학위가 전문가로 살아가는 데 있어서 중요하다고 생각하시나요? 직원을 채용할 때 학위가 있는 쪽을 선호하시는 편인가요?</em></p><blockquote> <p align="justify">좋은 질문입니다. 실은 그런 질문을 정말 많이 받았어요. 저는 개인적으로 별로 선택의 여지가 없었어요. 아버지가 의사셨는데요, 제가 어렸을 적부터 교육을 최대한 많이 받아야 한다는 것을 엄청나게 강조하셨어요. 어떤 분야를 원하든 – 특별히 어떤 분야를 강요하거나 하진 않으셨어요 – 어떤 분야를 선택하든 최고 높은 학위까지 받아야 한다고 말씀하셨죠. 그래야 더 많은 기회를 찾을 수 있다고 생각하셨어요. 중간에 멈추면 다시 돌아갈 기회가 없어요. 일단 직장생활을 시작하고 나면 다시 학교로 돌아가기가 정말 어렵고, 실제로 그렇게 하는 사람이 아주 드물죠. 그래서 저는 처음부터 박사 학위를 받을 생각을 하고 시작했어요. 다른 사람들이 박사 학위를 받는 것에 대해서는, 고등교육 기관에서 학생들을 가르친다거나 연구소에서 일한다거나 하는 것처럼 박사 학위가 필요한 직업을 원하는 게 아니라면 박사까지 받을 필요는 없다고 생각합니다. 하지만 석사 학위는 꼭 따는 게 좋다고 생각해요. 어떻게 보면 박사 학위를 받으면 오히려 기회가 줄어들 수도 있어요. 뭔가를 정말 하고 싶은데 박사 학위가 있으면 분에 넘치는 사람이라고 생각하고, 기분 좋게 일하지 않을 거로 생각해서 그 일을 주지 않을 수도 있으니까요. 하지만 석사 학위 정도면 그런 일은 걱정하지 않아도 되고, 다른 사람들과 차별화될 수 있죠. 꼭 학위가 있다는 게 중요한 게 아니고 자기가 관심 있는 분야, 자신이 추구하고자 하는 방향에 대해 조금 더 깊이 있는 지식을 가지고 있다는 증거가 되니까요.</p></blockquote>   <p align="justify"><em>이 분야에 들어오고자 하는 사람들에게 마지막으로 조언 한마디 해 주실 수 있을까요?</em></p>  <blockquote>   <p align="justify">자신을 차별화시켜 보세요. 예를 들어 1990년대 중반에 자바가 폭발적으로 성장할 때는 다들 자바 프로그래머가 되었고, 구직 시장에 틀에서 찍어낸 듯한 자바 프로그래머가 넘쳐났죠. 그런 상황에서는 다른 사람이 쉽게 대신할 수 없는 인재로 자라나기가 정말 어려워요. 운영체제 내부를 훤히 안다는 게 딱히 매력적이라거나 주류에 속한다고는 할 수 없었지만, 덕분에 그쪽에서 일하는 사람이 별로 없었고 “그거 어려운 거잖아”라는 인식이 널리 퍼져서 저는 다른 사람들과 분명하게 차별화될 수 있었어요. 주류와 군중과 거리를 두고, 휘황찬란하고 멋져 보이는 게 아니라 더 안정적일 수 있는 걸 찾아보세요. 그런 분야를 잘 잡으면 재미있게 일하고 훌륭한 경력도 쌓고 돈도 잘 벌 수 있어요. (후략)</p> </blockquote>  <p align="justify">정말 내 생각과 너무나 일치해 놀라울 정도. (아, 제 아버지는 의사는 아닙니다 ㅎㅎ) 특히 박사 학위의 단점에 대해서도 내가 느낀바와 정확히 일치하는 단점을 언급해주었다. 대학원 진학 여부나 분야 선택에 대해 나에게 질문한다고 하면 그냥 이걸 복사해서 붙여넣기해도 될 정도. 위 인터뷰 내용처럼 (1) 대학원 석사는 적극 추천, (2) 유행을 너무 따르지 말고 남들이 잘 하지 않으려는 어려운 기술을 파고 들라고 충고하고 싶다. </p>  <p align="justify">&nbsp;</p>  <p align="justify">2. C++ 언어를 만드신 Bjarne Stroustrup (각자 발음은 알아서 할 것)의 의견과 Business Objects의 CEO인 <a href="http://en.wikipedia.org/wiki/Business_Objects" target="_blank">존 슈왈츠</a>의 이야기도 들어보자.</p>  <p align="justify"><em>석사나 박사 학위가 전문가 커리어에서 가치가 있다고 생각하시나요?</em></p>  <p align="justify">Bjarne Stroustrup:</p>  <blockquote>   <p align="justify">저는 그렇다고 생각해요. 탄탄한 기술적/과학적 기반이 없으면 유행에 파묻힐 수밖에 없어요. 그리고 대학원은 지금 당장은 별로 쓸모없어 보이는 것에 대해 생각하고 실험하고 배울 수 있는 몇 안 남은 장소 가운데 하나죠. 뭔가에 너무 초점을 맞추지 않고 그냥 재미있어 보이는 것을 자세히 살펴보면서 시간을 보내는 것이 중요하다고 생각합니다. 좋은 학위 과정에서는 철저한 기술적/과학적 기반을 갖추는 것에 덧붙여 그러한 시간을 가질 수 있죠.</p> </blockquote>  <p align="justify">Johne Schwarz:</p>  <blockquote>   <p align="justify">정말 중요합니다. 첫째, 대학원을 졸업했다는 건 그만큼 그 분야에 오랜 시간을 투자할 수 있는 능력을 보여주는 일이라고 할 수 있어요. 둘째, 석박사 학위가 있다는 것은 그 사람이 어느 정도 진지하고 참을성 있고 조직생활을 할 수 있을 만한 사람이라는 걸 보여준다고 봐요. 물론 빌 게이츠같이 대학을 중퇴하고도 대단한 업적을 세운 사람도 있지만, 그쪽은 예외적인 경우라고 봐야 할 것 같습니다.</p> </blockquote>  <p align="justify">&nbsp;</p>  <p align="justify">3. Sun에서 자바를 만드신 위대한 제임스 고슬링님의 답변. 사실 약간 너무 학위를 강조하는 글이라 썩 옮기기 내키지 않았다. 하지만 전산학에 큰 영향을 준 분이니 이 분의 의견도 옮겨 본다.</p>  <p align="justify"><em>소프트웨어 업계에서 석박사 학위가 가치가 있다고 보시나요? 실제 직원을 뽑을 때도 학위를 보시나요?</em></p>  <blockquote>   <p align="justify">물론입니다. 학사 학위만 있는 사람을 뽑을 때와 박사 학위를 가진 사람을 뽑을 때는 전혀 다른 방식으로 뽑습니다. 특히 어느 자리에서든 상당한 전문지식이 반드시 필요한 썬 같은 회사에서는 더욱 그렇죠. 하지만 자리마다 요건이 다를 겁니다. 심도 있는 전문지식이 필요하지 않는 자리도 많죠. 개인적으로 보자면 회사에서 일하면 훨씬 많은 돈을 받는데도 박사 과정 동안, 대학원 생활을 하던 시절이 제 평생 가장 재미있게 일하던 시절이었던 것 같습니다. 정말 대학원생 시절로 돌아가고 싶어요. 제 친구 중 몇은 정말 그렇게 하기도 했는데, 부럽습니다. 깊이와 폭의 문제인 것 같아요. 학사 학위만 마친 사람은 알고리즘 같은 것에 대해 피상적으로만 이해하는 편입니다. 알고리즘 분석 분야로 대학원에 다녔다면 훨씬 더 잘 알 것입니다. 특히 좋은 교수님 밑에서 배웠다면 더욱 그렇겠죠.</p> </blockquote>  <p align="justify">(나의 생각: Aㅏ.. 저렇게 대단하신 분은 대학원 박사 시절이 그립다고 하시는구나..)</p>  <p align="justify">&nbsp;</p>  <p align="justify">4. 연구보다 개발에 집중된 자리에 있는 분이라면 당연히 학위가 그다지 중요하지 않다고 생각할 수 있다. 두 분의 의견을 마지막으로 옮겨본다. 나 역시 이 두 분의 의견에도 적극 이해하는 바이다. 전산학에는 학위가 필요한 곳도 있지만 꼭 필요 없는 곳도 많이 있다.</p>  <p align="justify">VMware 공동 창업자 및 전 CEO인 <a href="http://en.wikipedia.org/wiki/Diane_Greene" target="_blank">다이앤 그린</a>: </p>  <blockquote>   <p align="justify">물론 대학원에 다니는 게 해가 되는 일은 없습니다만 소프트웨어 분야에서는 대학원에 가지 않았다고 해서 그 사람이 재능이 부족하다고 생각하진 않습니다. 소프트웨어에서는 실력만 가지고도 충분히 능력을 발휘할 수 있어요. 대학원 과정이 상당히 훌륭한 훈련 과정이 될 수 있다고 생각하지만, 경력을 끌어올리는 데 필요한 것이라기보다는 관심이 있기 때문에 하는 것이라고 봐야 하는 것 같습니다. 물론 교수 같은 자리에 가고 싶다면 당연히 필요하긴 하겠지만요.</p> </blockquote>  <p align="justify">마이크로소프트 CTO인 데이비드 바스케비치(David Vaskevitch):</p>  <blockquote>   <p align="justify">이쪽 분야에서 대학원 학위가 직접 유용한 것은 아니라고 생각합니다. 상당히 까다로운 질문인데요, 아시다시피 대학 교육의 장점 중 적지 않은 부분이 생각하는 방법을 배우고, 책을 읽고, 자신을 탐구하고, 친구들을 사귀고 인맥을 쌓는 데 있죠. 물론 석사 논문을 쓰면서 글을 잘 쓰는 방법에 대해서는 확실히 배운 게 있습니다. 석사 지도 교수님이 정말 훌륭한 편집인이셨거든요.</p> </blockquote>  <p align="justify">&nbsp;</p>  <hr />  <p align="justify">3줄 요약:</p>  <ul>   <li>     <div align="justify">NHN이 SW 교육에 관심이 있으면 대학교 같은 곳에 투자하는 것이 어떨까.</div>   </li>    <li>     <div align="justify">어린 시절 꿈이 전부가 아니다. 자신이 원하는 걸 뒤늦게 찾을 수 있다. 대학교에서 그런 탐색을 할 수 있다.</div>   </li>    <li>     <div align="justify">그래도 프로그래머라면 NP-Hard가 무슨 뜻인지는 정확히 아는 것이 좋지 않을까. (정답은 <a href="https://twitter.com/d_ijk_stra/status/302078190342529025" target="_blank">여기서 확인</a>)</div>   </li> </ul>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/3003484#comments</comments>
		<pubDate>Fri, 15 Feb 2013 09:04:10 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 자신의 일을 몰래 중국 개발자에게 아웃소싱 해버린 미국 회사의 개발자 ]]> </title>
		<link>http://minjang.egloos.com/2996237</link>
		<guid>http://minjang.egloos.com/2996237</guid>
		<description>
			<![CDATA[ 
  <p align="justify">오늘 화제가 된 엄청나게 어이없는 사건 하나를 얘기하고자 한다. 요약된 기사는 <a href="http://betabeat.com/2013/01/programmer-outsources-his-job-to-china-so-he-can-get-paid-to-screw-around-on-reddit-all-day/">여기서 볼 수 있고</a> 원 기사는 <a href="http://securityblog.verizonbusiness.com/2013/01/14/case-study-pro-active-log-review-might-be-a-good-idea/">1월 14일에 나온 내용</a>이다. 이 사건은 이러하다.</p> <p align="justify">미국에 있는 한 회사의 IT 관리자가 VPN (회사 직원이 회사 밖에서도 회사 네트웍으로 접속할 수 있도록 하는 시스템) 접속 로그를 살펴보고 있는데, 이상하게 중국 선양에서 접속된 기록을 발견했다. 더욱 의아한 것은 그 접속이 매일같이 이뤄지고 있다는 점. 이 회사는 미국 내 인프라스트럭쳐 관련 중요한 일을 하기에 허가 받지 않은 중국 발 네트웍 접속은 심각한 보안의 문제일 수가 있었다. 그런데 그 VPN 접속에 사용된 아이디를 쓰는 직원은 여기 미국 회사에 앉아 있었다.</p> <p align="justify">보통 미국 회사는 VPN에 접속하려면 단순 암호 외에 인터넷 뱅킹의 OTP 번호 발생기처럼 RSA 암호키 생성기를 같이 쓴다.</p> <p align="center"><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/RSA_SecurID_SID800.jpg/800px-RSA_SecurID_SID800.jpg" width="400" height="190"></p> <p align="justify">설마 이 암호키가 도난이 되어 중국에서 쓰일 리 없으니 회사는 제로데이 멀웨어나 해킹으로 의심했다. 조사에 착수한 뒤 이 직원의 컴퓨터를 조사하면서 혹시 이상한 경로로 다운 받은 파일이 없나 살펴보았다고 한다. 그런데 정작 발견된 것은 PDF 파일 더미였다고 한다. 그 PDF 파일은, 예상하듯이, 중국 선양의 제 3 개발자/회사와의 계약 관련 문서였다고 한다!</p> <p align="justify">결국 드러난 전말은 이러하다.</p> <p align="justify">40대 중반의 C/C++, 자바 등 여러 언어를 쓰는 이 오랜 경력의 개발자는 겉으로 봐서는 매우 평범한 가정적인 사람이다. 그런데 이 개발자는 자신의 일을 몰래 중국 선양의 한 개발 업체에게 용역을 준 것이다. 그런데 용역에 드는 비용은 자신의 연봉의 1/5에도 미치지 못했다고. 보통 40대 중반의 개발자가 되면 10만불이 넘는 연봉이 일반적이니 2만불 정도 돈을 써가며 자신은 근무 시간에 탱자탱자 놀았다는 것.</p> <p align="justify">이 직원의 컴퓨터 웹 접속 기록도 살펴보니 대략 이러했다고 한다.</p> <ul> <li> <div align="justify">09:00 AM: 회사에 와서 Reddit에서 몇 시간 놈. 비디오 보면서 놈.</div></li> <li> <div align="justify">11:30 AM: 점심 먹음</div></li> <li> <div align="justify">1:00 PM: 이베이 함</div></li> <li> <div align="justify">오후 2시 경: 페이스북이나 링크드인 함.</div></li> <li> <div align="justify">4:30 PM: 업무 결과를 이메일로 보고</div></li> <li> <div align="justify">5:00 PM: 집에 감.</div></li></ul> <p align="justify">더욱 놀라운 것은 이 사람은 다른 회사에서도 일을 받아 똑같은 방식으로 아웃소싱을 해버렸다는 것. 그래서 1년에 몇 십만 불, 그러니까 몇 억원을 벌었다고 한다. </p><p align="justify">그러면 그 VPN 접속은 어떻게 했지? 암호키 생성기가 필요한데? 간단하다. 그냥 그 생성기를 페덱스로 직접 중국에 보낸 것;;</p> <p align="center"><img alt="" src="https://encrypted-tbn2.gstatic.com/images?q=tbn:ANd9GcSZNL8ApDy3QjE7N9_O6zaKVO6Vy2Oxl-m6T6fTL0omxZfaO-2vlw" width="376" height="134"></p> <p align="center"><em>그나저나 FedEx에서 회살표가 보이나요?</em></p> <p align="justify">가장 충격적인 건, 이 사람의 업무 평가 내역을 보니 거의 최고 수준이었다고 한다…. 코드는 항상 깔끔하고 목표된 시간에 완료가 되었다고 한다. 심지어 건물 내 최고의 개발자라는 평도 있었다고. 이런 평이 수년간 지속된 걸로 봐서 이 사람은 최소 3-4년을 이렇게 자기 일을 중국에 던져주고 놀았던 것이다. </p><p align="justify">&nbsp; </p><p align="justify">이 사람 완전 천잰데? </p><p align="justify">만약, 중국에서 미국에 있는 프락시를 써서 VPN 접속했다면 완전 범죄? </p><p align="justify">그나저나 회사에서 웹서핑 많이 하는데 내일부터 당장 줄여야겠다.</p><p align="justify"><br />
</p><p align="justify">하지만... 미국에서 십만불 받는 프로그래머의 코드가 중국의 1-2만불 개발자와 같은 수준이라니. 개발자에겐 별로 좋은 소식은 아님;;</p>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/2996237#comments</comments>
		<pubDate>Thu, 17 Jan 2013 06:39:29 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 새로운 페이스북의 검색 엔진: Graph Search ]]> </title>
		<link>http://minjang.egloos.com/2995942</link>
		<guid>http://minjang.egloos.com/2995942</guid>
		<description>
			<![CDATA[ 
  <p align="justify">미국 시각으로 1월 5일 오전에 페이스북이 갑자기 발표한다고 하는 내용이 공개되었다. The Verge에서 라이브로 <a href="http://live.theverge.com/facebook-see-what-were-building-event/" target="_blank">중계하는 것을 보았다</a>. 별 쓸모 없는 “타임라인” 같은 기능을 발표할까라고 반신반의 했는데 굉장한 기술을 발표했다. 아직 베타 서비스 개발 중이고 상업적인 성공은 두고 봐야겠지만 기존의 웹 검색보다 진화한 새로운 검색 시스템이라는 점에서 매우 높게 평가하고 싶다.</p>  <p align="justify">간략히 설명하면 Graph Search는 그간 페이스북이 너무나 취약했던 검색 기능을 획기적으로 바꾼 검색 엔진인데, 이것이 기존의 웹 검색과는 상당히 다른, 페이스북이 가지고 있는 데이터를 극대화한 검색 기술이다. 이 기술로 페이스북이 단순히 SNS 서비스로 머무는 것이 아니라 검색 회사로 나갈 수 있는 기회를 열었다고 본다. 그리고 마이크로소프트의 Bing과 협력도 확인하면서 보다 긴밀히 통합이 됐다. 이로서 페이스북+빙이 구글과 SNS(구글플러스) 외에도 검색에서도 직접적으로 경쟁을 하게 되었다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>Graph Search가 무엇인가?</strong></p>  <p align="justify">그래프 서치는 다음과 같은 검색을 가능하게 한다.</p>  <p align="justify"><em>“인도 사람들이 좋아하는 샌프란시스코에 있는 레스토랑”</em></p>  <p align="justify">지금까지 웹 검색이라면 “샌프란시스코에 있는 레스토랑”은 문제 없이 되었다. 구글이나 빙 맵에서 간단히 검색되는 것이었다. 그런데 여기서 “인도 사람들이 좋아하는”처럼 보다 한정적이고 정밀한 검색은 사실 상 불가능했다.</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201301/16/29/d0033129_50f5d512b4fb4.png" width="500" height="372.807017544" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201301/16/29/d0033129_50f5d512b4fb4.png', 684, 510);" /></div></p>  <p align="justify">최근 구글이 <a href="http://en.wikipedia.org/wiki/Zagat" target="_blank">2012년 5월에 인수한 Zagat</a>이라는 음식점 평가 사이트를 구글 검색에 통합함으로써 위 그림처럼 “231명의 리뷰”와 “17점” (총점 30점)이라는 리뷰를 바로 보여준다. 그래서 어느 정도 사람들이 좋아하는가도 알 수는 있다. 하지만, “인도 사람들이”, “샌프란시스코에 사는 사람들이”, 혹은 “내 친구 중 샌프란시스코에 사는 인도 친구들이”와 같은 자세한 검색은 불가능했다. 페이스북의 그래프 서치는 이 기능을 가능케 한다.</p>  <p align="justify"><a title="https://www.facebook.com/about/graphsearch" href="https://www.facebook.com/about/graphsearch">https://www.facebook.com/about/graphsearch</a></p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://thumbnail.egloos.net/500x0/http://pds27.egloos.com/pds/201301/16/29/d0033129_50f5d51a782f0.png" width="500" height="237.562189055" onclick="Control.Modal.openDialog(this, event, 'http://pds27.egloos.com/pds/201301/16/29/d0033129_50f5d51a782f0.png', 804, 382);" /></div></p>  <p align="justify">위 링크를 가면 그래프 서치에 대한 설명을 자세히 볼 수 있다. 아직 데이터가 충분히 다 안 만들어져서 당장 써 볼 수 있는 예제로는 “내가 사는 도시에 사는 친구와 친구의 친구(2nd degree)”가 있다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>왜 이 기술이 중요한가?</strong></p>  <p align="justify">내가 살면서 페이스북 기술에 감탄한 적은 첨인 것 같다. 내가 왜 이 기술에 흥미를 가지냐면, Bing이 주장하듯이 웹 검색의 주요한 목적 중 하나가 ‘결정’을 하는데 필요한 정보를 얻는 것이다. 그런데 다음과 같은 정보는 참 찾기가 어려웠다. 그래프 서치를 설명하는 비디오에서도 딱 나오는 예이다.</p>  <p align="justify">나도 최근에 이 동네에 와서 어느 치과가 좋은지, 어느 자동차 정비사가 좋은지 알기가 어렵다. 웹 검색으로 리스트를 뽑고 리뷰를 보면서 결정을 해야 했다. 보통 이것도 그다지 미덥지 못해 게시판에 올려서 사람들의 의견을 묻곤 한다. 소위 ‘알바’라는 사람이 물을 흐려놓을 수도 있지만 직접 사람들이 올린 정보는 상당히 신뢰가 간다. 이렇게 웹 검색과 추천 정보가 꽤 파편화 되어있었는데, 그래프 서치로 바로 “내 친구, 또는 산호세에 사는 사람들이 좋아하는 산호세의 치과”라고 치면 된다는 것이다.</p>  <p align="justify">물론, 너무 이상적인 생각을 하고 있을지도 모른다. 치과 의사 예제는 보니 직접 사람이 특정 치과 의사 페이지를 Like를 해야 되는 것 같기도 하다. 하지만 기존의 웹 검색이 쉽게 할 수 없었던 사람들의 관계 속에 녹아 든 정보를 찾아준다는 것에서 진일보한 검색 시스템임은 분명하다. 그리고 사람들이 이 기능에 익숙해지면 보다 적극적으로 자신의 취향을 페이스북에 기여할 수 있고 그러면 검색의 품질이 더 높아질 수 있다.</p>  <p align="justify">페이스북의 장기적인 매출에도 효율적인 광고를 넣을 수 있어 도움이 될 것 같다. 최근 페이스북은 특정 글을 홍보하는 기능(promote)이나 특정 사람에게 메세지 보내는데 돈을 부과하는 방식 같은 쉬운 방법으로 돈을 벌려고 했었다. 구글은 거의 대부분의 매출이 광고에서 만드는데 그걸 가능하게 하는 기술은 바로 검색기술이다. (그리고 상당히 뛰어난 부정클릭 차단 기술도 한 몫)</p>  <p align="justify">페이스북도 이제 단순히 정보를 다른 회사에 팔아서 돈을 벌기 보다는 직접적으로 검색 기능을 제공해 구글과 경쟁하려는 것 같다. 거기다 Bing 검색 엔진을 페이스북에 탑재함으로써 Bing+페이스북 대 구글 플러스+구글 검색의 대결 구도가 한층 심해질 것이다.</p>  <p align="justify">구글 역시 조만간 이와 비슷한 기능을 만들 것으로 확신한다. 기술적으로는 오히려 더 뛰어난 서비스를 만들 수 있을 것이다. 당장에 구글 플러스만 봐도 플랫폼 자체는 페이스북 보다 훨씬 잘 만들어졌다고 나는 느낀다. 하지만 문제는 축적된 데이터의 양이다.</p>  <p align="justify">그래프 서치로 페이스북은 쌓여있는 십억 명 이상이 만들어 낸 조 단위의 정보를 보다 효과적으로 가공해 궁극적으로 돈을 만들 수 있는 무기를 만들었다고 평가하고 싶다.</p>  <p align="justify">&nbsp;</p>  <p align="justify"><strong>그래프 서치의 기술적인 어려움</strong></p>  <p align="justify">일단 왜 이름이 그래프 서치일까?</p>  <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201301/16/29/d0033129_50f5d51d95597.png" width="386" height="373" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201301/16/29/d0033129_50f5d51d95597.png', 386, 373);" /></div></p>  <p align="center">Graph Search라는 이름은 바로 페이스북 데이터를 그래프 자료구조(점과 선으로 연결된 것)로 표현하고 여기서 찾기 때문일 듯.</p>  <p align="justify">컴퓨터 프로그램을 해보신 분은 바로 <a href="http://en.wikipedia.org/wiki/Graph_(abstract_data_type)" target="_blank">그래프 자료구조</a>를 떠올릴 것이다. 혹, 그래프라는 용어에 익숙하지 않은 사람들도 <a href="http://punkrockor.wordpress.com/2011/07/27/" target="_blank">이런 그림은 많이 봐왔을 것이다</a>.</p>  <p align="center"><img src="http://punkrockor.files.wordpress.com/2011/07/twitter_followers.jpg" width="599" height="396"></p>  <p align="justify">트위터 팔로우 하는 사람의 관계를 나타낸 것인데 이런 형태의 자료를 그래프라고 한다.</p>  <p align="justify">단순히 팔로우 관계 뿐만 아니라 어떤 것을 좋아하는 것 같은 여러 현상을 그래프로 표현할 수 있다. 그래서 여기서 정보를 찾는다고 해서 그래프 서치라고 이름이 지어졌을 것이다.</p>  <p align="justify">그런데 이런 그래프에서 의미 있는 정보를 찾는 것은 아주 어려운 문제로 알려져 있다. 최근에 연구가 활발히 되고 있다고 한다. 특히 엄청난 크기의 그래프에서 효율적으로 정보를 찾는 것이 핵심 문제이다. 구글은 2009~2010년에 <a href="http://kowshik.github.com/JPregel/pregel_paper.pdf" target="_blank">Pregel이라는 대용량 그래프 처리 시스템</a>을 발표했다.</p>  <p align="justify">그리고 가장 최근의 연구 결과 중 하나로는 카네기 멜론 대학의 <a href="https://www.usenix.org/sites/default/files/conference/protected-files/gonzalez_osdi12_slides.pdf" target="_blank">PowerGraph</a>라는 분산-병렬 그래프 처리 시스템이 있다. 나도 이 분야에는 아는 것이 별로 없는데 특히 <a href="https://www.usenix.org/conference/osdi12/167-powergraph-distributed-graph-parallel-computation-natural-graphs" target="_blank">PowerGraph 논문을 발표하는 동영상</a>을 강력히 추천한다. 약간의 전산학 지식만 있어도 이 분야의 현재 상황을 잘 알 수 있다. 핵심은 자연 현상에서 얻은 그래프는 기존의 그래프 분할 알고리즘으로 효과적으로 처리가 되지 않아 새로운 기법으로 데이터를 잘 분산 처리한다는 것.</p>  <p align="justify">페이스북의 그래프 서치도 분명 위의 기술과 유사한 기술을 응용했을 것이다. 혹 조만간 관련 논문을 낼 수도 있을 것이다.</p><p align="justify">지금 공개된 수준(<a href="http://www.theverge.com/2013/1/15/3880004/facebook-graph-search-hands-on" target="_blank">비디오 링크</a>)은 베타 서비스라 속도도 느리고 정보다 꽤 제한적이겠지만 그래프 서치가 제시한 비전은 분명 진보된 웹 검색이라 할 수 있다.</p>  <p>&nbsp;</p>  <p>두 줄 요약:</p>  <p>1. 그래프 서치는 페이스북의 소셜 데이터를 이용한 새로운 웹 검색 엔진.</p>  <p>2. 어, 그런데 아직까지도 내가 쓴 글과 댓글에 대한 검색은 안 되는데요??</p>			 ]]> 
		</description>
		<category>컴퓨터</category>

		<comments>http://minjang.egloos.com/2995942#comments</comments>
		<pubDate>Tue, 15 Jan 2013 22:15:58 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
	<item>
		<title><![CDATA[ 헷갈리는 영어 발음 ]]> </title>
		<link>http://minjang.egloos.com/2995783</link>
		<guid>http://minjang.egloos.com/2995783</guid>
		<description>
			<![CDATA[ 
  <p>한글이 우수한 점 중 하나는 글자 하나에 오직 한 발음만이 있어서 (음운 현상으로 인한 발음 변화는 있지만) 알파벳처럼 발음기호를 볼 일이 거의 없다는 것이다. 아시다시피 영어는 그러하지 않다. 물론 이해는 한다. 알파벳이 영어에만 쓰이는 것이 아니라 다른 언어에도 쓰여서 같은 알파벳에서도 발음이 다르다. 또, 영어라는 것이 미국, 영국, 호주 등에서 주요 국어로 쓰이지만 (참고로 미국은 연방정부 차원에서 <a href="http://en.wikipedia.org/wiki/Languages_of_the_United_States">공식 언어라는 개념이 없다</a>) 다른 나라 사람들도 제 2 외국어로 많이 쓰다 보니 고유의 액센트와 발음으로 같은 영어 단어라도 발음이 사뭇 다를 수 있다. 특히 영어 모음은 지역에 따라, 출신 국가에 따라 변화가 매우 심해 나 같은 한국인이 이해하기 어려울 때가 많다.</p> <p>일단 구글 크롬을 쓰시는 분은 <a href="https://chrome.google.com/webstore/detail/google-dictionary-by-goog/mgijmajocgfcbeboacabfgobmjgjcoja?hl=en">사전 플러그인</a>을 강력 추천한다. 발음도 바로 들어볼 수 있어서 아주 편하다.</p> <p>&nbsp;</p> <p>1. Multi-: 멀티? 멀타이?</p> <p>Multicore, Multimedia를 아마 우리나라 사람이면 거의 대부분이 멀티코어와 멀티미디어로 읽을 것이다. 그런데 매우 자주 저 두 단어를 “멀타이 코어”, “멀타이 미디어”라고 발음하는 걸 미국에서 본다. i를 보통 미국인은 ‘아이’로 읽는 경향이 매우 많아서 그런 것 같다. 그래서 Nikon이 미국에서는 “나이콘”, IKEA는 미국사람은 아주 당연한 듯이 “아이키아”라고 읽는다. IT 분야 종사자들도 “멀타이 코어”라고 발음하는 경우가 많은데 아직까지도 좀 낯설다.</p> <p>&nbsp;</p> <p>2. Mobile: 모바일? 모빌? 모블?</p> <p>역시 우리에게는 모바일이라는 단어로 친숙한데 <a href="http://dictionary.reference.com/browse/mobile?s=t">사전을 참고하면</a> 미국에서는 보통 모빌, 모블로 주로 발음한다. 영국에서는 특히 모바일로 발음한다고 한다. 내가 경험하기로는 모블 아니면 모바일인 것 같다.</p> <p>&nbsp;</p> <p>3. Either: 이덜? 아이덜?</p> <p>위와 비슷하게 either 역시 나는 늘 “이덜”로 발음했는데 “아이덜”로 발음하는 사람도 참 많다. 사전에도 보니 <a href="http://dictionary.reference.com/browse/either">두 발음이 다 있다</a>. Neither 역시 “나이덜”로 발음하는 사람이 많다. Diversity 역시 “디벌서티” 또는 “다이벌서티” <a href="http://dictionary.reference.com/browse/diversity?s=t">두 가지 발음이 있다</a>. 나는 다이벌서티로 알아왔는데 오늘 오바마 기자 회견에서는 “디벌서티”로 발음 하기도 했다.</p> <p>&nbsp;</p> <p>4. 2013: Two-thousand-13? Twenty-13?</p> <p>2013년을 영어로 읽으면 two-thousand thirteen 일까 아니면 twenty thirteen일까? 경험하기로는 두 가지가 모두 쓰인다. 하지만 2009년까지는 절대 twenty nine 으로 발음하는 사람은 못 봤다. 그런데 2010년을 기점으로 two-thousand ten 대신에 twenty ten으로 발음하는 사람을 확실히 많이 본다. 한번 구글 번역기로 실험해보니 역시나 그랬다.</p> <p><a title="http://translate.google.com/#ko/en/2010" href="http://translate.google.com/#ko/en/2010">http://translate.google.com/#ko/en/2010</a></p> <p>위 링크에서 발음 버튼을 누르면 twenty ten으로 읽는다. 하지만 2009로 바꾸면 two-thousand nine으로 읽는다.</p> <p><a title="http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203011." href="http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203011.">http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203011.</a></p> <p>그런데 웃긴 건, “It will be created in 3010.”을 주면 three-thousand ten으로 읽어버린다. 규칙성을 찾을 수 없다 ㅎㅎ</p> <p><a title="http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203010." href="http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203010">http://translate.google.com/#ko/en/It%20will%20be%20created%20in%203010.</a><br clear="all"><br clear="all"> </p><hr> <p></p> <p>좀 주제를 돌려서, 최근 삼성과 애플 소송 관련 한국 뉴스를 보면 희한한 단어 하나를 접할 수 있다. 바로 “새너제이”.</p> <p align="center"><div style="text-align:center"><img class="image_mid" border="0" onmouseover="this.style.cursor='pointer'" alt="" src="http://pds26.egloos.com/pds/201301/15/29/d0033129_50f4fd033ba37.png" width="500" height="470.260223048" onclick="Control.Modal.openDialog(this, event, 'http://pds26.egloos.com/pds/201301/15/29/d0033129_50f4fd033ba37.png', 538, 506);" /></div></p> <p>그렇다. 새너제이는 San Jose, 일명 우리가 “산호세”라고 알고 있던 샌프란시스코 주변/실리콘 밸리의 도시를 새너제이로 읽기 시작한 것이다. 갑자기 할로윈을 “핼러윈”으로 하더니 San Jose가 “새너제이”가 되었다.</p> <p align="center"><strong><font color="#d16349">새너제이</font></strong></p> <p align="center"><strong><font style="" color="#c0504d" size="4">새너제이</font></strong></p> <p align="center"><strong><font color="#ff0000" size="6">새너제이!!</font></strong></p> <p>솔직히 San Jose를 산호세라고 읽는 것은 정확한 것은 아니다. 여기서 정말로 ‘산’-‘호’-‘세’라고 말하면 이해 못할 사람이 대부분이다. 내가 여기서 들은 발음은 거의 “쌔엔~ 호제이~” 정도이다. 절대 절대 절대 “새너제이”와 같은 발음은 아니라고 생각한다. 새너제이를 좀 혀를 굴려 새너~제이~ 라고 해도 잘 못들을 확률이 높다. 핵심은 J를 스패니쉬로 읽어 ㅎ 발음을 넣는 것이 아닌가 한다.</p> <p>그 외에도 웃긴 점이 많다. 위에 지도 왼쪽 위를 보면 “팰러앨토”라고 있다. Palo Alto를 현지 발음에 가깝게 바꾼 것. 뭐, 이건 비슷하고 좋다고 치자. 그런데 바로 위에 보면 “East Palo Alto”가 있는데 얘는 그냥 “이스트 팔로알토”이다. 또 지도 아래에 보면 "사우스 산호세"라는 표현도 바로 볼 수 있다.</p> <p>나보다 훨 영어와 국어를 잘 아시는 분들이 결정을 했겠지만 외래어를 어떻게 한국어로 표현할지는 늘 논란거리가 되는 것 같다. 위에서 예를 들었듯이 한 영어 단어가 미국 내에서도 다양하게 읽힌다. 그래서 어설프게 괜히 현지 발음으로 하다가 더 우스꽝스럽게 되지 않을까라는 생각이 든다.</p><p><br />
</p><p>한 줄 요약:</p><p>멀티미디어? 멀타이미디어? 이덜? 아이덜? 정답은 그냥 내 하고 싶은대로 하면 된다. 하지만 San Jose는 새너제이가 아니다.</p>			 ]]> 
		</description>
		<category>나머지</category>

		<comments>http://minjang.egloos.com/2995783#comments</comments>
		<pubDate>Tue, 15 Jan 2013 06:53:57 GMT</pubDate>
		<dc:creator>김민장</dc:creator>
	</item>
</channel>
</rss>
