<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title>서광열의 프로그래밍 언어 이야기</title>
		<link>http://skyul.tistory.com/</link>
		<description>프로그래밍 언어, VM, 컴파일러에 대해 씁니다.</description>
		<language>ko</language>
		<pubDate>Wed, 17 Aug 2011 06:42:11 +0900</pubDate>
		<generator>Tistory 1.1 (http://www.tistory.com/)</generator>
		<image>
		<title>서광열의 프로그래밍 언어 이야기</title>
		<url><![CDATA[http://cfs6.tistory.com/upload_control/download.blog?fhandle=YmxvZzE5MzAzQGZzNi50aXN0b3J5LmNvbTovYXR0YWNoLzAvMDEwMDAwMDAwMDAwLmpwZw%3D%3D]]></url>
		<link>http://skyul.tistory.com/</link>
		<description>프로그래밍 언어, VM, 컴파일러에 대해 씁니다.</description>
		</image>
		<item>
			<title>C/C++ volatile 키워드</title>
			<link>http://skyul.tistory.com/337</link>
			<description>&lt;br /&gt;
2006년 9월 마이크로소프트웨어 기고글입니다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
약 60여개의 C++ 키워드 중에 가장 사용 빈도가 낮은 키워드는 무엇일까? 정답은 volatile이다. 대부분의 C/C++ 참고 서적은 1-2줄 정도로 volatile이 컴파일러의 최적화(optimization) 막아준다고만 설명하고 있다. 또한 Java5 이후로 명확한 메모리 모델이 확립된 자바와는 달리 C/C++의 경우 volatile에 대한 명확한 표준이 없고 컴파일러마다 구현에 차이가 있다는 점도 volatile 키워드의 사용을 어렵게 하고 있다. 하지만 임베디드 시스템이나 멀티쓰레드 프로그래밍이 보편화된 만큼, 이 글에서는 volatile 키워드의 기초부터 다시 살펴보고자 한다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;volatile 소개&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;volatile로 선언된 변수는 외부적인 요인으로 그 값이 언제든지 바뀔 수 있음을 뜻한다. 따라서 컴파일러는 volatile 선언된 변수에 대해서는 최적화를 수행하지 않는다. volatile 변수를 참조할 경우 레지스터에 로드된 값을 사용하지 않고 매번 메모리를 참조한다. 왜 volatile이라는 키워드가 필요한지 이해하려면 먼저 일반적인 C/C++ 컴파일러가 어떤 종류의 최적화를 수행하는지 알아야 한다. 가상의 하드웨어를 제어하기 위한 다음 코드를 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(unsigned int *)0x8C0F = 0x8001&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(unsigned int *)0x8C0F = 0x8002;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(unsigned int *)0x8C0F = 0x8003;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(unsigned int *)0x8C0F = 0x8004;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(unsigned int *)0x8C0F = 0x8005;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt; &lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;잘못된 하드웨어 제어 코드&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 코드를 보면 5번의 메모리 쓰기가 모두 같은 주소인 0x8C0F에 이루어짐을 알 수 있다. 따라서 이 코드를 수행하고 나면 마지막으로 쓴 값인 0x8005만 해당 주소에 남아있을 것이다. 영리한 컴파일러라면 속도를 향상시키기 위해서 최종적으로 불필요한 메모리 쓰기를 제거하고 마지막 쓰기만 수행할 것이다. 일반적인 코드라면 이런 최적화를 통해 수행 속도 면에서 이득을 보게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;하지만 이 코드가 MMIO(Memmory-mapped I/O)처럼 메모리 주소에 연결된 하드웨어 레지스터에 값을 쓰는 프로그램이라면 이야기가 달라진다. 각각의 쓰기가 하드웨어에 특정 명령을 전달하는 것이므로, 주소가 같다는 이유만으로 중복되는 쓰기 명령을 없애버리면 하드웨어가 오동작하게 될 것이다. 이런 경우 유용하게 사용할 수 있는 키워드가 volatile이다. 변수를 volatile 타입으로 지정하면 앞서 설명한 최적화를 수행하지 않고 모든 메모리 쓰기를 지정한 대로 수행한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(volatile unsigned int *)0x8C0F = 0x8001&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(volatile unsigned int *)0x8C0F = 0x8002;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(volatile unsigned int *)0x8C0F = 0x8003;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(volatile unsigned int *)0x8C0F = 0x8004;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;*(volatile unsigned int *)0x8C0F = 0x8005;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;올바른 하드웨어 제어 코드&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;특정 메모리 주소에서 하드웨어 레지스터 값을 읽어오는 프로그램의 경우도 마찬가지다. 아래 코드의 경우 같은 주소에서 반복적으로 메모리를 읽으므로, 최적화 컴파일러라면 buf[i] = *p;에서 *p를 한 번만 읽어온 후에 그 값을 반복해 사용할 것이다. 하지만 volatile 키워드가 있다면 *p를 참조할 때마다 직접 메모리에서 새 값을 가져와야 한다. 이 경우는 하드웨어가 메모리 0x8C0F 번지 값을 새롭게 변경해 주는 경우이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;void foo(char *buf, int size)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    int i;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    volatile char *p = (volatile char *)0x8C0F;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    for (i = 0 ; i &amp;lt; size; i++)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        buf[i] = *p;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        ...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;하드웨어 레지스터 읽기&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;가시성&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;volatile 키워드는 앞서 살펴본 하드웨어 제어를 포함하여 크게 3가지 경우에 흔히 사용된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;(1) MMIO(Memory-mapped I/O)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;(2) 인터럽트 서비스 루틴(Interrupt Service Routine)의 사용&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;(3) 멀티 쓰레드 환경&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;세 가지 모두 공통점은 현재 프로그램의 수행 흐름과 상관없이 외부 요인이 변수 값을 변경할 수 있다는 점이다. 인터럽트 서비스 루틴이나 멀티 쓰레드 프로그램의 경우 일반적으로 스택에 할당하는 지역 변수는 공유하지 않으므로, 서로 공유되는 전역 변수의 경우에만 필요에 따라 volatile을 사용하면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int done = FALSE;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;void main()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    ...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    while (!done)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        // Wait&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    ...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;interrupt void serial_isr(void)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    ...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    if (ETX == rxChar)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        done = TRUE;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    ...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;} &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;serial.c&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 시리얼 통신 예제는 전역 변수로 done을 선언해서 시리얼 통신 종료를 알리는 ETX 문자를 받으면 main 프로그램을 종료시킨다. 문제는 done이 volatile이 아니므로 main 프로그램은 while(!done)을 수행할 때 매번 메모리에서 done을 새로 읽어오지 않는다는 점이다. 따라서 serial_isr() 루틴이 done 플래그를 수정하더라도 main은 이를 모른 채 계속 루프를 돌고 있을 수 있다. done을 volatile로 선언해주면 매번 메모리에서 변수 값을 새로 읽어오므로 이 문제가 해결된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;인터럽트의 경우와 마찬가지로 멀티 쓰레드 프로그램도 수행 도중에 다른 쓰레드가 전역 변수 값을 임의로 변경할 수 있다. 하지만 컴파일러가 코드를 생성할 때는 다른 쓰레드의 존재 여부를 모르므로 변수 값이 변경되지 않았다면 매번 새롭게 메모리에서 값을 읽어오지 않는다. 따라서 여러 쓰레드가 공유하는 전역 변수라면 volatile로 선언해주거나 명시적으로 락(lock)을 잡아야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이처럼 레지스터를 재사용하지 않고 반드시 메모리를 참조할 경우 &lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot;&gt;가시성(visibility)&lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt; 이 보장된다고 말한다. 멀티쓰레드 프로그램이라면 한 쓰레드가 메모리에 쓴 내용이 다른 쓰레드에 보인다는 것을 의미한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;문법과 타입&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;C/C++의 volatile은 상수(constant)를 선언하는 const와 마찬가지로 타입에 특정 속성을 더해주는 타입 한정자(type qualifier)이다. const int a = 5; 라고 선언했을 경우 a라는 변수는 정수 타입의 변수이면서 동시에 상수의 속성을 가짐을 의미한다. 같은 방식으로 volatile int a; 라고 선언해주면 정수 변수 a는 volatile 속성을 가지게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;조심해야 할 것은 포인터 타입에 volatile을 선언하는 경우이다. int *를 volatile로 선언하는 몇 가지 방법을 비교해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;volatile int* foo;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int volatile *foo;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int * volatile foo;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int volatile * volatile foo;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;volatile의 선언&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;복잡하게 보이지만 원리는 const 타입 한정자와 동일하다. *를 기준으로 왼쪽에 volatile 키워드가 올 경우 포인터가 가리키는 대상이 volatile함을 의미하고, * 오른쪽에 volatile 키워드가 올 경우에는 포인터 값 자체가 volatile임을 의미한다. volatile이 *의 양쪽에 다 올 경우는 포인터와 포인터가 지시하는 대상이 모두 volatile함을 의미한다. 하드웨어 제어의 예처럼 일반적으로 포인터가 가리키는 대상이 volatile 해야 할 경우가 많으므로 volatile int * 형태가 가장 많이 사용된다. volatile int*와 int volatile*은 동일한 의미이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;01: int foo(int&amp;amp; a)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;02: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;03: }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;04:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;05: int bar(volatile int&amp;amp; b)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;06: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;07: }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;08:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;09: int main()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;10: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;11:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     volatile int a = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;12:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     int b = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;13: &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;14:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     foo(a);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;15:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     bar(b);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;16: }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;$ g++ a.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;a.cc: In function `int main()&#039;:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;a.cc:14: error: invalid initialization of reference of type &#039;int&amp;amp;&#039; from expression of type &#039;volatile int&#039;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;a.cc:2: error: in passing argument 1 of `int foo(int&amp;amp;)&#039;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;또한 int는 volatile int의 서브타입에 해당한다. 서브 타입을 쉽게 설명하면 A를 요구하는 곳에 언제든지 B를 사용할 수 있다면 B는 A의 서브 타입이다. 쉬운 예로 Class의 경우 Derived 클래스는 Base 클래스의 서브 타입이다. volatile int를 요구하는 곳에 언제든지 int를 넘길 수 있으므로 int는 volatile int의 서브 타입이라고 말할 수 있는 것이다. 그 예로 위 C++ 프로그램은 컴파일 에러가 난다. volatile int를 받는 bar() 함수에 int 인자로 호출하는 것은 아무 문제없지만, int를 요구하는 foo() 함수에 volatile int 타입인 a를 넘기면 컴파일 에러가 나는 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;01: int foo(int&amp;amp; a)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;02: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;03: }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;04:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;05: int bar(const int&amp;amp; b)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;06: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;07: }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;08:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;09: int main()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;10: {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;11:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     const int a = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;12: &amp;nbsp; &amp;nbsp;&amp;nbsp;    int b = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;13: &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;14:&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;     foo(a);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;15: &amp;nbsp; &amp;nbsp;&amp;nbsp;    bar(b);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;16: }&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;foobar2.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 관계가 쉽게 이해되지 않는다면 위의 예처럼 volatile 키워드를 같은 타입 한정자인 const로 대체해보자. 변수 a는 const int 타입이므로 이미 상수로 선언되었다. const int인 a를 int를 요구하는 foO() 함수에 넘기면 const라는 가정이 깨어지므로 컴파일 에러가 된다. 반대로 b의 경우 원래 const가 아니었지만 bar로 넘기면서 const 속성을 새롭게 부여받게 된다. const 속성을 부여받는다고 말하면 무엇인가 기능이 추가되는 것 같지만, 이는 바꿔 말해서 원래 int의 2가지 기능인 읽기, 쓰기에서 쓰기 기능이 사라지는 것으로 볼 수도 있다. 이를 클래스로 표현해 보면 다음과 같을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class ConstInteger {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    public:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        ConstInteger(int v) : value(v) {}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        int get() { return value; }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    protected:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        int value;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class Integer : public ConstInteger {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    public:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        Integer(int v) : ConstInteger(v) {}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        void set(int v) { value = v; }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;ConstInteger.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 클래스를 두고 보면 volatile/const int와 int의 관계가 명확해진다. Integer는 ConstInteger을 상속한 클래스이므로 ConstInteger를 요구하는 곳 어디에나 쓸 수 있는 것이다. 반대로 Integer가 필요한 곳에 ConstIntger를 넘기면 set() 메쏘드가 없으므로 문제가 된다. 따라서 컴파일러는 이를 금지하는 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;volatile의 const와 같은 맥락에서 생각할 수 있다. volatile 속성을 부여받는 다는 것은 바꿔 말하면 컴파일러가 최적화를 할 자유를 잃는다고 말할 수 있다. ConstInteger의 경우만큼 명확하지는 않지만 이 관계를 클래스로 생각해 본다면 아마 다음과 같을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class VolatileInteger {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    public:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        VolatileInteger(int v) : value(v) {}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        int get() { return value; }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        void set(int v) { value = v; }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    protected:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        int value;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class Integer : public VolatileInteger {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    public:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        Integer(int v) : VolatileInteger(v) {}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        void optimize();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;VolatileInteger.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;재배치(reordering)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;지금까지 volatile 키워드의 일반적인 기능과 문법에 대해서 살펴보았다. C 표준은 volatile 키워드와 메모리 모델에 대한 명확한 정의를 내리지 않고 있기 때문에 컴파일러마다 그 구현에 다소 차이가 있다. C++ 표준은 volatile 대해 별도의 정의하지 않고 가능한 한 C 표준을 따르라고만 하고 있다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;마이크로소프트의 Visual C++를 예로 들어보면, volatile 키워드에 앞서 살펴본 가시성(visibility) 뿐만 아니라 재배치(reordering) 문제에 대한 해결책도 추가하였다. Visual C++의 volatile 변수는 다음과 같은 기능을 추가로 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;(1) &lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot; lang=&quot;EN-US&quot;&gt;volatile write&lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;: volatile 변수에 쓰기를 수행할 경우, 프로그램 바이너리 상 해당 쓰기보다 앞선 메모리 접근은 모두 먼저 처리되어야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;(2) &lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot; lang=&quot;EN-US&quot;&gt;volatile read&lt;/span&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;: volatile 변수에 읽기를 수행할 경우, 프로그램 바이너리 상 해당 읽기보다 나중에 오는 메모리 접근은 모두 이후에 처리되어야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;재배치(reordering)는 컴파일러가 메모리 접근 속도 향상, 파이프라인(pipeline) 활용 등 최적화를 목적으로 제한된 범위 내에서 프로그램 명령의 위치를 바꾸는 것을 말한다. 우리가 프로그램에 a = 1; b = 1; c = 1; 이라고 지정했다고 해서 컴파일된 바이너리가 반드시 a, b, c 순서로 메모리를 쓰지 않을 수 있다는 뜻이다. 만약 a, c가 같은 캐시(cache)에 있거나 인접해 있어서 같이 쓸 경우 속도 향상을 볼 수 있다면 a = 1; c = 1; b = 1; 로 순서가 바뀔 수 있는 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;Visual C++의 경우 volatile을 사용하면 컴파일러가 수행하는 이러한 재배치에 제약을 주게 된다. a = 1; b = 1; c = 1;에서 c가 volatile로 선언된 변수였다면 a = 1;과 b=1;은 반드시 c에 1을 대입하기 전에 일어나야 한다. 물론 a와 b 사이에는 순서가 없으므로 b = 1; a = 1; c = 1; 과 같은 형태로 재배치가 일어날 수는 있다. 재배치가 일어나지 않도록 보장하는 문제가 왜 중요한지는 MSDN에서 발췌한 다음 예를 통해 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;#include &amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;using namespace std;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;volatile bool Sentinel = true;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int CriticalData = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;unsigned ThreadFunc1( void* pArguments ) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   while (Sentinel)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;      Sleep(0);   // volatile spin lock&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   // CriticalData load guaranteed after every load of Sentinel&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   cout &amp;lt;&amp;lt; &quot;Critical Data = &quot; &amp;lt;&amp;lt; CriticalData &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   return 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;} &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;unsigned  ThreadFunc2( void* pArguments ) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   Sleep(2000);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   CriticalData++;   // guaranteed to occur before write to Sentinel&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   Sentinel = false; // exit critical section&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   return 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;int main() {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   HANDLE hThread1, hThread2; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   DWORD retCode;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   hThread1 = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&amp;amp;ThreadFunc1,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;      NULL, 0, NULL);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   hThread2 = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&amp;amp;ThreadFunc2,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;      NULL, 0, NULL);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   retCode = WaitForSingleObject(hThread1,3000);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   CloseHandle(hThread1);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   CloseHandle(hThread2);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   if (retCode == WAIT_OBJECT_0 &amp;amp;&amp;amp; CriticalData == 1 )&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;      cout &amp;lt;&amp;lt; &quot;Success&quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   else&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;      cout &amp;lt;&amp;lt; &quot;Failure&quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt; &lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;volatile.cpp&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 수행은 간단하다. 이 프로그램은 쓰레드를 2개 생성하는데 ThreadFunc1은 Sentinel 플래그가 true인 동안 루프를 돌고, ThreadFunc2는 잠시 기다렸다 Sentinel 플래그를 false로 만들어준다. ThreadFunc2는 Sentinel을 false로 만들기 전에 전역 변수인 CriticalData을 1만큼 증가시킨다.. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 프로그램에서 만약 Sentinel이 volatile로 선언되지 않았다면 ThreadFunc1은 가시성을 보장받지 못하므로, ThreadFunc2가 Sentinel의 값을 바꾸더라도, 레지스터에 든 값을 사용해 영원히 루프를 돌 수 있음은 이미 살펴보았다. 그럼 이번에는 volatile로 선언해서 Sentinel의 가시성이 보장된다면 이 프로그램의 수행 결과는 어떻게 될까?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;간단히 생각하면 CriticalData를 1증가 시킨 이후에 Sentinel을 false로 바꾸므로 ThreadFunc1은 1이라는 값을 찍을 것이라고 생각할 것이다. 하지만 CriticalData는 volatile이 아니므로 여전히 메모리가 아닌 ThreadFunc2의 레지스터에만 남아있을 확률이 있다. 이 경우 ThreadFunc1은 변경된 CriticalData가 아닌 0이라는 값이 나올 수 있다. 수행 타이밍에 따라서 0이 되기도 1이 되기도 하는 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;가정을 바꿔서 CriticalData 또한 volatile이라고 해보자. 모든 문제가 해결된 것 같지만, 결과는 여전히 0 혹은 1이 나온다. CriticalData가 volatile이면 레지스터가 아닌 메모리에 직접 쓰므로 가시성은 확보되지만, 재배치의 문제가 남아있다. 컴파일러가 보기에 ThreadFunc2의 CriticalData++과 Sentinel = false는 전혀 관계없는 변수이다. 따라서 최적화를 이유로 이 순서를 뒤집어 Sentinel = false를 먼저 수행하고 CiriticalData=+을 수행할 수 있다. 이 경우 ThreadFunc2에서 Sentinel = false만 수행하고 컨텍스트 스위치(context switch)가 일어난 경우 ThreadFunc1은 아직 CriticalData++이 수행되기 전에 CriticalData 값인 0을 읽을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;여기서 Visual C++가 추가한 시멘틱(semantic)을 적용해보자. ThreadFunc2에서 Sentinel = false는 volatile write이므로 프로그램 바이너리에서 그 이전에 수행되어야 할 명령은 모두 volatile write 이전에 수행되게 된다. 따라서 CriticalData++;은 반드시 Sentinel = false; 이전에 수행된다. ThreadFunc1은 Sentinel을 volatile read하므로 그 이후에 실행되는 CriticalData 읽기는 반드시 Sentinel을 읽은 후에 수행된다. 따라서 위 프로그램은 정확히 1을 출력하는 올바른 프로그램이 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;또한 재배치가 일어나지 않음을 보장할 경우 Sentinel이 volatile이기만 하면 CriticalData는 volatile이 아니더라도 가시성(visibility)이 보장되는 효과도 있다. 이렇게 다른 volatile 변수로 인해 공짜로 가시성을 얻는 경우 피기백킹(piggybacking, 돼지 등을 타고 공짜로 달린다는 의미)이라고 부른다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;좋은 코딩 습관으로 생각되었다가 재배치 문제로 안전하지 않음이 밝혀진 예로 더블 체크 이디엄(double check idiom)이 있다. 아래 코드처럼 initialized == false로 초기화 여부를 확인하고 객체를 생성해 얻어올 경우 반드시 락을 잡아줘야 한다. read-test-write는 원자적(atomic)이지 않기 때문에 여러 쓰레드가 동시에 초기화를 시작할 수 있기 때문이다. 문제는 한 번 초기화가 된 이후에도 매번 객체를 얻어갈 때마다 락을 잡고 풀어야 한다는 점이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;Foo* Foo::getInstance()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    mutex.lock();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    if (instance == 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        instance = new Foo();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    }   &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    mutex.unlock();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    return instance;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;} &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;check.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이러한 오버헤드를 피하기 위해 다음과 같은 일단 초기화 여부를 확인한 이후에 실제로 락을 잡아서 다시 한 번 정말 초기화되지 않았는지 확인하는 패턴이 널리 사용되었다. 이 경우는 앞선 예와는 달리 한 번 초기화가 이루어지고 나면 더 이상 락을 잡지 않고 객체를 얻어올 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 코드는 언뜻 보기에 무척 효율적으로 보이지만 재배치와 관련해 큰 문제가 있다. 특히 instance = new Foo(); 의 수행 순서가 문제가 된다. 메모리를 할당 받아 생성자를 호출한 후에 메모리 주소를 instance를 대입한다고 하면 별 문제가 없겠지만, 일부 필드의 초기화 과정과 instance의 포인터 대입의 순서가 컴파일러 재배치로 인해 바뀔 수 있다. 이 경우 아직 일부 필드가 초기화되지 않은 상태에서 instance가 0이 아니게 되므로, 다른 쓰레드가 객체를 얻을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;Foo* Foo::getInstance()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    if (instance == 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        mutex.lock();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        if (instance == 0) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;            instance = new Foo();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;        }   &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;        mutex.unlock();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    }   &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    return instance;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;} &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;double_check.cc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;지금까지 C/C++의 volatile 키워드의 기본적인 기능과 관련된 문제들을 살펴보았다. volatile은 미묘한 키워드라 잘 알고 쓰면 큰 도움이 될 수 있지만, 또한 여러 가지 문제를 일으키는 근원이 되기도 한다. 특히 명확한 표준이 있는 게 아니므로, 사용하는 자신이 사용하는 C/C++ 컴파일러의 매뉴얼을 꼼꼼히 읽고 volatile을 어떻게 지원하는지 파악하는 게 중요하다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;volatile은 단일 CPU 환경에서 컴파일러 재배치 문제는 해결해주지만, MMU나 멀티CPU에 의한 재배치에 대해서는 완전한 대안을 제공하지 못한다. 또한 변수를 읽은 후에 값을 수정하고 다시 쓰는 read-modify-write를 원자적으로 수행할 수 있게 해주지도 않는다. a += 5; 같은 단순한 명령도 실제로는 a를 메모리에서 읽고 5를 더한 후에 다시 메모리 쓰는 복잡한 연산이므로 a를 volatile로 선언하는 것만으로는 이 코드를 멀티쓰레드에서 안전하게 수행할 수는 없다는 뜻이다. 유용성과 한계를 충분히 인지하고 필요에 따라 적절히 volatile을 사용하자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;참고문헌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;[1] The &quot;Double-Checked Locking is Broken&quot; Declaration &lt;/span&gt;&lt;a href=&quot;http://www.cs.umd.edu/%7Epugh/java/memoryModel/DoubleCheckedLocking.html&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M; color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&lt;br /&gt;
&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>C</category>
			<category>C++</category>
			<category>volatile</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/337</guid>
			<comments>http://skyul.tistory.com/337#entry337comment</comments>
			<pubDate>Mon, 01 Dec 2008 23:17:58 +0900</pubDate>
		</item>
		<item>
			<title>버그 잡기. 프로그램 분석 도구를 이용하자.</title>
			<link>http://skyul.tistory.com/336</link>
			<description>&lt;br /&gt;
마이크로소프트웨어 2006년 4월 기고글입니다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
소프트웨어 개발 관련 기술은 빠른 속도로 발전하고 있지만, 여전히 많은 개발자들은 코드 속의 버그와 전쟁을 벌이고 있다. 소프트웨어는 다른 산업과 달리 이례적으로 개발 비용보다 유지 보수비용이 훨씬 크다. 개발 과정에서 유지보수가 차지하는 비중이 1980년대에 50%에서 2000년 이후에는 90%라는 조사가 있을 정도이다. 유지보수는 소프트웨어의 요구사항이 지속적으로 변화한다는 문제에서 기인하지만, 설계, 구현 과정에서 발생한 버그 수정도 상당 부분을 차지한다. 수많은 소프트웨어 전문가는 이런 버그, 달리 말해서 소프트웨어 결함을 줄이기 위해 상당한 노력을 기울여 왔으며, 최선의 소프트웨어 프로세스와 코드 감사 및 리뷰에 의존하던 수동적인 버그 발견 및 수정 절차를 어느 정도 자동화하기에 이르렀다. 그 정점에 서있는 기술이 정적 프로그램 분석(static program analysis) 기술이다. 이 글에서는 자바 언어의 프로그램 분석 도구인 FindBugs 프로젝트를 중심으로, 버그 없는 소프트웨어 작성 프로세스에 대해 이야기해 보겠다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;소프트웨어의 버그는 정말 무섭다. 잘못된 한 줄의 코드가 수천 수백억의 재산을 한순간에 날려버릴 수 있다. 실제로 1998년 화성 주변을 돌던 인공위성이 파괴되었다. 이 사건은 미국식 단위(feet)를 사용하던 한 소프트웨어모듈과 미터법을 사용하는 다른 모듈이 결합되어 생긴 결과였다. 나사(NASA)의 과학자들은 인공위성이 파괴되기 전까지 이런 버그가 존재한다는 사실조차 모르고 있었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;상업용 소프트웨어도 사정이 다르지 않다. 2005년 7월 안티 바이러스 소프트웨어 벤더인 트렌드 마이크로(Trend Micro) 사는 자사 제품의 버그로 인해, 8백만 달러(약 80억 원)를 배상해야만 했다. 이 버그는 백신 업데이트를 다운받은 사용자의 CPU를 점유하여 성능을 떨어뜨렸다. 콜센터는 폭주했고, 기업은 명성을 잃고 엄청난 비용을 치러야만 했다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;소프트웨어는 버그와 전쟁을 벌이고 있다고 해도 과언이 아니다. 따라서 소프트웨어 결함을 조기에 발견하고 효과적으로 줄이기 위한 연구가 소프트웨어 공학을 중심으로 계속되고 있다. 또한 이와 별개로 소프트웨어의 버그를 자동으로 찾아주는 프로그램에 대한 연구도 무척 활발히 진행되고 있다. 이 글에서는 후자에 속하는 프로그램 분석 기술을 자세히 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;프로그램 분석&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;소프트웨어 개발은 대부분의 일을 사람이 해왔지만, 근래의 소프트웨어의 눈부신 발전은 반복적이고 귀찮은 개발 과정의 상당수를 자동화하기에 이르렀다. 이제 우리는 요구사항 분석,  설계, 구현, 테스트, 유지 보수에 이르는 소프트웨어 개발의 전 과정을 CASE(Computer Aided Software Engineering) 도구의 도움을 받아서 수행하고 있다. 구현과 테스트 측면에서만 본다면, 작게는 디버깅, 테스팅, 프로파일링을 비롯한 개별 기능을 수행하는 개발도구가 있고, 크게는 이런 도구들을 통합하는 통합개발도구(IDE)가 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;소프트웨어 개발 방법은 역사를 살펴보면, 개발 도구의 발전과 그 맥을 같이한다. 과거 컴파일러조차 없던 시절의 개발자들은 어셈블리 코드, 혹은 기계어를 직접 컴퓨터에 입력해야 했으며, 작은 실수조차도 원인을 알 수 없는 심각한 버그가 되는 경우가 많았다. C를 비롯한 다음 세대의 고급 언어의 출현은 컴파일러라는 자동화 도구가 있었기 때문에 가능했다. 컴파일러는 C에서 어셈블리 언어로의 번역 과정을 자동화 했을 뿐만 아니라, 개발자가 흔히 저지르는 실수와 오류를 즉시 교정해 주는 역할을 하였다. 예컨대, C언어에서 구문 끝에 세미콜론(;) 하나를 빠뜨려서 몇 시간씩 코드를 검토해야 하는 일은 없어진 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;다시 말해서 우리가 알고 있는 단순히 언어 번역기로만 알고 있는 컴파일러는 사실 두 가지 기능을 수행한다. 첫째는, 컴파일러 고유의 기능인 한 언어를 또 다른 언어(보통 어셈블리 언어)로 번역하는 것이다. 둘째는, 번역하는 프로그램 언어 속에 존재하는 구문 오류를 찾아내서 즉시 개발자에게 알려준다. 즉 컴파일 과정은 런타임에 버그가 될 수 있었던 잠재적인 소프트웨어 결함을 조기에 발견하는 효과가 있다. 이때 컴파일러가 사용하는 기법에는 구문 검증 기술(parsing), 타입 시스템(type system) 등이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;하지만 구문이 정확하고, 타입 오류가 없는 프로그램이 버그가 없는 프로그램은 아니다. 실제로 구문 검증과 타입 시스템은 수많은 소프트웨어 버그 중에서 극히 일부만을 찾아낼 뿐이다. 컴퓨터 과학자들은 좀 더 많은 버그를 찾아내고자 연구를 거듭했고, 그 결과로 나온 기술이 자동 증명(theorem proving)과 정적 프로그램 분석(static program analysis)(줄여서 정적 분석이라고도 함)이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 분석은 간단히 말해서 프로그램을 실제로 수행시켜 보기 전에 프로그램의 여러 성질을 파악해서, 버그가 있는지 없는지를 판별해 내는 기술이다. 우리가 버그를 찾아내기 위해 흔히 사용하는 기술인 테스팅은 런타임에만 버그를 찾을 수 있다. 하지만 테스팅이 모든 프로그램 수행 경로를 실행시켜 보는 것이 불가능하기 때문에 버그를 찾아내는데 한계가 있는 반면에, 프로그램 분석은 프로그램을 실제로 실행시키지 않으므로 탐지 가능한 모든 버그를 찾아낼 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 4&quot;&gt;&lt;span style=&quot;font-family: 한양견고딕;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(243, 197, 52); padding: 10px; background-color: rgb(254, 254, 184);&quot; class=&quot;txc-textbox&quot;&gt;
프로그램 분석(static program analysis)은 프로그램을 수행하기 전에 버그를 발견한다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 4&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양견고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;특히 타입 시스템이 풀지 못했던, 배열 경계를 벗어나는 오류, 널 포인터 오류, 레이스 컨디션 오류 등이 이런 프로그램 분석이 해결하고자 하는 주요 결함이다. 얼마 전에 마소에도 소개된 적이 있는 서울대 이광근 교수진에서 개발한 아이락(Airac)도 정적으로 C언어의 배열 경계 검사를 해주는 프로그램 분석 도구이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 분석 기술은 하나의 단어로 이야기하지만, 실제 분석 기술은 매우 다양하다. 단순히 프로그램의 특정 버그 패턴을 찾아내는 기술도 있고, 아이락처럼 프로그램을 요약해서 가상으로 수행시켜보는 요약 해석(abstract interpretation), 각종 데이터/제어 흐름 분석, 진보된 타입 시스템 등 다양한 기술이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px dashed rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Airac&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Airac(Static Analyzer for Automatic Verification of Array Index Ranges in C Programs)은 서울대에서 개발한 C 프로그램 분석 도구이다. 특히 Airac는 C 프로그램에서 발생 가능한 배열 인덱스 오류를 찾아준다. 배열 인덱스 오류는 잠재적인 버퍼 오버플로우 등의 주요 원인이므로, 이 문제를 미리 해결할 수 있으면 프로그램에 상당한 안전성을 확보할 수 있다. Airac은 nML이라는 함수형 프로그래밍 언어로 작성되었는데, 불행히 프로그램과 소스 코드는 라이선스 계약을 통해서만 얻을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;버그를 찾아라. FindBugs!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 분석 도구의 개념은 참 근사해 보인다. 개발자들이 엄청난 시간을 지겨운 디버깅과 버그 수정에 보낸다는 사실을 생각하면, 자동으로 버그를 찾아주는 도구는 자동으로 코딩을 해주는 도구만큼이나 매력적이다. 하지만 개발자는 반대로 그런 도구가 존재할까라는 의구심을 가지며, 현재 기술 수준으로는 생산적인 소프트웨어 개발에 도움이 될 만큼 훌륭한 분석 도구가 없다고 생각한다. 프로그램 분석 도구가 개발 과정에 가져다 줄 이점을 느껴보려면 실제로 분석 도구를 사용해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 분석 도구는 널리 사용되고 있지 않아서 그렇지, 실제로 꽤 많은 프로젝트가 활발히 개발 중이다. 그중 가장 많은 사용자를 가진 자바 프로그램 분석 도구로 메릴랜드 대학에서 개발한 FindBugs(http://findbugs.sourceforge.net/)가 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;FindBugs 프로젝트는 다음과 같은 흥미로운 관찰 결과를 바탕으로 시작하였다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;◆ 훌륭한 개발자도 종종 바보 같은 실수를 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;◆ 여러 버그는 비슷한 성질을 가지고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;◆ 버그 패턴: 빈번히 오류가 되는 코드 사용법(idiom)이 있다&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;◆ 이런 버그 패턴을 자동으로 찾을 수 있을까? Yes!&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;일단 훌륭한 개발자도 종종 바보 같은 실수를 한다는 점을 보자. 다음은 Eclipse 2.1.0에 실제로 있었던 코드이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;if (entry == null) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   IClasspathContainer container=&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   JavaCore.getClasspathContainer(entry.getPath(),&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   root.getJavaProject());&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;   ...&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Eclipse 2.1.0 org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor 코드 일부&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;if (!searchQueryData.isBookFiltering()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;   &amp;amp;&amp;amp; (lastWS != null || lastWS.length() &amp;gt; 0)) {&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Eclipse 2.1.0 org.eclipse.help.ui.internal.search.HelpSearchPage 코드 일부&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 코드의 버그는 매우 명백하다. entry가 null인지 확인한 후에 entry.getPath()를 부르므로, 이 코드에 들어가면 무조건 NullPointerException이 발생한다. lastWS의 경우도 마찬가지 문제가 있다. 이 코드를 작성한 사람은 절대 초보 개발자가 아니다. 많은 경험을 가진 훌륭한 개발자라도 가끔은 이런 실수를 하기 마련이다. 하지만 이런 실수를 했다는 사실보다 더 놀라운 것은, 이 코드가 Eclipse 2.1.0까지 발견되지 않고 그대로 코드 속에 남아있었다는 점이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;하지만 FindBugs를 이용하면 이러한 NullPointer 버그는 프로그램을 수행해 보기도 전에 곧바로 잡아낸다. 데이트 흐름 분석(data flow analysis), 제어 흐름 분석(control flow analysis) 등의 기법을 사용하면 이런 문제를 정적으로 발견하는 것이 가능하기 때문이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이미 소프트웨어 공학은 소프트웨어 결함(버그) 발견의 시기와 비용간의 상관관계에 대한 많은 분석을 수행하였다. 여기서 얻은 결론은 버그를 빨리 발견할수록 수정하는데 비용이 적게 든다는 것이다. 마이크로소프트가 보안 결함이 있는 소프트웨어를 배포해놓고, 이를 패치하기 위에 들이는 노력을 생각한다면 같은 버그를 테스트 단계, 혹은 구현 단계에서 발견할 수 있다는 그 경제적 이익은 엄청나다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;다른 예제를 살펴보자. 자바는 언어 차원에서 멀티쓰레드 프로그래밍을 지원하며, 네트워크를 비롯한 여러 라이브러리에서 쓰레드 사용을 장려하고 있다. 하지만, 멀티쓰레드 프로그램의 버그는 프로그램 수행을 예측할 수 없게 만든다. 항상 잘되다가 가끔씩만 문제가 생기는 버그는 거의 대부분 이 멀티 쓰레드 버그의 속성 때문이다. 하지만 정작 버그 자체만 놓고 보면 정말 사소한 개발자의 실수로 밝혀지는 경우가 대부분이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;while (!someCondition) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    synchronized (lock) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        lock.wait();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 예제는 개발자들이 자주 저지르는 멀티 쓰레드 프로그래밍 관련 오류이다. 원래는synchronized 블록에 들어가서 조건 검사를 해야 하는데, 반대로 조건부터 검사하고 락(lock)을 잡은 경우이다. while 조건 검사와 synchronized 블록 사이에 다른 쓰레드가 조건을 변경할 수 있으므로, 이 프로그램은 레이스 컨디션에 취약하다. 사소한 실수이지만, 이런 종류의 버그를 테스트로 찾아내는 것은 거의 불가능하다. 멀티쓰레드 버그는 타이밍에 민감하기 때문에 보통 소프트웨어가 릴리즈된 후에야 발견된다. 물론 그만큼 버그 파악과 해결에 걸리는 비용도 커진다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;FindBugs를 이용하면 일부 멀티 쓰레드 관련 버그를 매우 쉽게 발견할 수 있다. FindBugs는 자바 바이트 코드를 분석해서 버그를 찾는다. 위 버그의 경우 자바 바이트 코드에서  monitorenter와 Object.wait() 호출이 연달아 오는 패턴만 찾아내면 된다. 정적 분석 도구는 코드를 실제로 수행시켜 보는 것이 아니므로 멀티쓰레드 프로그램의 버그를 찾아내는데 가장 효율적인 방법이라 할 수 있다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;뿐만 아니라 FindBugs는 사용자들이 자바 언어/라이브러리를 잘못 이해하고 사용하는 경우도 탐지한다. 예를 들어 자바는 객체의 비교를 위해 equals라는 메쏘드를 이용하는데, 실수로 연산자(==)를 사용할 수도 있다. 라이브러리를 잘못 사용한 경우는 자바의 경우 해시 테이블(hash table)에 객체를 삽입하기 위해서는 hashCode와 equals를 모두 오버라이드해야 하는데 어느 한쪽만 오버라이드하는 경우도 있다. FindBugs는 이런 문제도 자동으로 찾아서 알려준다. 이런 패턴은 발견하는 데로 계속 추가가능하기 때문에 FindBugs의 탐지 기능은 지속적으로 발전하고 있다. 지면 관계상 여기에 모든 기능을 소개할 순 없지만, 보통 개발자들이 생각하는 것보다 훨씬 많은 버그를 잡아낸다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px dashed rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;PMD&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;PMD(http://pmd.sourceforge.net/)는 자바 프로그램에서 버그를 찾아주는 프로그램 분석 도구이다. FindBugs와는 달리 버그뿐만 아니라, 최적화되지 못한 코드, 데드 코드(dead code), 중복 코드 등도 찾아준다. 룰셋(ruleset)이라고 불리는 메커니즘으로 잠재적으로 버그나 문제가 될 수 있는 프로그램의 패턴을 지정하는 방식을 사용한다. PMD 역시 Eclipse를 비롯한 다양한 통합개발도구에 대한 플러그인을 제공하므로, 개발 과정에서 지속적인 피드백을 얻을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;프로그램 분석 사용 사례&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;아직까지도 프로그램 분석이 일상 개발과는 거리가 먼 이야기로 들린다면, 실제로 많은 소프트웨어 개발 프로젝트가 이미 프로그램 분석 도구 사용을 개발 과정의 일환으로 생각하기 시작했다는 사실을 말해주고 싶다. DOM, JDOM의 문제점을 지적하며 새로운 오브젝트 모델을 지향하고 나선 XOM도 FindBugs를 개발에 차용하고 있다. XOM는 프로젝트 홈페이지에 디자인 원리를 잘 정리해놓았는데, 개발 스타일에 JUnit을 이용한 단위 테스트와 함께 정적 검사(FindBugs와 PMD)를 명시하고 있다. XOM은 초기부터 FindBugs, 이와 유사한 도구인 PMD를 이용해 버그를 줄이는 방법을 쓰고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;FindBugs 외에도 나사와 하니웰 테크놀로지(Honeywell Technology Center)에서 개발한 반데라(Bandera)라는 정적 분석 도구도 있다. 이 도구는 멀티 쓰레드 프로그램의 오류를 찾아주는데, 항공 운항을 위한 실시간 운영체제인 DEOS(Digital Engine Operating System)의 오류를 찾아낼 수 있었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;프로그램 분석 도구는 어떻게 활용하는 것이 가장 좋을까? 방법은 실로 다양하다. 어느 정도 기간을 두고 한두 번씩 프로그램 분석 도구를 사용하여 버그를 잡아내는 방법도 있고, 개개인의 개발자가 Eclipse 같은 통합 개발 환경에 FindBugs를 설치하여 컴파일할 때마다 어떤 버그를 만든 건 아닌지 확인하는 방법도 있다. 혹은 소스 코드 관리 도구(CVS 혹은 SubVersion 같은 도구)에 저장된 소스 코드를 자동으로 꺼내와 프로그램 분석 도구를 수행한 후에 결과를 관련 개발자들에게 이메일로 보내는 방법도 있다. 단위 테스트나, 매일 빌드(daily build)가 비슷한 과정을 거쳐서 도입되었다는 점에 유의할 필요가 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;결론은 프로그램 분석 도구는 비용대비 무척 효율적인 버그 발견 방법이라는 점이다. 버그를 조기에 자동으로 발견할 수 있다는 장점을 애써 무시할 필요는 없는 법이다. 실제로 일부 개발자들은 오픈 소스를 꺼내와 FindBugs를 돌린 결과에서 버그를 발견해 오픈 소스에 기여하고 있는 경우도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;앞으로&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;지금까지 프로그램 분석 도구의 장점과 이를 도입했을 때 얻을 수 있는 이점에 대해 간략히 소개하였다. 하지만 소프트웨어 개발에 만병통치약이란 없다. 프로그램 분석 도구의 고질적인 문제로는 아직까지 완벽하게 버그만을 발견해내지 못한다는 점이다. 가끔은 버그가 아닌 코드를 버그라고 하는 허위 경보(false positive)를 내기도 하고, 아예 버그를 발견하지 못하는 탐지 실패(false negative) 문제도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;하지만 소프트웨어 결함 제거는 일종의 전선이다. 제 1 전선이 무너지면, 코드 리뷰, 검토, 단위 테스트, 기능 테스트, QA라는 2, 3, 4 전선이 계속 남아있다. 프로그램 분석 도구는 코딩 단계에서 버그를 최대한 빨리 발견하기 위한 제 1 전선의 역할을 훌륭하게 해낸다. 프로그램 분석 도구가 한 명의 적군(버그)라도 쓰러뜨린다면 우리 개발자가 개발 전쟁에서 승리할 확률이 더 높아짐을 명심하자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;리스트&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;&lt;br /&gt;</description>
			<category>FindBugs</category>
			<category>static analysis</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/336</guid>
			<comments>http://skyul.tistory.com/336#entry336comment</comments>
			<pubDate>Mon, 01 Dec 2008 00:32:29 +0900</pubDate>
		</item>
		<item>
			<title>객체지향+함수형 프로그래밍 언어 Scala</title>
			<link>http://skyul.tistory.com/335</link>
			<description>&lt;br /&gt;
마이크로소프트웨어 2008년 5월 기고글입니다.&lt;br /&gt;
&lt;br /&gt;&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
스칼라(Scala)는 객체지향 언어이면서 동시에 함수 언어이다. 스칼라는 자바와 마찬가지로 자바가상머신(JVM) 위에서 실행되며 기존 자바 라이브러리를 그대로 사용할 수 있다. 반대로 자바로 작성된 프로그램에서 스칼라로 작성된 라이브러리를 사용할 수도 있다. 다른 JVML(JVM 언어)인 JRuby, Jython과 마찬가지로 스칼라는 자바의 한계를 극복하기 위해 출현했다. 특히, 이미 설계된 컴포넌트 단위의 자바 라이브러리들을 효율적으로 재사용하기 위해서는 함수 언어의 특징인 고차 함수, 패턴 매칭 등이 필요하다는 것이다. 이 글에서는 자바와의 차이점을 부각시켜 스칼라의 특징과 장단점을 살펴보려 한다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;왜 새로운 언어가 필요했을까?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 언어를 만든 사람은 GJ, Pizza 프로젝트 등으로 유명한 마틴 오더스키(Martin Odersky)다. 그가 주도한 GJ와 Pizza는 자바 언어에 인자 다형성(parametric polymorphism)을 추가한 리서치 프로젝트였고 이런 결과물은 이후 자바 5의 제네릭스가 되었다. 하지만 JVM을 변경하지 않고 컴파일러 기술만으로 구현한 제네릭스는 성공이라고 보기 힘들었다. 오더스키는 이런 접근법에 한계를 느끼고, 함수 언어의 장점을 적극 반영한 새로운 JVML을 만들었다. 이렇게 나온 결과물이 스칼라이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라의 목표는 컴포넌트 소프트웨어를 잘 지원하기 위한 언어이다. 자바는 대규모 개발 프로젝트에 주로 사용되는 언어이고, 각종 프레임워크를 가져와서 조합해 사용하는 경우가 다른 언어보다 압도적으로 많다. 하지만 자바 언어 자체는 소형 디바이스를 지원하기 위한 오크(Oak)라는 프로그래밍 언어에서 출발했고, 웹에서도 소형 애플릿 작성을 주로 사용되었다. 이런 자바를 각종 프레임워크로 포장해 대형 프로젝트에 사용하기 시작하다보니 언어의 한계로 인해 여러 문제점을 겪게 되었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;컴포넌트 지원 언어는 2가지 특징을 가져야 한다. 첫째, 규모 가변적(scalable)해야 한다. 바꿔 말해, 컴포넌트의 크기와 관계없이 항상 같은 방법으로 사용할 수 있어야 한다는 것이다. 또한, 언어에 복잡한 요소를 더하기 보다는 추상화(abstraction), 조합(composition), 분해(decomposition)에 초점을 맞춰야 함을 의미한다. 둘째, 이런 특징을 만족시키기 위해서 프로그래밍 언어는 객체지향적일 뿐만 아니라 함수형이어야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;HelloWorld&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라를 본격적으로 공부하기에 앞서 스칼라의 기본적인 문법과 취향을 느낄 수 있도록 먼저 HelloWorld 프로그램을 작성해보자. 비교를 위해 자바 HelloWorld를 나란히 배치했다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;object HelloWorld {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def main(args: Array[String]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        println(&quot;Hello, world!&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Scala HelloWorld&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;class HelloWorld {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    public static void main(String[] args) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        System.out.println(&quot;Hello World!&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Java HelloWorld&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;일단 가장 큰 차이점으로 HelloWorld 클래스를 선언할 때 스칼라 프로그램은 object라는 키워드를 쓰고 있다. 스칼라는 class와 object를 구분하는데, object는 싱글톤(singleton)으로 클래스의 객체를 하나만 생성함을 의미한다. 스칼라 HelloWorld는 싱글톤이기 때문에 main 메서드를 선언할 때도 static이라는 키워드를 사용하지 않는다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바에서는 화면에 문자열을 출력하기 위해 System.out.println을 사용했는데, 스칼라는 간결하게 println이라고 사용할 수 있다. 자바는 문장의 끝에 세미콜론을 항상 붙여줘야 하는데, 스칼라는 세미콜론이 없다. 자바는 타입을 먼저 쓰고 변수를 선언하는데, 스칼라는 변수 : 타입 형태로 변수를 선언한다. 자바에서 String[]인 문자열 배열은 스칼라에서는 Array[String]으로 쓴다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;스칼라 인터프리터와 컴파일러&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라를 설치하고 스칼라 바이너리(scala)를 실행시키면 다음과 같이 인터프리터 모드로 동작한다. 인터프리터 모드에서는 입력되는 식을 계산해서 결과를 보여준다. 이후 예제에서 scala&amp;gt;가 나오면 인터프리터에 입력한 것으로 생각하면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;C:\Users\Administrator&amp;gt;scala&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Welcome to Scala version 2.7.0-final (Java HotSpot(TM) Client VM, Java 1.6.0_10-&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;beta).&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Type in expressions to have them evaluated.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Type :help for more information.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; 3+5&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;res1: Int = 8&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 인터프리터&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 컴파일러(scalac)는 스칼라 코드를 자바 클래스파일(바이트코드)로 컴파일해준다. 사용법은 자바 컴파일러(javac)와 유사하다. 위 HelloWorld.scala라는 컴파일하려면 다음과 같이 명령을 내려주면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;C:\Users\Administrator&amp;gt;scalac HelloWorld.scala&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;스칼라 컴파일러&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;컴파일된 스칼라 프로그램을 실행시키려면 scala를 이용하면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;C:\Users\Administrator&amp;gt;scala HelloWorld&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Hello, world!&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;스칼라 프로그램의 실행&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;순수 객체지향 언어&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바의 타입은 기본 타입(primitive type)과 레퍼런스 타입(reference type)으로 나뉘고, 이진(boolean), 정수(int), 부동소수점(float, double) 등 기본 타입은 객체가 아니다. 이런 방식은 성능 향상에는 큰 도움이 되지만, 기본 타입과 레퍼런스 타입 사이를 변환하는 박싱(boxing), 언박싱(unboxing) 등의 문제로 프로그래밍 언어가 복잡해지는 문제가 있다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바 5에는 기본 타입과 레퍼런스 타입을 필요에 따라 자동변환해주는 오토박싱, 오토언박싱 기능이 들어갔지만, 기본 타입과 레퍼런스 타입으로 이원화된 타입 시스템 자체는 달라지지 않았다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;반대로 스칼라는 스몰토크, 루비와 마찬가지로 순수 객체지향 언어이다. 스칼라는 정수 5가 scala.Int 클래스의 객체이며, +, -, , *, / 등의 연산자는 하나의 인자를 받는 메서드다. 예를 들어 1 + 2 * 3 / x 같은 수식은 1.+(2.*3./(x)))와 같이 전부 메서드 호출로 변경된다. 스칼라에서는 자바에서 특수 문자로 취급하던 +, -, *, / 등의 문자도 메서드 이름으로 사용할 수 있음을 의미한다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;아래 그림에서 볼 수 있듯이 스칼라의 클래스 계층도는 scala.Any를 최상위로 해서 값(scala.AnyVal)과 레퍼런스(scala.AnyRef)를 하나의 계층으로 아우르고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfs14.tistory.com/original/18/tistory/2008/12/01/00/11/4932ad2c8146f&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs14.tistory.com/image/18/tistory/2008/12/01/00/11/4932ad2c8146f&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;scalaclass.png&quot; height=&quot;348&quot; width=&quot;540&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라의 클래스 계층도&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;함수 언어&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 모든 함수를 객체로 취급한다. 바꿔 말해, 스칼라에서 함수를 함수의 인자로 넘길 수도 있고, 함수의 리턴 값으로 함수가 리턴될 수도 있음을 의미한다. 스칼라 입문서에 있는 간단한 예제를 하나 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;object Timer {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def oncePerSecond(callback: () =&amp;gt; unit) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        while (true) { callback(); Thread sleep 1000 }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def timeFlies() {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        println(&quot;time flies like an arrow...&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def main(args: Array[String]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        oncePerSecond(timeFlies)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;함수를 함수의 인자로 넘기는 예제&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;위 예제는 Timer라는 클래스를 만들어, main에서 oncePerSecond라는 메서드를 호출할 때 또 다른 메서드인 timeFlies를 인자로 넘겨준 예제이다. oncePerSecond 함수의 인자를 보면 callback이 () =&amp;gt; unit이라는 타입을 가짐을 알 수 있는데, ()는 인자를 하나도 받지 않음을 뜻하고, unit은 자바의 void와 유사하게 리턴 값이 없음을 뜻한다. 위 프로그램은 1초마다 한번씩 callback으로 넘어온 timeFlies 메서드를 호출하게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이 예제에서 하나 재미있는 사실은 Thread의 sleep 메서드를 호출할 때 Thread sleep 1000라고 적은 부분이다. 스칼라에서는 인자가 하나인 메서드를 호출할 때, 메서드 호출자(.)를 생략하고 위와 같이 적을 수 있다. 앞서 +, - 등이 메서드라고 언급했는데 1.+(2)가 아닌 1 + 2로 적을 수 있는 이유도 마찬가지다. 1 + 2에서 1은 리시버 오브젝트(receiver object), +는 메서드, 2는 + 메서드의 인자인데, 스칼라에서는 간결함을 위해 1.+(2)라고 적는 대신에 1 + 2라고 적을 수 있게 허용한 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정적 타입 시스템&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 자바에 비해 간결한 문법을 제공하지만, 강력한 정적 타이핑을 제공한다. 스칼라는 동적 JVML 언어인 그루비, JRuby, Jython 등과 달리 컴파일 타임에 모든 타입 오류를 잡아낼 수 있다. 스칼라가 여러 컴포넌트를 통합하기 위해 만들어진 언어라는 점을 감안하면 통합 오류를 조기에 잡아내는 정적 타입 시스템은 자연스러운 선택이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;대신 스칼라는 같은 정적 타이핑을 사용하는 자바와 달리 경우에 따라 타입을 생략할 수 있다. 사용자가 모든 타입을 적어주지 않더라도 스칼라 컴파일러가 타입 추론(type inference)을 통해 부족한 부분을 채워주기 때문이다. 타입 추론은 자바 스타일의 문법을 가진 스칼라를 동적 타이핑하는 그루비나 루비처럼 간결하게 만들어주는 핵심 요소이다. (스칼라 코드는 같은 일을 하는 자바 코드의 1/3 정도 밖에 안 된다.)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;일례로, 정수 2개를 더해서 돌려주는 add 함수를 생각해보자. add 함수를 정의할 때 x와 y는 정수 타입으로 정의를 해줬지만 add 함수의 리턴 타입은 생략했다. 하지만 스칼라 컴파일러가 봤을 때 정수 x와 정수 y를 더한 값을 돌려주므로 리턴 타입은 자동으로 Int가 된다는 사실을 추론해낼 수 있다. 이 함수를 인터프리터에 입력해보면, 인터프리터가 add의 타입을 (Int,Int)Int라고 정확히 추론해냄을 볼 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; def add(x: Int, y: Int) = x + y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;add: (Int,Int)Int&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 타입 추론 (리턴 타입을 추론한 경우)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;물론 다음과 같이 타입을 모두 적어줘도 무방하다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; def foo(x: Int, y: Int): Int = x + y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;foo: (Int,Int)Int&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 타입 추론 (모든 타입을 써준 경우)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;하지만 동적 타이핑하는 언어와 달리 모든 타입을 생략하면 컴파일러가 타입을 추론할 없기 때문에 오류가 발생한다. 스칼라 코딩을 처음 시작한 사람들은 타입을 어느 정도 생략해도 되는지 알기 어려운데, 시행착오를 통해 컴파일러가 어디까지 타입 추론을 해주는지 감을 잡는 일이 필요하다. 단, 컴파일러가 추론할 수 있더라도 필요한 경우에는 적절히 타입을 써주면 코드의 가독성을 높일 수 있음을 명심하자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; def foo(x, y) = x + y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;console&amp;gt;:1: error: &#039;:&#039; expected but &#039;,&#039; found.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;       def foo(x, y) = x + y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                ^&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;console&amp;gt;:1: error: identifier expected but eof found.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;       def foo(x, y) = x + y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                            ^&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 타입 추론 (실패)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;선언(val/var/def)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 변수를 선언할 때 자바처럼 모든 타입을 다 적어줄 필요가 없다. 변수 x를 선언하고 1을 넣어주려면 다음과 같이 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var &lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;키워드를 사용하면 된다. &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;은 자바 변수와 동일하다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; var x = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; x = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int = 2&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;var의 사용&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var &lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;외에도 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;을 통해 값을 선언할 수 있는데, &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;은 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;로 선언된 변수와 달리 값이 변하지 않는다. &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;로 만든 x에 x + 1이라는 새로운 값을 집어넣으면 다음처럼 x는 변경 불가능한 값(immutable value)이라는 오류가 발생한다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; val x = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; x = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;console&amp;gt;:7: error: assignment to immutable value&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;       x = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;val의 사용&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라에는 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var/val&lt;/span&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt; 외에도 함수 객체를 선언하는 데 사용하는 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt; 키워드가 있다. &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;는 다음처럼 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;과 마찬가지로 변하지 않는 값을 선언하는 데 사용할 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; def x = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; x = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;console&amp;gt;:7: error: value x_= is not a member of object $iw&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;       x = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;       ^&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;def의 사용&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;과 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;의 차이는 연산을 하는 시점에 있다. &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;은 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;val&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;을 선언하는 시점에 우변을 계산해서 값을 할당하는 반면에 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;는 실제로 사용되는 시점마다 우변을 새로 계산한다. 다음 예제는 이 차이를 분명하게 보여준다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; var x = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int = 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; val y = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;y: Int = 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; def z = x + 1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;z: Int&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; z&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;res13: Int = 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; x = 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;x: Int = 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;res15: Int = 2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;scala&amp;gt; z&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;res16: Int = 3&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;var과 def의 차이&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;위 예제에서 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;var&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;로 선언한 변수 x에 1을 넣은 다음에 y와 z 모두 x + 1로 정의해주었다. 다만 y는 val을 z는 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;를 사용해서 선언하였다. 일단 val y는 선언하는 순간에 값이 2임을 표시해준 반면에 def z를 선언했을 때는 타입이 Int라는 사실만 알려주고 값을 계산하지 않았음을 알 수 있다. z를 실제로 사용했을 때 2로 계산해준다. 이후 변수 x의 값을 2로 변경했을 때, y는 이미 선언한 시점에서 계산이 끝났으므로 값이 변경되지 않고 여전히 2인 반면에 z는 다시 x + 1을 이 시점에서 새로 계산하기 때문에 x 값을 2로 계산해서 3을 돌려줌을 볼 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;클래스&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라의 클래스는 기본적으로 자바와 유사하다. 다만 별도의 생성자 없이 클래스 이름 옆에 객체 생성 시 어떤 인자를 받을 것인지 써준다는 차이가 있다. 아래 Person 클래스는 성과 이름을 입력받는 간단한 클래스이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;class Person(fname: String, lname: String) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def firstname() = fname&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def lastname() = lname&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    override def toString() = firstname() + &quot; &quot; + lastname()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 클래스의 예&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;toString 메서드는 java.lang.Object의 toString 메서드를 오버라이드(override)한 것이다. 스칼라는 상위 클래스의 메서드를 오버라이드할 때 명시적으로 &lt;/span&gt;&lt;span style=&quot;font-style: italic;&quot; lang=&quot;EN-US&quot;&gt;override&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;라는 키워드를 써줘야 한다. 실수로 상위 클래스의 메서드를 의도치 않게 오버라이드하는 것을 막기 위한 조치이다. &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;케이스 클래스(case class)와 패턴 매칭(pattern matching)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;패턴 매칭은 함수 언어의 고유한 특징 중에 하나로 함수 언어를 강력하게 만들어주는 핵심이다. 스칼라는 케이스 클래스를 통해 객체지향 언어 속에 패턴 매칭을 녹여 넣었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;abstract class Shape&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;case class Rectangle(width: Double, height: Double) extends Shape&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;case class Circle(radius: Double) extends Shape&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;case class Square(side: Double) extends Shape&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;케이스 클래스의 예&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;케이스 클래스는 일반 클래스와 달리 다음과 같은 몇 가지 특징을 갖는다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;(1) 새로운 객체를 생성하기 위해 new 키워드를 사용할 필요가 없다. new Circle(5.0) 대신에 Circle(5.0)이라고 사용할 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;(2) 생성자의 파라미터에 사용된 값을 얻을 수 있는 getter 메서드가 자동으로 생성된다. 예를 들어 var c = Circle(5.0)를 선언했다면 c.radius는 5.0을 리턴한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;(3) equals와 hashCode 메서드가 자동으로 만들어진다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;(4) toString 메서드가 자동으로 정의된다. Rectangle(5.0, 3.0)을 출력해보면 &quot;Rectangle(5.0, 3.0)&quot;이 나온다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;(5) 패턴 매칭을 통해 분해(decompose)될 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;케이스 클래스의 최대 장점은 (5)에서 언급한 패턴 매칭의 사용이다. 다음은 패턴 매칭을 사용한 면적(area) 계산 함수이다. &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;def area(s: Shape): Double = s match {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Rectangle(width, height) =&amp;gt; width * height&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Circle(radius) =&amp;gt; radius * radius * 3.14&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Square(side) =&amp;gt; side * side&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case _ =&amp;gt; 0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;def perimeter(s: Shape): Double = s match {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Rectangle(width, height) =&amp;gt; 2 * (width + height)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Circle(radius) =&amp;gt; 2 * 3.14 * radius&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case Square(side) =&amp;gt; side * 4&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    case _ =&amp;gt; 0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;패턴 매칭을 통한 Shape의 면적/둘레 계산&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;area(면적)와 perimeter(둘레) 함수는 Shape의 객체 s를 넘겨받아 패턴 매칭을 한다. s의 객체가 Rectangle, Circle, Square일 때 각각의 케이스에 대해 어떤 일을 수행할 것인지 적어주면 된다. 이때 각 객체를 만들 때 사용되었던 인자가 원하는 변수에 자동으로 매칭된다. 예를 들어, Rectangle(5.0, 3.0)을 s로 넘겼다면 첫 번째 케이스에서 width와 height는 각각 5.0, 3.0이 된다. _는 앞선 패턴 매칭이 모두 실패했을 때 디폴트로 호출되는 케이스를 의미한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;객체지향 프로그래밍에 익숙한 개발자라면 area를 Shape의 메서드로 선언하고, Rectangle, Circle, Square 등 각각의 서브클래스가 area를 구현하는 방식으로 코드를 작성할 수도 있을 것이다. area나 perimeter 같은 메서드는 몇 개로 고정되어 있고, Triangle이나 Ellipse 등 새로운 Shape이 계속 추가되는 상황이라는 이 방법이 더 좋다. 새로 추가되는 Shape에서 area와 perimeter 등 몇 개의 메서드만 구현해주면 되고 기존 파일을 고칠 필요가 없기 때문이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;반대로 Shape의 종류는 고정된 상황에서 area, perimeter 등의 메서드를 계속 추가해 나가야 되면 상황이 달라진다. 메서드가 하나 추가될 때마다 모든 Shape의 서브클래스를 찾아서 메서드를 추가해줘야 하기 때문이다. 자바를 비롯한 전통적인 객체지향 언어에서는 이 문제를 비지터 패턴(visitor pattern)을 이용한 더블 디스패치(double dispatch)로 풀었다. 하지만 비지터 패턴은 이해하기도 어렵고, 싱글 디스패치하는 일반적인 객체지향 언어에서 자연스러운 접근 방법도 아니다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;패턴 매칭은 이런 상황에서 완벽한 솔루션을 제공한다. 새로운 함수/메서드를 만들고 패턴 매칭을 통해 각각의 케이스를 다루면 되기 때문이다. 케이스 클래스라고 이름 붙인 이유는 이처럼 패턴 매칭을 통해 각 케이스를 다룬다는 면을 강조한 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;제네리시티(Genericity)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;마지막으로 살펴볼 내용은 자바 제네릭스에 대응하는 제네리시티이다. 스칼라의 제네리시티는 자바보다 문법적으로 훨씬 간결하고 직관적이다. 이해를 위해 스칼라 튜토리얼에 있는 예제 코드를 하나 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;class Reference[a] {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    private var contents: a = _&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def set(value: a) { contents = value }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    def get: a = contents&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;제네리시티&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;아무 타입이나 저장할 수 있는 Reference 클래스를 만들기 위해서 [a]라는 타입 파라미터를 받았다. Reference의 contents 필드를 타입 a로 선언했고, get의 리턴 타입과 set의 value 타입을 a로 선언했다. 실제로 사용할 때는 val cell = new Reference[Int] 형태로 타입을 넘겨주면 된다. 참고로, 스칼라는 기본 타입과 레퍼런스 타입의 구분이 없기 때문에 Int를 넣기 위해 Integer 객체를 만들어 박싱할 필요가 없다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 다른 함수 언어와 달리 JVM 위에서 동작하는 언어라는 이점 때문에 상당히 실용적이다. 특히 이미 기존 자바 개발자들에게 스칼라는 기존 프로젝트 플랫폼을 변경하지 않고 필요한 부분에서 생산성을 높일 수 있는 중요한 도구가 될 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라 컴파일러와 런타임의 버전은 2.7.0으로 상당히 안정되어 있고, 지금은 스칼라를 기반으로 한 라이브러리와 프레임워크도 출연하기 시작했다. Lift는 스칼라를 이용한 웹 프레임워크이고, Scalax, Scalaz 프로젝트 등은 스칼라 라이브러리이다. 또한 멀티 코어 시대를 대비한 병렬 프로그래밍(얼랭(Erlang)과 유사한 프로세스 모델을 제공) 또한 스칼라가 자랑하는 기능 중 하나이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;짧은 지면에 새로운 프로그래밍 언어를 처음부터 소개하려다보니 응용 부분에서 많은 내용이 빠졌다. 보다 자세한 내용은 스칼라 홈페이지(http://www.scala-lang.org/)를 통해 얻길 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px dashed rgb(243, 197, 52); padding: 10px; background-color: rgb(254, 254, 184);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Scalax, Scalaz&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라는 JDK에 있는 클래스들을 쉽게 사용할 수 있지만, 한편으로는 스칼라 프로그래밍 언어 자체의 특징을 살리기 위한 라이브러리의 개발도 한참이다. 대표적으로 Scalax와 Scalaz 프로젝트가 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;일례로 Scalaz는 ScalaCheck이라는 테스팅 프레임워크를 제공한다. 물론 스칼라도 자바 테스팅 프레임워크인 JUnit을 사용할 수 있지만, ScalaCheck은 JUnit과 달리 함수 언어의 특징을 살려 명세 기반의 자동화된 테스팅을 제공한다. 이는 헤스켈의 QuickCheck과 유사하다. 또한 Scalaz는 함수 언어의 특징을 살리고자 모나드(monad) 관련 패키지도 제공한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;스칼라의 장점을 잘 살린 함수형 프로그래밍을 하고 싶다면 이런 라이브러리 프로젝트가 중요한 학습 소스가 될 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;참고문헌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[1] A Scala Tutorial for Java Programmers&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://www.scala-lang.org/docu/files/ScalaTutorial.pdf&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.scala-lang.org/docu/files/ScalaTutorial.pdf&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[2] Scala by Example&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://www.scala-lang.org/docu/files/ScalaByExample.pdf&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.scala-lang.org/docu/files/ScalaByExample.pdf&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[3] An Overview of the Scala Programming Language&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://www.scala-lang.org/docu/files/ScalaOverview.pdf&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.scala-lang.org/docu/files/ScalaOverview.pdf&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[4] The Scala Language Specification Version 2.7&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://www.scala-lang.org/docu/files/ScalaReference.pdf&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.scala-lang.org/docu/files/ScalaReference.pdf&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>Scala</category>
			<category>스칼라</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/335</guid>
			<comments>http://skyul.tistory.com/335#entry335comment</comments>
			<pubDate>Mon, 01 Dec 2008 00:19:29 +0900</pubDate>
		</item>
		<item>
			<title>자바 컴파일러 들여다보기</title>
			<link>http://skyul.tistory.com/334</link>
			<description>&lt;p class=&quot;전체 제목&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;마이크로소프트웨어 2006년 7월 기고글입니다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;전체 제목&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
자바 개발자라면 누구나 자바 컴파일러(javac)를 사용한다. 하지만 상당수 개발자는 컴파일러가 어떻게 동작하는지 관심이 없다. 이들은 작성한 소스 코드가 오류 없이 컴파일되고 컴파일의 결과로 나온 클래스 파일이 원하는 기능을 수행하면 그만이라고 말한다. 하지만 컴파일러 작성자가 아니더라도 컴파일러가 소스 코드를 어떤 형태의 바이너리(자바의 경우 바이트코드)로 변환시키는지 알아두면 유용한 경우가 많다. 이 글에서는 몇 가지 예제를 중심으로 자바 컴파일러의 내부 동작을 엿보는 기회를 가지려고 한다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;T 업계의 종사하는 사람이라면 18개월마다 컴퓨팅 파워가 2배가 된다는 무어(Moore)의 법칙을 잘 알고 있을 것이다. 컴파일러에도 이와 비슷한 법칙이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 4&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(243, 197, 52); padding: 10px; background-color: rgb(254, 254, 184);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;제목 4&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Proebsting&#039;s Law&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 4&quot;&gt;&lt;span style=&quot;font-family: 한양견고딕;&quot;&gt;컴파일러 기술은 18년마다 컴퓨팅 파워(computing power)를 2배로 증가시킨다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;제목 4&quot;&gt;&lt;span style=&quot;font-family: 한양견고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 4&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 법칙이 정확한 예측치는 아니더라도 비약적으로 발전하는 하드웨어에 비해 컴파일러의 발전 속도가 상당히 더디다는 것만은 유추할 수 있다. 하지만 그렇다고 마냥 정체되어 있기만 한 것은 아니었다. 50-60년대에 최초의 컴파일러가 나오고 벌써 수십 년이 지났으므로, 지금 우리가 사용하는 컴파일러는 초창기에 비해 상당히 발전한 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;따라서 개발자도 컴파일러를 블랙박스로만 생각할 것이 아니라, 어떤 일을 해주는지 조금은 알아둘 필요가 있다. 컴파일러가 변환하는 소스 코드와 바이너리의 관계를 코드 모양(code shape)이라고 하는데, 최적화 컴파일러의 복잡한 변환(transformation) 과정은 아니더라도, 이런 코드 모양을 몇 가지 숙지하고 있으면 좋다. 이 글에서는 자바의 표준 컴파일러인 javac을 통해 자바 언어와 바이트코드에 대한 이해의 폭을 넓혀 보려고 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;데드 코드(dead code)와 조건부 컴파일&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;C/C++ 개발자들이 자바 개발을 시작하면 가장 먼저 느끼는 불편함 중에 하나가 전처리기(preprocessor)의 부재일 것이다. C/C++에서는 #ifdef #endif를 이용해서 특정 코드를 선택적으로 컴파일할 수 있는데, 자바는 그런 전처리기가 없기 때문이다. 하지만 자바 컴파일러를 잘 이용하면 자바에서도 조건부 컴파일이 가능하다. 우선 자바 컴파일러의 배경 지식부터 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;컴파일러는 바이너리를 생성하기에 앞서서 실행 흐름 분석(control flow analysis)을 통해 소스 프로그램을 분석하는데, 이 분석을 통해 하는 일 중에 하나가 데드 코드 제거(dead code elimination)이다. 자바 컴파일러도 프로그램 흐름상 절대로 수행될 수 없는 코드를 발견하면 이 부분은 바이트코드에 포함시키지 않는다. 다음 예제를 보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
  &lt;!--[if !supportEmptyParas]--&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Foo {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static void main(String args[]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                if (false) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                        System.out.println(&quot;Never&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;데드 코드 예제&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;제목 2&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(243, 197, 52); padding: 10px; background-color: rgb(254, 254, 184);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 2&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;자바 디컴파일러 javap&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;font-family: 한양신명조;&quot;&gt;자바 개발 환경을 설치하면 javac, java와 함께 몇 가지 프로그램이 함께 설치되는데, 그 중 하나가 자바 디컴파일러인 javap이다. javap는 클래스 파일을 읽어서 클래스와 메쏘드, 그리고 각 메쏘드의 바이트코드를 보여주는 프로그램이다. 특히 자바 네이티브 인터페이스(Java Native Interface, JNI) 작성 시에 메쏘드 시그너처(signature)를 뽑아내는데 유용한 도구이다. -c 옵션을 주면 각 메쏘드의 바이트코드도 볼 수 있는데, 이 글의 디컴파일 결과는 모두 javap -c를 사용한 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;font-family: 한양신명조;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 코드에서 if (false) System.out.println(&quot;Never&quot;)은 수행될 수 없는 코드이다. 따라서 바이트코드에 포함되지 않는데, 자바 디스어셈블러인 javap를 이용해 Foo.class를 살펴보면 main 메쏘드에 return 문만 있는 것을 볼 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static void main(java.lang.String[]);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   return&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt; &lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;데드 코드 Foo의 디컴파일&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;물론 if (false)의 경우는 너무 당연해서 별로 쓸모가 있어 보이지 않는다. 하지만 자바 컴파일러가 데드 코드를 바이트코드에 포함시키지 않는다는 사실을 이용하면 C/C++ 전처리기리처럼 조건부 컴파일을 흉내 낼 수 있다. 다음 예제를 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class Configure {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final boolean debug = false;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Foo {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static void main(String args[]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    if (Configure.debug) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                        System.out.println(&quot;Debug.&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;조건부 컴파일 예제&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;[debug가 static final인 경우]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static void main(java.lang.String[]);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   3:   ldc     #3; //String Debug.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   8:   return&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;조건부 컴파일 디컴파일&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;자바에서 static final로 선언된 필드는 상수(constant)이다. 따라서 위 조건부 컴파일 예제의 경우 Configure.debug라는 플래그가 false이면 main 메쏘드의 if (Configure.debug) 부분이 데드 코드가 되므로 바이트코드에 포함되지 않는다. 반대로 debug를 true로 바꿔주면, if (Configure.debug) 부분 코드가 컴파일되는데, debug는 static final로 선언되어 있으므로 항상 참이다. 따라서 javac은 if 문을 없애고 바로 System.out.println을 실행하도록 코드를 생성한다. 즉 flag를 true/false로 바꿔준 후에 새로 컴파일하면 조건부 컴파일이 되는 것이다. &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;[debug가 final이 아닌 경우]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static void main(java.lang.String[]);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   getstatic       #2; //Field Configure.debug:Z&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   3:   ifeq    14&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   6:   getstatic       #3; //Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   9:   ldc     #4; //String Debug.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   11:  invokevirtual   #5; //Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   14:  return&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;final이 아닌 경우 디컴파일&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;만약에 debug가 final이 아니었다면 런타임에 값이 바뀔 수 있으므로, [debug가 false가 아닌 경우]의 3행에서처럼 ifeq로 debug 값을 테스트하는 부분이 들어갔을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;배열 초기화(array initialization)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;C/C++ 프로그램을 개발할 때 바이너리 데이터를 메모리에 읽어오는 방법으로 배열 초기화를 사용하는 경우가 많다. 특히 바이너리 외에 별도의 파일 시스템이 없는 임베디드 시스템의 경우 어플리케이션의 그림(image)나 소리(sound) 데이터를 char[]에 저장한다. 로더(loader)가 프로그램을 로드할 때 배열의 값을 메모리의 데이터 영역으로 바로 복사해주기 때문에 효율적이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;다음은 썬(Sun)에서 만든 J2ME의 Personal Basic Profile 소스 코드에서 발췌한 코드이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class IxcClassLoader extends ClassLoader {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    /* fields */&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;    private static byte[] utilsClassBody = {  //            The .class file&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0xca, (byte) 0xfe, (byte) 0xba, (byte) 0xbe,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x2e,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x3d, (byte) 0x0a, (byte) 0x00,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x11, (byte) 0x00, (byte) 0x1f, (byte) 0x07,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x20, (byte) 0x07, (byte) 0x00,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x21, (byte) 0x0a, (byte) 0x00, (byte) 0x03,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x22, (byte) 0x0a, (byte) 0x00,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x02, (byte) 0x00, (byte) 0x23, (byte) 0x0a,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x02, (byte) 0x00, (byte) 0x24,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x07, (byte) 0x00, (byte) 0x25, (byte) 0x07,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x00, (byte) 0x26, (byte) 0x07, (byte) 0x00,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;            (byte) 0x27, (byte) 0x0a, (byte) 0x00, (byte) 0x08,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt; ...&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;PBP의 IxcClassLoader 클래스&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 코드를 보면 utilsClassBody라는 byte[] 필드에 클래스 생성에 필요한 유틸리티 클래스의 바이트코드를 바이너리 형태로 넣어 놨음을 알 수 있다. static 필드이므로 클래스 정적 초기화(static initialization)시에 해당 필드가 초기화될 것이다. C/C++ 코드를 많이 작성해온 개발자라면 이런 형식의 배열 사용법에 익숙할 것이다. 자바에서 이런 배열 초기화의 문제점은 무엇일까? 대답에 앞서서 이 클래스를 한 번 디컴파일해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;static {};&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   sipush  1165&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   3:   newarray byte&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   5:   dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   6:   iconst_0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   7:   bipush  -54&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   9:   bastore&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   10:  dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   11:  iconst_1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   12:  bipush  -2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   14:  bastore&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   15:  dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   16:  iconst_2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   17:  bipush  -70&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   19:  bastore&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   20:  dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   21:  iconst_3&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   22:  bipush  -66&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   24:  bastore&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   25:  dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   26:  iconst_4&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   27:  iconst_0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   28:  bastore&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   29:  dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   ...&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;PBP의 IxcClassLoader 클래스 디컴파일&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;무엇이 문제인지 감이 잡히는가? 지면 관계상 일부만 표시했지만, byte[] utilsClassBody는 길이가 1165이다. C/C++이였으면 이 데이터를 곧바로 메모리에 로드하였겠지만, 자바의 클래스 로더는 그렇지 않다. 자바의 경우 클래스를 초기화할 때 1165 길이의 byte[]를 힙에 생성하고 각 원소를 하나하나 초기화해주어야 한다. 이 초기화를 위해서 무려 7738개의 바이트코드가 필요하다. 코드 길이도 문제지만, 클래스 로딩 시간 또한 무척 길어진다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;자바의 원산지인 썬에서 배포하는 코드에서 이런 문제점이 있다는 점을 생각해보면 언뜻 비슷해 보이는 두 언어의 차이점을 정확히 알고 쓰는 일이 쉽지 않음을 알 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;문자열 처리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;자바는 문자열의 편리한 처리를 위해서 문자열 병합 연산자(+)를 제공한다. 따라서 우리는 &quot;Hello&quot; + &quot;World&quot;와 같이 문자열을 병합할 수 있고, &quot;I am &quot; + name + &quot;.&quot;과 같이 중간에 변수를 삽입해서 문자열을 생성할 수도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;하지만 자바의 String 클래스는 변경 불가능(immutable)한 클래스이다. 따라서 한 번 문자열을 생성하면 문자열의 값을 바꾸는 것은 불가능하다. 따라서 replace, replaceAll, toLowerCase 등의 메쏘드는 모두 기존의 문자열은 그대로 두고 새로운 문자열을 리턴한다. java.lang.String의 API를 유심히 읽어본 개발자라면 정답을 알고 있을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(243, 197, 52); padding: 10px; background-color: rgb(254, 254, 184);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;◆ java.lang.String API에서 발췌&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;문자열 병합은 StringBuilder(혹은 StringBuffer) 클래스의 append 메쏘드를 통해 이루어진다. 추가적인 정보를 위해서는 자바 언어 명세서(Java Language Specification)을 참조하기 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;즉 우리가 String a = &quot;Hello&quot;; a += &quot; World&quot;; 라고 프로그램을 작성하더라도 실제 병합은 StringBuilder 클래스를 통해 이루어짐을 의미한다. 역시 실제 프로그램을 컴파일해서 확인해보도록 하자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Foo {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static void main(String args[]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                String h = &quot;Hello&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                h += &quot;World&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static void main(java.lang.String[]);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   ldc     #2; //String Hello&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   2:   astore_1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   3:   new     #3; //class java/lang/StringBuilder&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   6:   dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   7:   invokespecial   #4; //Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   10:  aload_1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   11:  invokevirtual   #5; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   14:  ldc     #6; //String World&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   16:  invokevirtual   #5; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   19:  invokevirtual   #7; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   22:  astore_1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   23:  return&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;String 병합&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;바이트코드를 잘 모르더라도 String 대신에 StringBuilder 클래스를 통해 문자열을 병합하고 이후에 toString 메쏘드를 이용해 문자열을 돌려줌을 쉽게 유추해 볼 수 있다. 이처럼 javac은 자바 개발자가 알게 모르게 여러 가지 일을 해주고 있는데, 바꿔 말하면 자바 개발자는 의도하지 않게 비효율적인 명령을 실행할 수도 있다는 뜻이다. 실제로 초창기 자바는 멀티 쓰레드 세이프한 StringBuffer의 append 메쏘드를 이용했는데, append는 매번 락을 잡았다 풀었다 하였기 때문에 심각한 속도 저하의 원인이 되기도 했었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Inner Class&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이너 클래스가 있는 클래스를 컴파일하면, $ 표시가 붙은 클래스 파일이 생성되는 것을 보았을 것이다. 그리고 JVM 명세서를 잘 읽어보면 이너 클래스라는 게 존재하지 않는다는 사실도 알 수 있을 것이다. 그렇다면 다음과 같이 이너 클래스가 있는 클래스를 컴파일하면 어떤 일이 생기는 걸까?&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Foo {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        static class Bar {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                private boolean flag = true;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%; font-weight: bold;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%; font-weight: bold;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static void main(String args[]) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                Bar bar = new Bar();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;                System.out.println(bar.flag);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%; font-weight: bold;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Inner Class&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 예제의 경우 Foo 내부에 Bar라는 정적 이너 클래스를 선언하였다. Bar는 Foo의 이너 클래스이므로 private 멤버라도 직접 접근이 가능하다. 이 클래스를 컴파일하면 Foo.class와 Foo$Bar.class라는 두 개의 클래스 파일이 나타난다. JVM에는 이너 클래스의 개념이 없으므로, 자바 소스 코드 상에서는 Bar는 Foo의 이너 클래스이지만 바이트코드 상에서는 별도의 클래스가 되는 것이다. &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Foo extends java.lang.Object{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    public Foo();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    public static void main(java.lang.String[]);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;class Foo$Bar extends java.lang.Object{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    Foo$Bar();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    static boolean access$000(Foo$Bar);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Inner Class 디컴파일&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;또 하나 특이한 점으로는 access$000라는 메쏘드가 있다. 원래 Bar 클래스에는 없는 메쏘드인데 어째서 바이트코드에는 나타난 것일까? 그 이유는 자바 소스 코드에서는 Bar가 이너 클래스이므로 Foo의 main 메쏘드에서 Bar의 private field가 접근 가능해야 하는데, 실제 바이트코드 상에서는 별도의 클래스이므로, private 멤버의 값을 읽을 수 없게 된다. 이 문제를 해결하기 위해 자바 컴파일러는 access$000이라는 메쏘드를 생성해 Foo가 Bar의 필드 참조 시 access$000으로 대체하게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Enumeration&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;Java 5에는 타입 세이프 enum 강화된 for 루프, 제네릭스(generics), 오토박싱(autoboxing), 언박싱(unboxing), 가변인자(varargs), 정적 임포트(static import), 메타데이터(metadata) 등 여러 가지 언어 기능이 추가 되었다. 하지만 언어만 바뀌었을 뿐 기존의 JVM이 사용하던 바이트코드에는 차이가 없다. 이 말은 결국 이런 기능들은 전부 컴파일러가 해준다는 뜻이다. 타입 세이프 enum을 통해서 컴파일러가 어떤 바이트코드를 생성해 내는지 살펴보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public enum Week {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        MON, TUE, WED, THU, FRI, SAT, SUN&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Week Enum&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;위 Week enum은 월요일부터 일요일까지 각각의 요일을 나타낸다. enum이 없던 시절에는 어떻게 구현했을까? 한 가지 방법은 int 상수를 이용하는 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Week {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int MON = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int TUE = 1;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int WED = 2;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int THU = 3;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int FRI = 4;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int SAT = 5;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final int SUN = 6;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt; &lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;int 상수를 이용한 Week Class&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 방법도 동작에는 전혀 문제가 없지만, MON, TUE, WED 같은 값들이 int이기 때문에 MON * 2 같이 의미 없는 연산을 하더라도 컴파일 타임에 타입 에러를 발견할 수 없었다. 이런 문제를 해결하기 위해 타입 세이프 enum 패턴이 널리 쓰였다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public class Week {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week MON = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week TUE = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week WED = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week THU = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week FRI = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week SAT = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        public static final Week SUN = new Week();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;타입 세이프 enum 패턴&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 방식은 타입 세이프하지만 각 필드가 오브젝트이므로 int를 사용한 방식과는 달리 switch 문에 사용이 불가능하다는 불편함이 있었다. 반면에 Java5에 도입된 타입 세이프 enum은 타입 세이프하면서 switch 문에서도 사용이 가능하다. 어떻게 구현한 것일까? Week enum을 디컴파일해보자.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public final class Week extends java.lang.Enum{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week MON;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week TUE;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week WED;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week THU;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week FRI;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week SAT;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;public static final Week SUN;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;static {};&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;  Code:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   0:   new     #4; //class Week&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   3:   dup&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   4:   ldc     #7; //String MON&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   6:   iconst_0&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   7:   invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   10:  putstatic       #9; //Field MON:LWeek;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;   ...&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p class=&quot;본문중고&quot;&gt;&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;타입 세이프 enum 패턴&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문중고&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양중고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;우리가 간단히 enum Week { MON, TUE, ... }로 써줬지만 실제로 컴파일하면 타입 세이프 enum 패턴처럼 각각이 public final static Week 필드로 들어가 있음을 알 수 있다. 즉 우리가 타입 세이프 enum 패턴에서 수동으로 구현해주던 것을 컴파일러가 대신해 주는 것이다. 클래스 초기화인 static{} 에서는 Week의 객체를 생성해서 각 필드를 초기화해주고 있다. 객체를 생성할 때 MON은 0, TUE는 1, WED는 2 하는 식으로 값을 주고, switch 문에서는 이 값을 얻어오는 ordinal() 메쏘드를 호출하여 switch 문에서도 사용할 수 있게 해준다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;지금까지 자바 컴파일러(javac)가 해주는 몇 가지 일을 살펴보았다. 특히 자바 소스 코드의 특정 구문이 어떤 바이트코드로 변환되는지를 위주로 보았다. 우리는 javap를 이용해 결과를 살펴보았지만, JVM 지식이 있고 자바 언어 명세서를 꼼꼼히 읽은 개발자라면 이미 알고 있었을 내용일지도 모르겠다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;자바 개발자를 만나서 이야기해보면 깜짝 놀라는 일 중에 하나는, 자바의 가장 근간이 되는 자바 언어 명세서(Java Language Specification)와 자바 가상 머신(Java Virtual Machine) 명세서를 숙독한 개발자가 거의 없다는 점이다. 자바 튜토리얼(tutorial)이나 여러 자바 입문서로 시작하여 단 한 번도 명세서를 보지 않고 지금까지 프로그램을 작성해 온 개발자가 부지기수다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;모든 자바 컴파일러, 자바 가상 머신은 모두 이 명세서를 기준으로 만들어졌다. 썬에서 배포하는 레퍼런스 구현(reference implementation)도 결국 이 명세서를 바탕으로 만든 구현 중 하나에 지나지 않는다. 즉 자바 언어 명세서는 자바 세상의 성경인 셈이다. 명세서를 바탕으로 자바의 문법과 의미를 분명히 명확히 이해하고, 자바 코드가 어떤 바이트코드로 변환되는지를 숙지하는 것은 고급 개발자가 되기 위해 반드시 필요한 일이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 과정에서 디컴파일러를 이용해 의문을 해소하는 일은 무척 유용하다. 앞서 언급하지는 않았지만 try, finally 구문은 바이트코드로 어떻게 표현되는지, synchronized 블록은 바이트코드로 어떻게  변환되는지 등을 살펴보면 자바 언어와 JVM에 대한 이해를 넓힐 수 있다. 자바의 경우 컴파일러에 대한 지식은 결국 언어 지식을 넓히는 길인 셈이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;참고문헌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;[1] Java Language Specification, Third Edition Gosling, Joy, Steele, Bracha Addison Wesley 2005&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;[2] Java Virtual Machine Specification, Second Eidtion Lindholm, Yellin, Addison-Wesley 1999&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 한양신명조;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;박스&quot;&gt;&lt;span style=&quot;font-family: 한양신명조;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot; style=&quot;line-height: 130%;&quot;&gt;&lt;span style=&quot;font-family: Courier New; font-size: 8pt;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;</description>
			<category>자바 컴파일러</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/334</guid>
			<comments>http://skyul.tistory.com/334#entry334comment</comments>
			<pubDate>Sun, 30 Nov 2008 02:12:30 +0900</pubDate>
		</item>
		<item>
			<title>코드 난독화(Code Obfuscation)</title>
			<link>http://skyul.tistory.com/333</link>
			<description>&lt;br /&gt;
마이크로소프트웨어 2007년 12월에 기고한 글입니다.&lt;br /&gt;
&lt;br /&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;요즘 보안 취약점 분석자들은 각종 보안 문제 분석에 역공학(reverse engineering) 기술을 적극 활용하고 있다. 역공학은 소스 코드 없이 윈도우즈 실행 파일(PE, Portable Executable)이나, 자바 바이트코드 등을 직접 분석해서 프로그램이 어떤 기능을 수행하는지 파악하여 취약점을 찾아내는 기술이다, 필요하면 직접 프로그램 바이너리를 수정해 불법적인 일을 수행하게 만들기도 한다. 이에 대한 대응으로 코드를 복잡하게 만들어 알아보기 힘들게 하는 코드 난독화(code obfuscation) 기술이 발전하였다. 이 글에서는 코드 난독화의 기본 원리를 알아보자.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;역공학(reverse engineering)이란?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;div class=&quot;imageblock&quot; style=&quot;display:inline;&quot;&gt;&lt;a href=&quot;http://cfs13.tistory.com/original/4/tistory/2008/11/30/01/01/4931675f2b7c7&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs13.tistory.com/image/4/tistory/2008/11/30/01/01/4931675f2b7c7&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;reverse_engineering.png&quot; height=&quot;340&quot; width=&quot;390&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 바탕;&quot;&gt;역공학의 개념&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 바탕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;대부분의 개발자들은 컴파일된 바이너리를 완전한 블랙박스로 취급한다. 윈도의 PE 포맷이나 리눅스의 ELF 포맷을 이해하더라도 코드섹션(code section)에 들어있는 기계어(어셈블리어)를 이해하기란 무척 어렵다. 하지만 보안 취약점 분석가들의 주요 업무는 이런 바이너리 코드를 읽고 보안 취약점을 찾아내는 것이다. 이는 보안 전문가들이라 할지라도 쉽지 않은 일인데, 보통 컴파일된 바이너리를 다시 원래의 소스코드로 복구하는 프로그램인 디컴파일러(decompiler)의 도움을 받는다. 디컴파일러는 원래 소스 코드를 완벽히 복구하지는 못하지만, 어셈블리에 비해서는 훨씬 이해하기 쉬운 프로그래밍 언어(주로 C)의 소스 코드를 생성해준다. 또한 코드 섹션에 직접 브레이크를 걸고 실행시켜볼 수 있는 디버거(debugger)의 도움을 받는 경우도 많다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이처럼 바이너리 코드를 분석해 유용한 정보를 뽑아내는 작업을 역공학(reverse engineering)이라 부른다. 최근 보안 취약점 분석의 상당 부분은 역공학과 관련되어 있다. 실제로 역공학은 윈도우처럼 소스 코드가 공개되지 않은 운영체제나, 어플리케이션의 보안 버그를 찾아내는데 적극적으로 활용되고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;역공학의 위험성을 보여주는 예로, 각종 보안 프로그램들이 뚫린 사례를 들 수 있다. 예를 들어 도서관 같은 공용 컴퓨터에 불법적인 프로그램을 설치하는 것을 막기 위해 리부팅하면 하드가 리셋(reset)되는 시스템이 있다. 이 시스템은 추가적은 프로그램 설치를 위해 관리자 모드를 제공하는데, 4자리의 패스워드를 입력하도록 되어있다. 역공학을 이용해 패스워드를 검사하는 루틴을 찾아내면, 이 부분을 건너뛰게 만들 수도 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;수십 가지의 안전장치를 마련한 인터넷 뱅킹도 예외가 아니다. 안전한 공인 인증서를 이용한다고 해도, 입력받은 비밀번호와 공인인증서 비밀번호를 비교하는 코드를 찾아내서 해당 루틴을 건너뛰게 만든다면 공인인증서의 비밀번호(passphrase)는 의미가 없어진다. 아무리 많은 안전장치를 걸어놔도 윈도 머신에서 실행되는 바이너리라면, 그 내용을 분석해 해당 코드를 제거해 버리면 되기 때문이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;현재 MS 윈도의 보안 모델에서는 이런 역공학에 의한 공격에 효과적인 대응책이 없다. 그나마 우리가 할 수 있는 차선책은 바이너리를 분석하기 어렵도록 복잡하게 만들어 주는 것이다. 코드 난독화의 필요성은 여기서 출발한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;코드 난독화(code obfuscation)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;코드 난독화는 프로그램을 변화하는 방법의 일종으로, 코드를 읽기 어렵게 만들어 역공학을 통한 공격을 막는 기술을 의미한다. 난독화는 난독화의 대상에 따라 크게 1) 소스 코드 난독화와 2) 바이너리 난독화로 나눌 수 있다. 소스 코드 난독화는 C/C++/자바 등의 프로그램의 소스 코드를 알아보기 힘든 형태로 바꾸는 기술이고, 바이너리 난독화는 컴파일 후에 생성된 바이너리를 역공학을 통해 분석하기 힘들게 변조하는 기술이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;일단 소스 코드 난독화의 필요성을 먼저 이야기해보자. 첫 번째 경우는 부득이하게 소스 코드를 릴리즈(release)해야 하는 경우이다. 예를 들어 플래시 파일 시스템을 파는 A라는 회사가 있다고 하자. B 회사는 A 회사의 라이브러리를 구매해서 제품을 만들려고 한다. B 회사는 매우 많은 플랫폼을 가지고 있고, 여러 설정에 따라서 플래시 파일 시스템을 조금씩 다르게 컴파일해야할 필요가 있다고 하자. 이 경우 B 사가 일일이 해당 라이브러리를 빌드해서 릴리즈해주는 방법도 있지만, 난독화 도구를 이용해 코드를 적당히 알아보기 힘들게 만든 후에 A 사에 넘겨서 A사가 직접 빌드하도록 하는 것이 편리할 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;또 다른 예로 최근 부각 받는 AJAX의 경우, 자바스크립트(JavaScript)로 작성된 코드가 브라우저에 그대로 노출되는 문제가 있다. 소스 코드를 공개하고 싶지 않은 개발자라면 AJAX의 이런 특성이 큰 부담이 될 것이다. 이 경우 자바스크립트 코드를 쉽게 알아보지 못하도록 난독화 도구를 사용할 수 있다. 다음은 JavaScript Obfuscator가 실제로 자바 스크립트를 난독화한 예제이다. 원래 코드와 난독화된 코드를 비교해보면, 난독화 과정에 대한 감을 잡을 수 있을 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;원래 코드&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;//detect which browser is used&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;var detect = navigator.userAgent.toLowerCase();&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;var OS,browser,version,total,thestring;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;if (checkIt(&#039;konqueror&#039;))&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    browser = &quot;Konqueror&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    OS = &quot;Linux&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;else if (checkIt(&#039;opera&#039;)) browser = &quot;Opera&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;else if (checkIt(&#039;msie&#039;)) browser = &quot;Internet Explorer&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;else if (!checkIt(&#039;compatible&#039;))&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    browser = &quot;Netscape Navigator&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    version = detect.charAt(8);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;else browser = &quot;An unknown browser&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;//version of browser&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;if (!version) version = detect.charAt(place + thestring.length);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;//client OS&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;if (!OS)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    if (checkIt(&#039;linux&#039;)) OS = &quot;Linux&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    else if (checkIt(&#039;x11&#039;)) OS = &quot;Unix&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    else if (checkIt(&#039;mac&#039;)) OS = &quot;Mac&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    else if (checkIt(&#039;win&#039;)) OS = &quot;Windows&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    else OS = &quot;an unknown operating system&quot;;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;//check the string&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;function checkIt(string)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    place = detect.indexOf(string) + 1;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    thestring = string;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;    return place;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;난독화된 코드&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
var e=navigator.userAgent.toLowerCase();var f,b,c,total,d;if(a(&#039;konqueror&#039;)){b=&quot;Konqueror&quot;;f=&quot;Linux&quot;;};else if(a(&#039;opera&#039;))b=&quot;Opera&quot;;else if(a(&#039;msie&#039;))b=&quot;Internet Explorer&quot;;else if(!a(&#039;compatible&#039;)){b=&quot;Netscape Navigator&quot;;c=e.charAt(8);};else b=&quot;An unknown browser&quot;;if(!c)c=e.charAt(g+d.length);if(!f){if(a(&#039;linux&#039;))f=&quot;Linux&quot;;else if(a(&#039;x11&#039;))f=&quot;Unix&quot;;else if(a(&#039;mac&#039;))f=&quot;Mac&quot;;else if(a(&#039;win&#039;))f=&quot;Windows&quot;;else f=&quot;an unknown operating system&quot;;};function a(string){g=e.indexOf(string)+1;d=string;return g;};&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;C/C++ 개발자에게는 코드 난독화가 생소한 개념일 수 있지만, 자바 개발자들은 수년전부터 코드 난독화 도구를 실용적인 목적으로 이용해 오고 있다. 자바의 바이트코드는 윈도 실행 파일보다 훨씬 많은 심볼(symbol)을 컨스턴트 풀(constant pool) 영역에 가지고 있기 때문이다. 난독화를 거치지 않은 자바 바이트코드를 디컴파일해보면, 원래 소스 코드의 대부분이 복구되는 것을 알 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfs13.tistory.com/original/8/tistory/2008/11/30/01/03/493167c984cdd&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs13.tistory.com/image/8/tistory/2008/11/30/01/03/493167c984cdd&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;olly_dbg.png&quot; height=&quot;385&quot; width=&quot;527&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;/span&gt;&lt;span style=&quot;font-family: 바탕;&quot;&gt;윈도 PE 분석에 가장 많이 사용되는 어셈블리 디버거인 OllyDbg&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 바탕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 바탕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;코드 난독화에 대한 재미난 사실은 이 기술이 바이러스나 웜 제작자들에 의해 처음 연구되었다는 사실이다. 바이러스나 웜은 백신의 스캔에 걸리지 않기 위해 자신의 바이너리를 교묘한 형태로 숨겨왔는데, 이렇게 바이너리를 변형해 정보를 숨기는 기술이 바이너리 코드 난독화의 목표이다. 반면에 백신 개발자들은 이렇게 변형된 웜을 탐지하기 위해, 소스 코드를 확인할 수 없는 바이너리 코드의 안정성과 취약점을 분석하는 기술을 발전시켜왔다, 코드 난독화와 바이너리 분석 기술은 서로 경쟁하는 기술인 셈이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;기본적인 바이너리 코드 난독화 방법&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;가장 기본적인 코드 난독화는 바이너리에서 심볼 정보를 제거하거나 변경하는 것이다. C/C++로 컴파일된 바이너리의 경우 디버깅 옵션을 주면 바이너리에 심볼 정보가 포함되는데 난독화 도구는 이런 정보를 지워서, 바이너리에서 사람이 이해할 수 있는 정보를 최대한 제거하는 것이다. 자바의 경우는 심볼 정보가 프로그램 수행에 필요하므로, 심볼 정보를 제거할 수는 없다. 대신에 자바용 난독화 도구는 심볼 이름을 바꾸는 방법을 많이 사용한다. MyString이라는 클래스 이름보다는 M라는 클래스 이름이 알아보기 어렵고, find라는 메쏘드 이름보다는 f라는 이름이 공격자가 이해하기 어렵다는 점에 착안한 것이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;그 외에도 다음과 같은 난독화 방법이 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot; lang=&quot;EN-US&quot;&gt;1. 필요 이상으로 복잡한 코드를 만들거나, 아무 것도 하지 않는 코드를 삽입한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 난독화 기술은 실행되지 않는 함수를 추가하거나, 아무 것도 하지 않는 함수들을 중간 중간에 삽입하여 바이너리 코드 분석을 힘들게 만드는 것이다. 이런 일은 데드 코드(dead code)를 제거하고, 코드를 짧고 간단하게 만드는 최적화 컴파일러(optimizing compiler)가 하는 일에 역행하지만, 역공학을 어렵게 만드는 데는 효과적이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;물론 이런 기술을 사용해도 공격자가 함수 호출 그래프(call graph)와 흐름 그래프(control flow graph)를 그리고, 세심하게 코드를 분석하면 취약점을 찾아내는 것은 시간문제이다. 하지만 그렇다고 이런 난독화 기술이 의미가 없지는 않다. 난독화의 목표는 역공학을 불가능하게 만드는 게 아니라, 충분히 어렵게 만들어서 공격자가 포기하고 다른 공격 대상을 찾게 만드는 데 있기 때문이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot; lang=&quot;EN-US&quot;&gt;2. 코드를 여기저기로 복사하고, 옮긴다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;관련된 코드를 최대한 멀리 떨어진 곳에 배치하거나, 함수를 인라이닝(inlining)하고, 반복되는 몇 개의 구문(statement)을 합쳐서 익명의 함수를 만드는 등의 일을 할 수 있다. 똑같은 함수를 복사하여, 각기 다른 지점에서 다른 함수 이름을 사용하는 방법도 있다. 연달아 불리는 서로 관련 없는 함수를 하나의 함수로 묶어주는 방법도 있다. 성능을 심각하게 해치지 않는 범위에서 코드를 뒤섞는 모든 방법이 여기에 포함된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M; font-weight: bold;&quot; lang=&quot;EN-US&quot;&gt;3. 데이터를 알아보기 힘들게 인코딩(encoding)한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;취약점 분석가들이 바이너리 분석에서 가장 먼저 하는 일은 바이너리에 포함된 텍스트(text) 문자열을 찾아내는 것이다. 일례로, C 언어로 char passwd[] = &quot;mypass&quot;; 같은 코드가 컴파일되어 바이너리에 포함되어 있다면 strings 명령으로 바이너리를 스캔해 보는 것만으로도 암호를 발견해 낼 수 있다. 믿지 않겠지만, 실제로 이런 코드가 발견되는 경우가 매우 빈번하다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;본문&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;해결책은 텍스트 문자열을 알아보기 힘든 방식으로 인코딩하고 필요할 경우만 디코딩(decoding)해서 사용하는 방법이다. 특히 외부로 노출되었을 경우 곤란한 정보인 경우, 이런 과정을 거치는 것이 좋다. 인코딩/디코딩하는 방법으로 암호 알고리즘을 사용하는 것도 한 방법이다. 하지만 암호 알고리즘도 역공학 앞에서는 완벽한 보호책이 되지 못한다. 복호화에 사용되는 키가 메모리 어딘가에 반드시 존재해야 하고, 복호화 직전에 이 키를 읽어와야만 하기 때문이다. 공격자는 언제든지 암호키를 읽을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;앞서 살펴본 3가지 방법은 역공학을 어렵게 만들기는 하지만, 프로그램의 성능을 심각하게 떨어뜨릴 수 있다. 난독화 도구는 각종 난독화 방법을 적용할지 여부를 옵션으로 남겨놓는데, 시스템과 성능과 역공학에 대한 저항성 등을 상충되는 요구 사항을 잘 고려한 후에 결정해야할 문제다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;앞서 이야기한 것처럼 역공학에 대한 100% 완벽한 대안은 없다. 바이너리를 분석하고 수정할 수 있다면 어떠한 안전장치도 통과할 수 있기 때문이다. 다만 전자 상거래나 보안 제품 등 높은 수준의 보안성을 요구하는 프로그램이라면, 약간의 성능 저하를 감수하고서라도 각종 코드 난독화 기술을 적용해볼 여지를 가지고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;이 글에서는 역공학과 코드 난독화의 기본적인 개념과 간단한 메커니즘만 소개하였고, 세부적인 기술에 대한 논의는 지면 관계상 보류하였다. 관심 있는 독자는 &quot;obfuscate&quot;라는 단어로 좀 더 많은 자료를 찾아보길 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;참고 문헌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;[1] Building Secure Software, Viega, McGraw, Addison-Wesley&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 양재 다운명조M;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 가지;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>obfuscation</category>
			<category>Reverse Engineering</category>
			<category>난독화</category>
			<category>역공학</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/333</guid>
			<comments>http://skyul.tistory.com/333#entry333comment</comments>
			<pubDate>Sun, 30 Nov 2008 01:04:39 +0900</pubDate>
		</item>
		<item>
			<title>웹과 사용자 인터페이스</title>
			<link>http://skyul.tistory.com/332</link>
			<description>&lt;br /&gt;
마이크로소프트웨어 2008년 9월호 박스 기사입니다.&lt;br /&gt;
&lt;br /&gt;&lt;div class=&quot;imageblock&quot; style=&quot;display:inline;&quot;&gt;&lt;a href=&quot;http://cfs12.tistory.com/original/1/tistory/2008/11/29/23/11/49314d96873e6&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs12.tistory.com/image/1/tistory/2008/11/29/23/11/49314d96873e6&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;webui.png&quot; height=&quot;286&quot; width=&quot;372&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT의 위젯이나 고급 Ajax UI 라이브러리는 HTML과 CSS 밖에 없는 브라우저 위에 버튼, 레이블, 메뉴 등을 쉽게 만들 수 있게 해준다. 대표적인 Ajax UI 툴킷은 Ext이다. 위 그림은 Ext로 MS 윈도 데스크톱 환경을 비슷하게 구현한 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;웹 브라우저에 그림을 그리려면 HTML와 CSS를 사용해야 한다. 따라서 웹 UI 라이브러리는 자바 SWT와 달리 UI가 변할 때마다 HTML을 동적으로 생성하는 방식을 쓴다. 브라우저에서 데스크톱 이상의 UI 툴킷을 구현하는 것은 웹 표준이 의도한 바를 넘어선 해킹인 셈이다. 속도 향상을 위해 많은 최적화 방법이 사용되지만 여전히 답답할 만큼 속도가 느리다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;HTML5에서는 성능 문제가 보다 쉽게 해결될 수 있다. HTML5에 추가된 &amp;lt;canvas&amp;gt; 자바스크립트로 호출할 수 있는 2D 벡터 그래픽 API를 제공하기 때문이다. DOM에서 canvas 오브젝트를 얻어, GDI+나 Cairo와 유사한 2D 벡터 그래픽 API로 그릴 수 있다. 이 방식을 사용하면 UI 툴킷을 좀 더 효율적으로 구현할 수 있고 기존 UI 툴킷도 쉽게 포팅할 수 있으리라 기대된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>canvas</category>
			<category>Extjs</category>
			<category>html5</category>
			<category>웹유저인터페이스</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/332</guid>
			<comments>http://skyul.tistory.com/332#entry332comment</comments>
			<pubDate>Sat, 29 Nov 2008 23:12:20 +0900</pubDate>
		</item>
		<item>
			<title>스크립트 언어와 개발 도구(IDE)</title>
			<link>http://skyul.tistory.com/331</link>
			<description>&lt;br /&gt;
마이크로소프트웨어 2008년 9월 박스 기사입니다.&lt;br /&gt;
&lt;br /&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;흔히 스크립트 언어는 개발 도구 개발이 어렵다고 생각하는 사람이 많다. 동적 타입 시스템을 사용하는 스크립트 언어는 실행 전에 정확한 타입 정보를 알기 어렵기 때문이다. 예를 들어, MS 비주얼 스튜디오 인텔리센스(IntelliSense)는 자동으로 변수 혹은 함수 이름을 완성해주는 기능이다. 하지만 불행히도 스크립트 언어는 인텔리센스 같은 자동 완성 기능을 완벽히 지원하기 어렵다. 변수의 정확한 타입을 모르기 때문이다. 또 다른 예로, 리팩토링이 있다. 메서드 이름 변경 리팩토링을 했을 때 스크립트 언어는 메서드가 사용된 위치를 100% 정확히 파악할 수 없다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;하지만 개발 도구 지원이 약한 것이 반드시 언어 특징 때문은 아니다. 정적 타입 시스템을 사용하는 언어라고 크게 상황이 다르지 않기 때문이다. 예를 들어 자바는 정적 타입 시스템을 사용하지만 컴파일 타임에 모든 정보를 알 수 있지는 않다. 대표적인 예가 리플렉션(reflection)이다. 자바도 실행 시에 문자열로 메서드 이름이나 필드 이름을 참조할 있기 때문에 스크립트 언어와 마찬가지로 인텔리센스나 리팩토링 기능이 정확할 수 없다. 스크립트 언어 개발 도구가 미흡한 것은 아직 다른 언어처럼 개발 도구 개발에 많은 노력을 하지 않았기 때문으로 보는 것이 옳다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>PL</category>
			<category>IDE</category>
			<category>스크립트 언어</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/331</guid>
			<comments>http://skyul.tistory.com/331#entry331comment</comments>
			<pubDate>Sat, 29 Nov 2008 23:09:22 +0900</pubDate>
		</item>
		<item>
			<title>웹 클라이언트 프로그래밍 언어</title>
			<link>http://skyul.tistory.com/330</link>
			<description>&lt;br /&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
요즘은 자바 플랫폼과 .NET을 보면 다중 언어 지원이 대세다. 개발자가 하나의 프로그래밍 언어에 얽매여 있을 필요가 없는 시대가 왔다. 그런데 웹 클라이언트 프로그래밍만은 예외다. 어떤 개발자도 예외 없이 자바스크립트를 쓰도록 강요받고 있기 때문이다. 자바스크립트 나름의 매력에도 불구하고 웹 클라이언트 프로그래밍에 다른 언어를 쓰고자 하는 욕망이 있다 구글의 GWT, 280Slides의 Objective-J 등은 웹 클라이언트 프로그래밍에 각각 자바와 Objective-C라는 기존 언어를 쓰고자 하는 시도다. 이 글에서는 자바스크립트의 대안으로 사용되는 웹 클라이언트 프로그래밍 언어들을 살펴보려 한다.&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;마이크로소프트웨어 2008년 9월 기고글입니다.&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;새로운 웹 클라이언트 프로그래밍 언어&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;과거에는 프로그래밍 언어 하나로 전체 시스템을 만드는 방식이 일반적이었다. 하지만 스크립트 언어, 함수 언어 등의 필요성과 장점이 부각되면서 하나의 시스템을 만드는 데 여러 언어를 동시에 쓰는 방법이 인기를 얻고 있다. 예를 들어, 주요 컴포넌트는 자바로 작성하고 컴포넌트 통합 및 사용자 인터페이스 작성은 그루비로 하는 방식은 각 언어의 특징을 잘 살린 실용적인 접근법이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;처음부터 다중 언어 지원을 중요한 기능으로 내세웠던 .NET은 현재 C#, VB.NET 외에도 IronPython, IronRuby, F#을 비롯해 수십 개의 프로그래밍 언어를 지원하고 있다. .NET에 대응하여 다빈치 머신(Davinci Machine) 프로젝트를 통해 다중 언어 지원을 강화하고 있는 자바 플랫폼도 그루비, Jython, JRuby, 스칼라 등의 자바가상머신 언어 개발을 적극적으로 후원하고 있다. 프로그래밍 언어의 중요 개발자들은 마이크로소프트와 썬 썬마이크로시스템즈가 영입해 개발 속도를 높이고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이런 변화의 바람 속에도 꿋꿋이 단일 언어만 고집하는 분야가 웹 클라이언트 프로그래밍이다. Ajax 바람 속에 웹 프로그래밍이 서버에서 클라이언트로 추가 넘어가고 있지만 자바, 파이썬, 루비를 포함한 서버의 다양한 개발 언어와 달리 클라이언트 프로그래밍은 오직 자바스크립트만이 유일한 대안이다. 대신 jQuery, Dojo, Prototype 등의 Ajax 라이브러리들은 각자의 취향에 따라 여러 속임수로 다른 언어를 흉내 내고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;하지만 시간이 흐르면서 웹 클라이언트 프로그래밍에 새로운 언어들이 등장하기 시작했다. 대표 선수는 자바를 웹 프로그래밍에 사용한 구글의 GWT(Google Web Toolkit)다. 웹 프레젠테이션 도구인 280Slides 작성에 쓰인 Objective-J도 유명하다. 그 외에도 아직 프로토타입 수준이지만 루비, 파이썬 등 현존하는 거의 모든 언어가 모두 웹에서 돌아가는 시대가 열렸다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이들 언어는 기존 웹브라우저에서 그대로 동작한다. 비법은 컴파일러에 있다. GWT의 경우 GWT 컴파일러가 자바로 작성된 소스 코드를 컴파일해서 자바스크립트를 생성한다. 일반적인 컴파일러는 고급 언어를 컴파일해서 중간 언어 혹은 기계 코드를 생성하는데 비해 웹 프로그래밍 언어 컴파일러는 최종 코드가 자바스크립트라는 차이만 있을 뿐 기본적인 컴파일러 동작 방식은 동일하다. 컴파일러 기술에 웹 클라이언트 프로그래밍 언어의 새로운 지평을 열었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;GWT(Google Web Toolkit)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Ajax 프로그래밍은 구글의 대표 기술이다. 지메일(Gmail), 구글맵(Google Maps) 등 구글 대표 서비스는 Ajax 기술을 활용한 풍부한 사용자 인터페이스를 제공하였고 경쟁자들을 물리칠 수 있었다. 누구보다 자바스크립트를 많이 사용하는 구글이 자바스크립트가 아닌 자바로 웹 프로그래밍 툴킷을 제작했다. 구글이 밝힌 GWT의 장점은 컴파일러 최적화를 이용한 고성능 자바스크립트, 개발 도구 지원, 구글 API 및 재사용 UI 컴포넌트다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT의 기본 가정은 손으로 작성한 자바스크립트 코드보다 자바로 작성한 후 컴파일러가 최적화하는 편이 성능이 더 좋다는 것이다. 물론 자바스크립트에 정통한 개발자는 최고의 성능을 발휘하는 아름다운 코드를 작성할 수도 있겠다. 하지만 C 언어가 아닌 어셈블리를 써야만 최고의 성능을 발휘할 수 있으니 무조건 어셈블리만 사용하자는 말과 동일하다. GWT는 자바 코드 컴파일해 얻은 자바스크립트 코드가 손으로 작성한 자바스크립트 코드보다 더 빨리 로딩되면서 코드 크기는 오히려 작다고 이야기한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이식성도 중요한 이유다. 자바스크립트는 이식성이 나쁜 언어다. 웹브라우저마다 자바스크립트 인터프리터, DOM, 이벤트 등이 미묘하게 다르고 브라우저 간 호환성을 위해서는 상당한 노력이 필요하다. 물론 고급 Ajax 라이브러리가 이 문제를 상당히 해결한 것은 사실이지만 GWT는 이 문제를 더 높은 수준에서 해결했다. GWT 개발자는 GWT 개발 환경 하나만 익히면 모든 브라우저에서 호환되는 코드를 자동으로 만들 수 있게 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT가 자바를 선택한 또 다른 이유는 개발 도구 지원이다. 자바는 이클립스(Eclipse)라는 세상에서 가장 강력한 개발 도구를 보유한 언어이다. 물론 개발자 개인 취향에 따라 IntelliJ 혹은 NetBeans를 선택할 수도 있다. 반대로 자바스크립트는 개발 도구 지원이 열악하다. 동적 타입 시스템을 쓰는 스크립트 언어 특징상 개발 도구 개발이 어렵기 때문이다. 크고 복잡한 응용 프로그램 개발의 경우 개발 도구 지원 여부는 프로그래밍 언어 선택의 중요 기준이 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT은 재밌는 기능 중 하나는 JSNI(JavaScript Native Interface)이다. 원래 자바는 JNI(Java Native Interface)라고 해서 자바로 작성된 프로그램이 C 함수를 호출할 수 있는 인터페이스를 열었다. GWT는 웹 브라우저에서 돌아가는 코드를 생성하므로 C 코드를 호출할 수는 없는 대신 자바스크립트 코드를 호출할 수 있게 했는데 그 인터페이스가 JSNI다. 특정 브라우저에만 있는 기능을 이용하거나 GWT가 생성한 코드보다 더 효율적인 코드를 자바스크립트로 작성할 수 있다고 판단했을 때 쓰면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT를 사용한다고 모든 자바 프로그램이 웹에서 실행되지는 않는다. GWT는 자바 언어를 사용하지만 JRE(Java Runtime Environment)를 모두 제공하지는 않기 때문이다. GWT는 JRE의 일부를 웹으로 포팅했고 웹 프로그래밍을 위한 별도의 API를 제공한다. 또한 UI를 쉽게 만들 수 있도록 기존 스윙(Swing) 혹은 SWT와 유사한 UI API도 제공한다. UI 렌더링을 할 때는 HTML을 동적으로 생성하여 붙이는 방식을 쓴다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Objective-J&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;div class=&quot;imageblock&quot; style=&quot;display:inline;&quot;&gt;&lt;a href=&quot;http://cfs10.tistory.com/original/9/tistory/2008/11/29/23/01/49314b3d116a2&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs10.tistory.com/image/9/tistory/2008/11/29/23/01/49314b3d116a2&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;280slides.png&quot; height=&quot;371&quot; width=&quot;388&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Objective-J를 이용해 만든 프레젠테이션 도구 280slides&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;GWT가 데스크톱 프로그래밍의 일부를 웹 프로그래밍에 도입한 프로젝트라면 Objective-J와 Cappuccino는 데스크톱 프로그래밍 환경을 웹에 그대로 옮겨놓은 야심찬 프로젝트다. Objective-J는 그 이름에서 알 수 있듯이 Mac OS X 데스크톱 응용 프로그램 개발에 사용되는 Objective-C를 웹으로 옮겨놓은 버전이다. Objective-J를 만든 North280은 웹 프레젠테이션 도구(MS의 파워포인트, 애플의 키노트)인 280Slides 통해 Objective-J의 가능성을 보여줬다.  Cappuccino는 Mac OS X UI 라이브러리인 Cocoa를 웹으로 포팅한 것이고 역시 North280 팀이 만들었다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;웹 프로그래밍 하면 떠오르는 모습은 Rails, Django 등의 웹 프레임워크로 서버 측 프로그램을 작성하고 HTML, CSS, Ajax 라이브러리로 클라이언트 프로그램을 만드는 방식이다. 하지만 서버 쪽 코드를 줄이고 데스크톱 응용 프로그램과 유사한 웹 응용 프로그램을 만들려는 시도도 계속되고 있다. 대표적인 예가 SproutCore이다. 플래시나 실버라이트가 표방하는 리치 클라이언트(rich client)의 자바스크립트 버전인 셈이다. SproutCore 프로그램은 대부분의 시간을 웹 서버와 독립적으로 동작하다가 데이터를 저장하거나 불러올 때만 Ajax 라이브러리로 서버와 통신하는 방식을 사용한다. SproutCore로 작성된 프로그램은 Rails 웹 응용 프로그램보다는 데스크톱 Cocoa 프로그램을 더 닮았다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이런 변화의 바람 속에서 웹 프로그램이 Rails 보다 Cocoa 프로그램을 더 닮았다면 자바스크립트가 아닌 Objective-C로 코딩하자는 생각에서 출발한 프로젝트가 Objective-J다. Objective-J의 예는 프로그래밍 언어는 단순한 문법이 아니라 그 언어를 사용하는 사람, 문화, 기술을 통칭함을 보여준다. Objective-J 도입은 자바스크립트, CSS, HTML, DOM을 이용한 전통적 웹 응용 프로그램 개발 방식을 대체하는 데스크톱 스타일의 개발 환경을 웹으로 가져온다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Objective-J는 North280 팀에 의해 조만간 오픈소스화될 예정이다. Objective-J (&lt;/span&gt;&lt;a href=&quot;http://objective-j.org/&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://objective-j.org/&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;) 홈페이지를 확인해 보기 바란다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;Flapjax&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;앞서 언급한 GWT나 Objective-J는 기존 프로그래밍 언어를 웹으로 포팅하고 각 언어의 장점을 살려 데스크톱 응용 프로그램을 쉽게 구축할 수 있는 방법을 제공했다. 반면에 Flapjax는 새로운 웹 프로그래밍 모델을 제시하는 프로그래밍 언어다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바스크립트 프로그래밍의 문제점 중 하나는 콜백 함수 등록이 너무 많다는 점이다. 마우스 위치를 따라 네모 박스가 약간 시간 간격을 두고 따라오는 간단한 자바스크립트 프로그램을 생각해보자. 다음과 같은 HTML, 자바스크립트 코드가 필요할 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;div id=&quot;box&quot; style=&quot;position:absolute; background:yellow;&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;   Seconds to deadline: &amp;lt;span id=&quot;time&quot;&amp;gt;...time...&amp;lt;/span&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;document.addEventListener(&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    &#039;mousemove&#039;,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    function(e) {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;        var left = e.pageX&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        var top = e.pageY&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        setTimeout(function() {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; document.getElementById(&quot;box&quot;).style.top = top;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;            document.getElementById(&quot;box&quot;).style.left = left;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        }, 500);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    }, false);&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바스크립트 예제&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;자바스크립트 프로그래밍에 익숙한 개발자는 위 코드가 직관적이라고 느낄 수도 있겠다. 하지만 마우스 위치에 따라 네모 상자를 옮기는 간단한 일을 하기 위해 콜백을 2번 등록하고 &quot;box&quot; ID를 찾아서 값을 변경해야 한다. 가독성도 떨어진다. 이 프로그램은 마우스의 움직임에 따라 다음 그림과 같은 명확한 데이터 흐름이 있지만 위 자바스크립트 소스 코드만 보고 이 사실을 한 번에 알아내기는 쉽지 않다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[if gte vml 1]&gt;&lt;v:shapetype id=&quot;_x0000_t75&quot;		coordsize=&quot;21600,21600&quot; o:spt=&quot;75&quot; o:preferrelative=&quot;t&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot;		filled=&quot;f&quot; stroked=&quot;f&quot;&gt;		&lt;v:stroke joinstyle=&quot;miter&quot;/&gt;		&lt;v:formulas&gt;		&lt;v:f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;		&lt;v:f eqn=&quot;sum @0 1 0&quot;/&gt;		&lt;v:f eqn=&quot;sum 0 0 @1&quot;/&gt;		&lt;v:f eqn=&quot;prod @2 1 2&quot;/&gt;		&lt;v:f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;		&lt;v:f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;		&lt;v:f eqn=&quot;sum @0 0 1&quot;/&gt;		&lt;v:f eqn=&quot;prod @6 1 2&quot;/&gt;		&lt;v:f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;		&lt;v:f eqn=&quot;sum @8 21600 0&quot;/&gt;		&lt;v:f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;		&lt;v:f eqn=&quot;sum @10 21600 0&quot;/&gt;		&lt;/v:formulas&gt;		&lt;v:path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;		&lt;o:lock v:ext=&quot;edit&quot; aspectratio=&quot;t&quot;/&gt;	&lt;/v:shapetype&gt;&lt;v:shape id=&quot;_x82384968&quot; style=&quot;v-text-anchor:top;mso-position-vertical-relative:line;mso-position-vertical:absolute;mso-position-horizontal-relative:text;mso-position-horizontal:absolute;width:424.89pt;height:152.59pt;position:absolute;&quot; type=&quot;#_x0000_t75&quot;&gt;&lt;v:imagedata o:title=&quot;EMB0000095c9d19&quot; src=&quot;file:///C:\DOCUME~1\admin\LOCALS~1\Temp\Hnc\BinData\EMB0000095c9d19.bmp&quot;/&gt;&lt;w:wrap type=&quot;topAndBottom&quot;/&gt;&lt;/v:shape&gt;&lt;![endif]--&gt;  &lt;!--[if !vml]--&gt;&lt;img src=&quot;file:///C:/DOCUME%7E1/admin/LOCALS%7E1/Temp/Hnc/BinData/EMB0000095c9d19.bmp&quot; v:shapes=&quot;_x82384968&quot; width=&quot;424&quot; height=&quot;152&quot;&gt;&lt;!--[endif]--&gt;  &lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;!--[if gte vml 1]&gt;&lt;v:shapetype id=&quot;_x0000_t75&quot;		coordsize=&quot;21600,21600&quot; o:spt=&quot;75&quot; o:preferrelative=&quot;t&quot; path=&quot;m@4@5l@4@11@9@11@9@5xe&quot;		filled=&quot;f&quot; stroked=&quot;f&quot;&gt;		&lt;v:stroke joinstyle=&quot;miter&quot;/&gt;		&lt;v:formulas&gt;		&lt;v:f eqn=&quot;if lineDrawn pixelLineWidth 0&quot;/&gt;		&lt;v:f eqn=&quot;sum @0 1 0&quot;/&gt;		&lt;v:f eqn=&quot;sum 0 0 @1&quot;/&gt;		&lt;v:f eqn=&quot;prod @2 1 2&quot;/&gt;		&lt;v:f eqn=&quot;prod @3 21600 pixelWidth&quot;/&gt;		&lt;v:f eqn=&quot;prod @3 21600 pixelHeight&quot;/&gt;		&lt;v:f eqn=&quot;sum @0 0 1&quot;/&gt;		&lt;v:f eqn=&quot;prod @6 1 2&quot;/&gt;		&lt;v:f eqn=&quot;prod @7 21600 pixelWidth&quot;/&gt;		&lt;v:f eqn=&quot;sum @8 21600 0&quot;/&gt;		&lt;v:f eqn=&quot;prod @7 21600 pixelHeight&quot;/&gt;		&lt;v:f eqn=&quot;sum @10 21600 0&quot;/&gt;		&lt;/v:formulas&gt;		&lt;v:path o:extrusionok=&quot;f&quot; gradientshapeok=&quot;t&quot; o:connecttype=&quot;rect&quot;/&gt;		&lt;o:lock v:ext=&quot;edit&quot; aspectratio=&quot;t&quot;/&gt;	&lt;/v:shapetype&gt;&lt;v:shape id=&quot;_x81542944&quot; style=&quot;v-text-anchor:top;mso-position-vertical-relative:line;mso-position-vertical:absolute;mso-position-horizontal-relative:text;mso-position-horizontal:absolute;width:424.89pt;height:152.59pt;position:absolute;&quot; type=&quot;#_x0000_t75&quot;&gt;&lt;v:imagedata o:title=&quot;EMB0000095c9d19&quot; src=&quot;file:///C:\DOCUME~1\admin\LOCALS~1\Temp\Hnc\BinData\EMB0000095c9d19.bmp&quot;/&gt;&lt;w:wrap type=&quot;topAndBottom&quot;/&gt;&lt;/v:shape&gt;&lt;![endif]--&gt;  &lt;!--[if !vml]--&gt;&lt;img src=&quot;file:///C:/DOCUME%7E1/admin/LOCALS%7E1/Temp/Hnc/BinData/EMB0000095c9d19.bmp&quot; v:shapes=&quot;_x81542944&quot; width=&quot;424&quot; height=&quot;152&quot;&gt;&lt;!--[endif]--&gt;  &lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;div class=&quot;imageblock center&quot; style=&quot;text-align: center; clear: both;&quot;&gt;&lt;a href=&quot;http://cfs13.tistory.com/original/4/tistory/2008/11/29/23/00/49314b0fa8281&quot; rel=&quot;lightbox&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://cfs13.tistory.com/image/4/tistory/2008/11/29/23/00/49314b0fa8281&quot; alt=&quot;&quot; filemime=&quot;&quot; filename=&quot;dataflow.png&quot; height=&quot;170&quot; width=&quot;540&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;데이터 흐름도(data flow)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Flapjax는 이처럼 자바스크립트(Ajax) 프로그램에서 빈번히 발생하는 데이터 흐름 중심으로 프로그램을 기술하는 언어다. 위 프로그램은 Flapjax로 작성하면 다음과 같다. Flapjax는 자바스크립트와 유사한 문법을 가지며 자바스크립트로 컴파일된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;lt;div style={!&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    {&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        position:&quot;absolute&quot;, background: &quot;yellow&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        top: delay(mouseTop(), 500),&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        left: delay(mouseLeft(), 500)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; }&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;!}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;gt; Seconds to deadline: {! timeStream() !}. &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Flapjax 예제 (주의: 설명을 위해 간단하게 만들었기 때문에 실제 동작하지 않음)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이 프로그램을 해석하는 방법은 간단하다. mouseTop()과 mouseLeft()는 지속적으로 현재 마우스의 위치를 주는 데이터 소스로 생각하면 된다. top 값은 mouseTop 값이 바뀜에 따라 지속적으로 변경되는데, 변경 시에는 500ms의 지연이 있다. 마찬가지로 left 값은 mouseLeft() 값이 바뀜에 따라 지속적으로 바뀌고 500ms의 지연이 있다. timeStream()은 흐르는 시간을 데이터 소스로 주기 때문에 화면에 표시되는 시간이 계속 바뀐다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;Flapjax는 지속적으로 값이 변경되는 데이터 소스가 존재하고 이 값이 변하면 여기에 의존하는 값들이 자동으로 변경되는 방식을 채택했다. 따라서 일반적인 자바스크립트 프로그래밍처럼 변경이 예상되는 이벤트에 일일이 콜백을 걸어줄 필요 없이도 자동으로 새로운 값이 계산된다. Flapjax 프로그래밍 모델에서는 데이터 흐름이 명시적으로 보이는 것이 장점이고 document.getElementByID를 이용해 변경할 노드를 찾을 필요 없을 값을 삽입할 위치에 직접 코드를 적어주면 된다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;핫루비(HotRuby)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;컴파일러 외에 웹에서 다중 언어를 구현하는 또 다른 방식은 자바스크립트로 가상 머신을 구현하는 것이다. 예를 들어 자바가상머신(JVM)을 자바스크립트로 작성하면 자바 프로그램을 바이트코드로 컴파일한 후에 자바스크립트로 돌릴 수 있다. 물론 가상머신은 보통 성능을 높이기 위해 효율적인 C/C++ 코드로 작성하는 것이 일반적이지만 이론적으로는 자바스크립트로 작성해도 아무런 문제가 없다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;핫루비 프로젝트는 루비 인터프리터를 자바스크립트로 구현하는 프로젝트다. Ruby 1.9 YARV(Yet Another Ruby VM)의 바이트코드 인터프리터를 만들었다. &amp;lt;script type=&quot;text/ruby&quot;&amp;gt;&amp;lt;/script&amp;gt; 태그 안에 루비 코드를 작성해 넣으면 텍스트를 뽑아서 XMLHttpRequest로 서버에 보낸다. 서버 CGI는 루비 코드를 받아서 바이트코드로 바꾸고 직렬화해 JSON으로 보낸다. 브라우저는 루비 인터프리터를 돌려서 루비 코드를 실행한다. 핫루비는 기존 코드를 재활용하기 위해 루비 컴파일러를 서버에 두는 방식을 택했지만 이론적으로는 루비 컴파일러 또한 자바스크립트로 만들어 넣을 수 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;존 레시그(John Resig)는 다음 코드로 핫루비의 성능을 측정했다[3]. 벤치마크 결과 Ruby 1.8.2에서는 12.25초가 걸렸다. 자바스크립트로 구현한 핫루비의 성능은 어느 정도 일까? 놀랍게도 파이어폭스 2에서 6.71초, 파이어폭스 3.0b5에서 2.47초 만에 수행이 끝났다. C로 구현한 Ruby 1.8.2 보다 자바스크립트로 구현한 핫루비가 몇 배나 더 빠른 셈이다. 게다가 파이어폭스 버전이 올라갈수록 더 빨라지고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;startTime = Time.new.to_f&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;sum = &quot;&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;50000.times{|e| sum += e.to_s}&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;endTime = Time.new.to_f&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;puts (endTime - startTime).to_s + &#039; sec&#039;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;루비 벤치마크&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
[&quot;YARVInstructionSequence\/SimpleDataFormat&quot;,1,1,1,{&quot;arg_size&quot;:0,&quot;local_size&quot;:4,&quot;stack_max&quot;:3},&quot;&quot;,&quot;src&quot;,&quot;top&quot;,[&quot;startTime&quot;,&quot;sum&quot;,&quot;endTime&quot;],0,[[&quot;break&quot;,null,&quot;label_21&quot;,&quot;label_29&quot;,&quot;label_29&quot;,0]],[2,[&quot;putnil&quot;],[&quot;getconstant&quot;,&quot;Time&quot;],[&quot;send&quot;,&quot;new&quot;,0,null,0,null],[&quot;send&quot;,&quot;to_f&quot;,0,null,0,null],[&quot;setlocal&quot;,4],4,[&quot;putstring&quot;,&quot;&quot;],[&quot;setlocal&quot;,3],&quot;label_21&quot;,5,[&quot;putobject&quot;,50000],[&quot;send&quot;,&quot;times&quot;,0,[&quot;YARVInstructionSequence\/SimpleDataFormat&quot;,1,1,1,{&quot;arg_size&quot;:1,&quot;local_size&quot;:1,&quot;stack_max&quot;:2},&quot;block in &quot;,&quot;src&quot;,&quot;block&quot;,[&quot;e&quot;],[1,[],0,0,-1,-1,3],[[&quot;redo&quot;,null,&quot;label_0&quot;,&quot;label_22&quot;,&quot;label_0&quot;,0],[&quot;next&quot;,null,&quot;label_0&quot;,&quot;label_22&quot;,&quot;label_22&quot;,0]],[&quot;label_0&quot;,5,[&quot;getdynamic&quot;,3,1],[&quot;getdynamic&quot;,1,0],[&quot;send&quot;,&quot;to_s&quot;,0,null,0,null],[&quot;send&quot;,&quot;+&quot;,1,null,0,null],[&quot;dup&quot;],[&quot;setdynamic&quot;,3,1],&quot;label_22&quot;,[&quot;leave&quot;]]],0,null],&quot;label_29&quot;,[&quot;pop&quot;],7,[&quot;putnil&quot;],[&quot;getconstant&quot;,&quot;Time&quot;],[&quot;send&quot;,&quot;new&quot;,0,null,0,null],[&quot;send&quot;,&quot;to_f&quot;,0,null,0,null],[&quot;setlocal&quot;,2],9,[&quot;putnil&quot;],8,[&quot;getlocal&quot;,2],[&quot;getlocal&quot;,4],[&quot;send&quot;,&quot;-&quot;,1,null,0,null],[&quot;send&quot;,&quot;to_s&quot;,0,null,0,null],[&quot;putstring&quot;,&quot; sec&quot;],9,[&quot;send&quot;,&quot;+&quot;,1,null,0,null],[&quot;send&quot;,&quot;puts&quot;,1,null,8,null],8,[&quot;leave&quot;]]]&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;서버가 생성해 JSON으로 준 핫루비 바이트코드&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;상식적으로 납득하기 어려운 벤치마크 결과를 설명하기 위해서는 Ruby 1.8.2와 Ruby 1.9의 차이를 알아야 한다. Ruby는 인터프리터가 비효율적인 것으로 유명한 스크립트 언어다. 동일한 일을 수행하는 코드를 작성하면 C 보다 100배 이상 느린 경우가 다반사다. 파이썬이 소스코드를 일단 중간 코드(바이트코드)로 변환한 후에 인터프리트하는 것과 달리 루비는 1.8.2까지 파싱된 소스 코드(AST)를 매번 새로 방문하면서 코드를 실행하는 방식을 택했기 때문이다. YARV는 이런 문제를 해결하기 위해 루비에 바이트코드 인터프리터를 추가하는 프로젝트였고 루비 1.9는 YARV를 기본으로 채택했다. 핫루비는 바이트코드 인터프리터이기 때문에 루비 1.8.2의 비효율적인 실행 방식에 비해 빠르다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;핫루비의 성능이 괜찮은 또 다른 요인은 자바스크립트 인터프리터가 점점 빨라지고 있다는 점이다. 파이어폭스 2.0과 3.0b5의 비교를 해보면 3.0b에서 2.71배 속도 향상이 있음을 볼 수 있다. 앞서 언급한 GWT, Objective-J 등 대형 Ajax 프레임워크가 나오면서 자바스크립트 속도 향상이 브라우저 벤더들 사이에서 중요한 요구사항이 되었기 때문이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;모질라는 파이어폭스의 성능을 더 높이기 위해 현재 아도브가 기증한 타마린(Tamarin) 스크립트 엔진을 파이어폭스 스크립트 엔진인 스파이더몽키(SpiderMonkey)에 붙이는 액션몽키(ActionMonkey) 프로젝트를 진행하고 있다. 그것만으로 모자랐는지 아도브는 타마린에 바이트코드 실행 기록을 남겨서 머신 코드를 생성하는 트레이스 JIT를 추가한 타마린 트레이싱(Tamarin Tracing)까지 내놓고 자바스크립트 속도를 높이기 위해 안간힘을 쓰고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;이런 움직임은 애플 사파리에서도 마찬가지다. 애플은 최근 레지스터 바이트코드를 쓰는 다이렉트 쓰레드(direct-threaded) 코드 기반의 효율적인 자바스크립트 엔진 인터프리터인 스쿼럴피시(SquirrelFish)를 내놨고, 그 속도는 JIT 컴파일러를 내장한 타마린을 능가하고 있다. 스쿼럴피시는 앞으로 사파리에 탑재되어 데스크톱 사파리와 iPhone 사파리 모바일 등에 사용될 예정이다. &lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;정리&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;웹 프로그래밍은 서버에서 클라이언트로 이동하고 있다. 플래시, 실버라이트, JavaFX 등 비표준 RIA 플랫폼 이런 변화를 앞당긴 기술이다. 웹 표준 기반 응용 프로그램도 서서히 서버에서 클라이언트로 방향 전환을 하고 있다. 따라서 Ajax로 대표되는 웹 클라이언트 프로그래밍의 중요성이 날로 커지고 있다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;앞서 살펴본 것처럼 웹 클라이언트 프로그램이 발전하고 데스크톱 응용 프로그램과 유사한 기능을 원하게 되면 기존 데스크톱 응용 프로그램에 작성에 사용되는 프로그래밍 언어와 라이브러리들이 웹으로 진입할 가능성이 크다. 컴파일러 혹은 VM 기술에 힘입어 기존 브라우저를 수정하지 않고도 다양한 언어를 지원할 수 있기 때문이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;따라서 앞으로 웹 개발자는 빠르고 효율적인 개발을 위해 서버 기반 웹 프레임워크에서 벗어나 클라이언트 솔루션을 찾아볼 필요가 있다. GWT, Objective-J, Flapjax 등의 새로운 웹 프로그래밍 언어 및 프레임워크는 웹 응용 프로그램 작성에 있어 든든한 지원군이 되어줄 것이다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;참고문헌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;font-weight: bold;&quot; class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;span style=&quot;font-size: 11pt;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[1] GWT(Google Web Toolkit) Documentation&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://code.google.com/webtoolkit/overview.html&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://code.google.com/webtoolkit/overview.html&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[2] Flapjax Tutorial&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://www.flapjax-lang.org/tutorial/&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://www.flapjax-lang.org/tutorial/&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;[3] Ruby VM in JavaScript&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;a href=&quot;http://ejohn.org/blog/ruby-vm-in-javascript/&quot;&gt;&lt;u style=&quot;&quot;&gt;&lt;span style=&quot;color: rgb(0, 0, 255);&quot; lang=&quot;EN-US&quot;&gt;http://ejohn.org/blog/ruby-vm-in-javascript/&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;제목 1&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;발문&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>PL</category>
			<category>FlapJax</category>
			<category>GWT</category>
			<category>HotRuby</category>
			<category>Objective-J</category>
			<category>웹 프로그래밍 언어</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/330</guid>
			<comments>http://skyul.tistory.com/330#entry330comment</comments>
			<pubDate>Sat, 29 Nov 2008 23:06:08 +0900</pubDate>
		</item>
		<item>
			<title>헤스켈의 IO</title>
			<link>http://skyul.tistory.com/329</link>
			<description>&lt;br /&gt;
&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
마소 4월호 박스 기사입니다.&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;헤스켈은 순수 함수형 언어이며 원칙적으로 사이드 이펙트가 없다. 여기서 사이드 이펙트는 프로그램 수행의 결과로 상태가 변화하는 경우를 일컫는다. 대표적인 사이드 이펙트는 IO로, 화면에 결과를 출력하거나 키보드로부터 입력을 받는 일을 말한다. 간단한 예로 putStr 함수는 문자열을 받아서 화면에 출력해주며 타입은 다음과 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
putStr :: String -&amp;gt; IO ()&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;putStr의 타입&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;putStr은 String을 인자로 받고 IO를 수행한 후에 ()를 리턴한다는 뜻이다. 또 다른 예로 getLine을 사용자에게 한 줄 입력을 받는 함수며 타입이 다음과 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
getLine :: IO String&lt;/div&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;getLine의 타입&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;getLine은 인자가 없고 IO를 수행 후에 String 타입을 리턴한다. do {}를 사용하면 이렇게 IO를 수행하는 함수를 통해 조금 더 복잡한 일을 순차적으로 수행할 수 있다. 앞서 소개한 두 함수를 조합해 사용자가 한 줄 입력을 받은 후에 그대로 보여주는 프로그램은 다음과 같다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div style=&quot;border: 1px solid rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;echo :: IO ()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;echo = do { s &amp;lt;- getLine&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;            ; putStr s }&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;&quot; lang=&quot;EN-US&quot;&gt;echo 함수&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;br /&gt;
&lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>PL</category>
			<category>IO</category>
			<category>헤스켈</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/329</guid>
			<comments>http://skyul.tistory.com/329#entry329comment</comments>
			<pubDate>Sat, 29 Nov 2008 04:34:30 +0900</pubDate>
		</item>
		<item>
			<title>커링(currying)</title>
			<link>http://skyul.tistory.com/328</link>
			<description>&lt;div style=&quot;border: 1px dashed rgb(193, 193, 193); padding: 10px; background-color: rgb(238, 238, 238);&quot; class=&quot;txc-textbox&quot;&gt;
마소 4월호 박스 기사입니다.&lt;/div&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;본문에서는 transfer 함수가 Account, Account, Int 타입의 인자 3개를 받고 IO () 리턴하는 함수로 설명했다. 이런 해석 방식으로도 헤스켈 함수를 이해하고 사용하는 데에는 아무런 지장이 없지만 헤스켈에서 -&amp;gt;을 보다 정확히 이해하기 위해서는 &lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕; font-weight: bold;&quot;&gt;커링(curring)&lt;/span&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;의 개념을 알아야 한다.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;헤스켈은 C/C++, 자바 등 일반적인 명령형(imperative) 언어와 달리 함수가 제 1 클래스이다. (파이썬과 루비 같은 최신 스크립트 언어는 예외다.) 여기서 제 1 클래스라고 하면 다른 타입과 마찬가지로 함수 역시 함수의 인자로 넘길 수 있고 리턴 값으로 함수를 리턴할 수도 있다는 뜻이다. 그리고 -&amp;gt;는 결합의 방향이 오른쪽이다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;따라서 Account -&amp;gt; Account -&amp;gt; Int -&amp;gt; IO ()는 실제로 (Account -&amp;gt; (Account -&amp;gt; (Int -&amp;gt; IO ())))를 뜻한다. 이렇게 괄호로 묶은 (Account -&amp;gt; (Account -&amp;gt; (Int -&amp;gt; IO ())))를 다시 보면 한 가지 흥미로운 사실을 발견할 수 있다. 이 함수는 Account 타입을 하나 인자로 받아서 (Account -&amp;gt; (Int -&amp;gt; IO ())) 타입의 함수를 리턴하는 함수로 볼 수도 있기 때문이다. 리턴된 함수의 타입인 (Account -&amp;gt; (Int -&amp;gt; IO ())) 역시 또 다른 Account를 인자로 받고 (Int -&amp;gt; IO ())를 타입으로 가지는 또 다른 함수를 리턴한다. 마지막으로 이 함수에 Int 인자를 넘기면 IO () 타입을 리턴한다. &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;  &lt;!--[if !supportEmptyParas]--&gt;&amp;nbsp;&lt;!--[endif]--&gt;  &lt;o:p&gt;&lt;/o:p&gt;&lt;/p&gt;
&lt;p class=&quot;바탕글&quot;&gt;&lt;span style=&quot;font-family: 맑은 고딕;&quot;&gt;즉, 우리가 처음에 3개의 인자를 받는다고 생각했던 transfer 함수는 실제로는 1개의 인자를 받는 여러 개의 함수로 이해할 수도 있다. 이처럼 여러 개 인자를 받는 함수를 1개의 인자를 받는 여러 함수로 변화시키는 것을 커링(currying)이라고 부른다.&lt;/span&gt;&lt;/p&gt;
&lt;br /&gt;</description>
			<category>PL</category>
			<category>커링</category>
			<category>헤스켈</category>
			<author>죽현마을</author>
			<guid>http://skyul.tistory.com/328</guid>
			<comments>http://skyul.tistory.com/328#entry328comment</comments>
			<pubDate>Sat, 29 Nov 2008 04:32:04 +0900</pubDate>
		</item>
	</channel>
</rss>
