<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
	<channel>
		<title>오라클 성능 문제에 대한 통찰 - 조동욱</title>
		<link>http://ukja.tistory.com/</link>
		<description>엑셈 조동욱 컨설턴트가 운영하는 오라클 성능 문제 전문 블로그</description>
		<language>ko</language>
		<pubDate>Wed, 17 Aug 2011 08:01:31 +0900</pubDate>
		<generator>Tistory 1.1 (http://www.tistory.com/)</generator>
		<image>
		<title>오라클 성능 문제에 대한 통찰 - 조동욱</title>
		<url><![CDATA[http://cfs5.tistory.com/upload_control/download.blog?fhandle=YmxvZzExMjM2NEBmczUudGlzdG9yeS5jb206L2F0dGFjaC8wLzE1MDAwMDAwMDAwMC5naWY%3D]]></url>
		<link>http://ukja.tistory.com/</link>
		<description>엑셈 조동욱 컨설턴트가 운영하는 오라클 성능 문제 전문 블로그</description>
		</image>
		<item>
			<title>Set-Based Approach</title>
			<link>http://ukja.tistory.com/362</link>
			<description>SQL을 효과적으로 작성하는 방법은 &lt;b&gt;집합적 사고(Set-Based Approach)&lt;/b&gt;를 사용하는 것이라고 하죠.
&lt;p/&gt;
오늘 어떤 책을 보다가 아주 재미있는 예제를 봤습니다. 아래 문제를 손쉽게 푸신다면 집합적 사고에 능숙하다고 할 수 있겠습니다.
&lt;p/&gt;
&lt;b&gt;1. &lt;/b&gt;아래와 같은 테이블 ORDERS가 있습니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
create table orders(
    member_no     number, -- 회원번호
    order_no        number, -- 주문번호
    order_date     date -- 주문일자
);
&lt;/pre&gt;
&lt;b&gt;2. &lt;/b&gt;아래 질문을 집합적 사고에 기반한 SQL 문으로 작성해 보세요.
&lt;ul&gt;
&lt;li&gt;100번 회원의 &lt;b&gt;주문 간격의 평균값&lt;/b&gt;은 무엇입니까?
&lt;/ul&gt;
즉, 2010년 12월 1일, 2010년 12월 10일, 2010년 12월 15일 이렇게 세번 주문했다면 이렇게 되겠죠?
&lt;ul&gt;
&lt;li&gt;2010년 12월 10일 - 2010년 12월 1일 = 10일
&lt;li&gt;2010년 12월 15일 - 2010년 12월 10일 = 5일
&lt;li&gt;따라서 평균 = (10 + 5) / 2 = 7.5일
&lt;/ul&gt;
자신만의 SQL 문장을 잠시 생각해보세요. 
&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
만일 다음과 같은 문장을 생각했다면 SQL 작성에는 능숙할지 모르겠지만 집합적 사고에는 실패하신 겁니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
select 
    avg(trunc(order_date) - trunc(prev_order_date))  avg_order_between  -- (현재일자 - 이전일자)의 평균
from (
    select 
          order_date,   -- 현재 주문일자
          lag(order_date, 1, order_date) over (partition by member_no order by order_date
              as prev_order_date  -- 이전 주문일자
    from
        orders
    where
        member_no = 100
);
&lt;/pre&gt;
사실 위의 문장은 집합적 사고에 조금 실패한 정도가 아니라, 완벽하게 프로시저적인 방법(한단계 한단계씩 실행하는 방식)입니다.
&lt;p/&gt;
그렇다면 완벽한 집합적 사고에 의해 작성된 SQL 문장은 무엇일까요? 책에서 제시한 정답은 다음과 같습니다.
&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
...&lt;p/&gt;
&lt;pre class=&quot;brush: sql; &quot;&gt;
select
    (max(trunc(order_date)) - min(trunc(order_date))) / count(*) as avg_order_between
from
    orders
where
    member_no = 100
;
&lt;/pre&gt;
어떠신가요? 집합적 사고에 성공하셨나요? 
&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-362-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/362&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/362</guid>
			<comments>http://ukja.tistory.com/362#entry362comment</comments>
			<pubDate>Thu, 09 Dec 2010 18:23:56 +0900</pubDate>
		</item>
		<item>
			<title>Missing Value 채우기와 Row를 Column으로 변환하기 - Partition Outer Join과 listagg 함수의 조합의 예</title>
			<link>http://ukja.tistory.com/361</link>
			<description>데이터 모델링을 하다보면 비정규화의 유혹에 빠지는 경우가 있습니다. 이유는 여러가지가 있겠지만, 대표적인 한가지 이유는 &lt;b&gt;우리의 데이터 인식법과 관계형 데이터베이스의 표현 양식에서 차이가 있다&lt;/b&gt;는 것입니다. 가령 특정 테이블에 있는 인덱스별로 컬럼 목록을 보고 싶다면, 우리 눈에는 이렇게 보는 것이 가장 편합니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
T1_N1		C1, C2, C3
T1_N2		C3
T1_N3		C2, C1
&lt;/pre&gt;
하지만 관계형 데이터베이스는 정규화 법칙에 의해 다음과 같이 데이터를 저장하게 됩니다. 보기가 어렵죠.
&lt;pre class=&quot;brush: sql; &quot;&gt;
T1_N1		C1
T1_N1		C2
T1_N1		C3
T1_N2		C3
T1_N3		C2
T1_N3		C1
&lt;/pre&gt;
정규화된 형태에서 데이터를 추출하면 우리가 데이터를 인식하는 방법과 달라서 대단히 불편하게 느끼게 됩니다. 이런 이유 때문에 비정규화의 유혹이 생길 수 있습니다. (엄격하게 말하면 위의 예는 제 1 정규형에 해당합니다)
&lt;p/&gt;
즉 &lt;b&gt;비정규화란 &quot;우리가 데이터를 인식하는 방식 그대로&quot; 표현하고자 하는 욕구를 의미&lt;/b&gt;한다고 할 수 있습니다. 비정규화를 하면 쿼리가 간단해지는 것도 이런 이유 때문입니다. 더 정확하게 말하면 우리 눈에 간단해보이는거죠. 물론 성능을 위한 적절한 비정규화는 삶의 양념같은 역할을 하기도 합니다. 너무 빡빡한 삶은 재미가 없잖아요? ^^;
&lt;p/&gt;
다행스러운 것은 오라클이 제공하는 (비교적 최신의) 기능들을 잘 이용하면 관계형으로 저장된 데이터를 비교적 간단하게 우리가 원하는 비정규화된 형태로 추출할 수 있다는 것입니다. 
&lt;p/&gt;
간단한 예제를 볼텐데요, 우선 다음과 같이 테이블 T1과 총 6개의 인덱스(Primary Key 포함)을 만듭니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
create table t1(
	c1 number primary key,
	c2 number,
	c3 number,
	c4 number
);

create index t1_n1 on t1(c1, c2);
create index t1_n2 on t1(c2, c3);
create index t1_n3 on t1(c3);
create index t1_n4 on t1(c3, c1, c2);
create index t1_n5 on t1(c1, c2, c4);
&lt;/pre&gt;
우리의 목적은 다음과 같은 표 형태로 &lt;b&gt;인덱스별, 컬럼별 순서와 Unique 여부&lt;/b&gt;를 보는 것입니다. U가 붙으면 Unique이고, T1_N4의 경우에는 (C3, C1, C2)로 이루어져 있다는 의미입니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
Index_name			 C1   C2   C3   C4
-----------          --   --   --   --
SYS_C0016792         1U
T1_N1                1    2
T1_N2                     1    2
T1_N3                          1
T1_N4                2    3    1
T1_N5                1    2         3
&lt;/pre&gt;
위의 같은 표현 양식에는 일반적으로 표현하기 힘든 &lt;b&gt;두 가지 쿼리 패턴&lt;/b&gt;이 숨어 있습니다.
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Missing Value 채우기: &lt;/b&gt;인덱스 T1_N1의 경우를 보면 컬럼 (C1, C2)로 구성되어 있습니다. 하지만 전체 컬럼은 (C1, C2, C3, C4)로 이루어져 있죠. 이때 C3, C4가 Missing Value가 됩니다. Missing Value까지 다 포함해야 위와 같은 형태의 결과를 얻을 수 있습니다.
&lt;li&gt;&lt;b&gt;Row 값을 Column으로 변환하기: &lt;/b&gt;인덱스 T1_N1의 경우를 보면 (C1(1), C2(2), C3(X), C4(X)) 로 구성됩니다. &lt;b&gt;Missing Value 채우기&lt;/b&gt;를 통해 데이터를 만들었다고 하더라도 이 데이터들을 Row로 되어 있기 때문에 컬럼 형태로 변환해야 합니다. 
&lt;/ul&gt;
위의 두 가지 요구 사항은 매우 보편적으로 발생합니다. 최신 버전의 오라클에서는 &lt;b&gt;Partition Outer Join&lt;/b&gt;과 &lt;b&gt;Listagg&lt;/b&gt; 함수를 이용하면 비교적 간단하게 구현할 수 있습니다. 그렇지 않다면 좀 더 수고스러운 과정을 거쳐야할 것이구요. 
&lt;p/&gt;
우선 &lt;b&gt;Missing Value를 채우는 가장 보편적인 방법은 값을 중복해서 복사&lt;/b&gt;하는 것입니다. 가령 다음과 같이 인덱스별, 컬럼별로 모든 조합이 다 나오도록 중복된 데이터 셋을 만들면 됩니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
INDEX_NAME           COLUMN_NAME
-------------------- --------------------
SYS_C0016792         C1
SYS_C0016792         C2
SYS_C0016792         C3
SYS_C0016792         C4
T1_N1                C1
T1_N1                C2
T1_N1                C3
T1_N1                C4
T1_N2                C1
T1_N2                C2
T1_N2                C3
T1_N2                C4
T1_N3                C1
T1_N3                C2
T1_N3                C3
T1_N3                C4
T1_N4                C1
T1_N4                C2
T1_N4                C3
T1_N4                C4
T1_N5                C1
T1_N5                C2
T1_N5                C3
T1_N5                C4
&lt;/pre&gt;
위와 같은 형태의 데이터를 만드는 가장 보편적인 방법은 복사를 위한 피봇(Pivot) 테이블을 이용하는 것입니다. 아래와 같이 DBA_TAB_COLUMNS 뷰를 피봇 테이블로 활용할 수 있습니다. DBA_TAB_COLUMNS와 DBA_INDEXES 뷰는 정상적인 조인이 불가능합니다. DBA_INDEXES 뷰에는 컬럼 정보가 없기 때문입니다. 따라서 &lt;b&gt;Cartesian Join&lt;/b&gt;이 발생하게 되고 그로 인해 인덱스별로 컬럼 수만큼 복사가 발생하게 됩니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
-- pivot table
select 
	i.index_name,
	i.uniqueness,
	tc.column_id,
	tc.column_name
from
	dba_tab_columns tc,
	dba_indexes i
where
	tc.owner = &#039;TPACK&#039;
	and tc.table_name = &#039;T1&#039;
	and tc.owner = i.owner
	and tc.table_name = i.table_name  
        -- 컬럼에 대한 조인 필터 없음 ==&gt; Cartesian Join
order by
	i.index_name, tc.column_id
;

-- 그 덕분에 다음과 같이 복사가 이루어짐
INDEX_NAME           UNIQUENES  COLUMN_ID COLUMN_NAME
-------------------- --------- ---------- --------------------
SYS_C0016792         UNIQUE             1 C1
SYS_C0016792         UNIQUE             2 C2
SYS_C0016792         UNIQUE             3 C3
SYS_C0016792         UNIQUE             4 C4
T1_N1                NONUNIQUE          1 C1
T1_N1                NONUNIQUE          2 C2
T1_N1                NONUNIQUE          3 C3
T1_N1                NONUNIQUE          4 C4
T1_N2                NONUNIQUE          1 C1
T1_N2                NONUNIQUE          2 C2
T1_N2                NONUNIQUE          3 C3
T1_N2                NONUNIQUE          4 C4
T1_N3                NONUNIQUE          1 C1
T1_N3                NONUNIQUE          2 C2
T1_N3                NONUNIQUE          3 C3
T1_N3                NONUNIQUE          4 C4
T1_N4                NONUNIQUE          1 C1
T1_N4                NONUNIQUE          2 C2
T1_N4                NONUNIQUE          3 C3
T1_N4                NONUNIQUE          4 C4
T1_N5                NONUNIQUE          1 C1
T1_N5                NONUNIQUE          2 C2
T1_N5                NONUNIQUE          3 C3
T1_N5                NONUNIQUE          4 C4
&lt;/pre&gt;
Missing Value를 채운 후, 그 데이터를 DBA_IND_COLUMNS 뷰와 조인하면 우리가 원하는 완전한 형태의 정보를 얻을 수 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
select
	c.index_name,
	decode(ic.column_position,null,&#039;&#039;,
		decode(c.uniqueness,&#039;UNIQUE&#039;,&#039;U&#039;,&#039;&#039;)) as is_unique,
	c.column_name,
	c.column_id,
	ic.column_position
from
	(
	select 
		i.table_owner,
		i.table_name,
		i.index_name,
		i.uniqueness,
		tc.column_id,
		tc.column_name
	from
		dba_tab_columns tc,
		dba_indexes i
	where
		tc.owner = &#039;TPACK&#039;
		and tc.table_name = &#039;T1&#039;
		and tc.owner = i.owner
		and tc.table_name = i.table_name
	order by
		i.index_name, tc.column_id
	) c,
	dba_ind_columns ic
where
	c.table_owner = ic.table_owner(+)
	and c.table_name = ic.table_name(+)
	and c.index_name = ic.index_name(+)
	and c.column_name = ic.column_name(+)
order by
	c.index_name, c.column_id
;

INDEX_NAME           I COLUMN_NAME           COLUMN_ID COLUMN_POSITION
-------------------- - -------------------- ---------- ---------------
SYS_C0016792         U C1                            1               1
SYS_C0016792           C2                            2
SYS_C0016792           C3                            3
SYS_C0016792           C4                            4
T1_N1                  C1                            1               1
T1_N1                  C2                            2               2
T1_N1                  C3                            3
T1_N1                  C4                            4
T1_N2                  C1                            1
T1_N2                  C2                            2               1
T1_N2                  C3                            3               2
T1_N2                  C4                            4
T1_N3                  C1                            1
T1_N3                  C2                            2
T1_N3                  C3                            3               1
T1_N3                  C4                            4
T1_N4                  C1                            1               2
T1_N4                  C2                            2               3
T1_N4                  C3                            3               1
T1_N4                  C4                            4
T1_N5                  C1                            1               1
T1_N5                  C2                            2               2
T1_N5                  C3                            3
T1_N5                  C4                            4               3
&lt;/pre&gt;
이제 남은 일은 Row로 존재하는 데이터를 Column 형태로 표현하는 것입니다. 아래와 같이 &lt;b&gt;DECODE 함수와 MAX 함수를 조합&lt;/b&gt;하면 완전한 형태의 피보팅(Pivoting)이 이루어집니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
-- pivoting and decode
col col_list format a50
with x as (
	select
		c.index_name,
		decode(ic.column_position,null,&#039;&#039;,
			decode(c.uniqueness,&#039;UNIQUE&#039;,&#039;U&#039;,&#039;&#039;)) as is_unique,
		c.column_name,
		c.column_id,
		ic.column_position
	from
		(
		select 
			i.table_owner,
			i.table_name,
			i.index_name,
			i.uniqueness,
			tc.column_id,
			tc.column_name
		from
			dba_tab_columns tc,
			dba_indexes i
		where
			tc.owner = &#039;TPACK&#039;
			and tc.table_name = &#039;T1&#039;
			and tc.owner = i.owner
			and tc.table_name = i.table_name
		order by
			i.index_name, tc.column_id
		) c,
		dba_ind_columns ic
	where
		c.table_owner = ic.table_owner(+)
		and c.table_name = ic.table_name(+)
		and c.index_name = ic.index_name(+)
		and c.column_name = ic.column_name(+)
	order by
		c.index_name, c.column_id
)
select
	x.index_name,
	rpad(max(decode(x.column_id,1,nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique)),5,&#039; &#039;)||
	rpad(max(decode(x.column_id,2,nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique)),5,&#039; &#039;)||
	rpad(max(decode(x.column_id,3,nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique)),5,&#039; &#039;)||
	rpad(max(decode(x.column_id,4,nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique)),5,&#039; &#039;)
		as col_list
from 
	x
group by 
	index_name
;


INDEX_NAME           COL_LIST
-------------------- --------------------------------------------------
SYS_C0016792         1U
T1_N1                1    2
T1_N2                     1    2
T1_N3                          1
T1_N4                2    3    1
T1_N5                1    2         3
&lt;/pre&gt;
Oracle 11gR2에서는 &lt;b&gt;LISTAGG&lt;/b&gt; 함수를 이용하면 훨씬 간단한 방법으로 구현할 수 있습니다. 그 이전 버전이라면 &lt;b&gt;XMLAGG&lt;/b&gt; 함수를 사용할 수 있을 것입니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
-- pivoting and listagg
col col_list format a50
with x as (
	select
		c.index_name,
		decode(ic.column_position,null,&#039;&#039;,
			decode(c.uniqueness,&#039;UNIQUE&#039;,&#039;U&#039;,&#039;&#039;)) as is_unique,
		c.column_name,
		c.column_id,
		ic.column_position
	from
		(
		select 
			i.table_owner,
			i.table_name,
			i.index_name,
			i.uniqueness,
			tc.column_id,
			tc.column_name
		from
			dba_tab_columns tc,
			dba_indexes i
		where
			tc.owner = &#039;TPACK&#039;
			and tc.table_name = &#039;T1&#039;
			and tc.owner = i.owner
			and tc.table_name = i.table_name
		order by
			i.index_name, tc.column_id
		) c,
		dba_ind_columns ic
	where
		c.table_owner = ic.table_owner(+)
		and c.table_name = ic.table_name(+)
		and c.index_name = ic.index_name(+)
		and c.column_name = ic.column_name(+)
	order by
		c.index_name, c.column_id
)
select
	x.index_name,
	listagg(rpad(nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique, 5, &#039; &#039;), &#039;&#039;) 
		within group (order by x.column_id) 
		as col_list
from 
	x
group by 
	x.index_name
;

INDEX_NAME           COL_LIST
-------------------- --------------------------------------------------
SYS_C0016792         1U
T1_N1                1    2
T1_N2                     1    2
T1_N3                          1
T1_N4                2    3    1
T1_N5                1    2         3
&lt;/pre&gt;
&lt;b&gt;Partition Outer Join을 사용하면 Cartesian Join을 사용할 필요없이 훨씬 효율적으로 Missing Value를 채울 수&lt;/b&gt; 있습니다. 
&lt;p/&gt;
아래 결과를 보면 DBA_TAB_COLUMNS 뷰와 DBA_IND_COLUMNS 뷰를 Outer Join하는 것만으로 Missing Value를 채울 수가 없다는 것을 알 수 있습니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
-- what is partition outer join?
select
	ic.index_name,
	tc.column_name,
	ic.column_position
from
	(select
		column_id,
		column_name
	from 
		dba_tab_columns
	where
		owner = &#039;TPACK&#039;
		and table_name = &#039;T1&#039;
	) tc
	left outer join
	(select 
		index_name,
		column_position,
		column_name
	from
		dba_ind_columns
	where
		table_owner = &#039;TPACK&#039;
		and table_name = &#039;T1&#039;
	) ic
	on (tc.column_name = ic.column_name)
;

INDEX_NAME           COLUMN_NAME          COLUMN_POSITION
-------------------- -------------------- ---------------
SYS_C0016793         C1                                 1
T1_N1                C1                                 1
T1_N1                C2                                 2
T1_N2                C2                                 1
T1_N2                C3                                 2
T1_N3                C3                                 1
T1_N4                C3                                 1
T1_N4                C1                                 2
T1_N4                C2                                 3
T1_N5                C1                                 1
T1_N5                C2                                 2
T1_N5                C4                                 3
&lt;/pre&gt;
하지만 다음과 같이 &lt;b&gt;Partition Outer Join&lt;/b&gt;을 사용하면 &lt;b&gt;DBA_IND_COLUMNS.INDEX_NAME 별로 그룹핑해서 Outer Join&lt;/b&gt;을 수행합니다. 따라서 Missing Value를 완벽하게 채울 수 있습니다. 
&lt;pre class=&quot;brush: sql; :&quot;&gt;
select
	ic.index_name,
	tc.column_name,
	ic.column_position
from
	(select
		column_id,
		column_name
	from 
		dba_tab_columns
	where
		owner = &#039;TPACK&#039;
		and table_name = &#039;T1&#039;
	) tc
	left outer join
	(select 
		index_name,
		column_position,
		column_name
	from
		dba_ind_columns
	where
		table_owner = &#039;TPACK&#039;
		and table_name = &#039;T1&#039;
	) ic
	partition by (ic.index_name)   -- DBA_IND_COLUMNS.INDEX_NAME 별로 그룹핑해서 아우터 조인
	on (tc.column_name = ic.column_name)
;


INDEX_NAME           COLUMN_NAME          COLUMN_POSITION
-------------------- -------------------- ---------------
SYS_C0016793         C1                                 1
SYS_C0016793         C2
SYS_C0016793         C3
SYS_C0016793         C4
T1_N1                C1                                 1
T1_N1                C2                                 2
T1_N1                C3
T1_N1                C4
T1_N2                C1
T1_N2                C2                                 1
T1_N2                C3                                 2
T1_N2                C4
T1_N3                C1
T1_N3                C2
T1_N3                C3                                 1
T1_N3                C4
T1_N4                C1                                 2
T1_N4                C2                                 3
T1_N4                C3                                 1
T1_N4                C4
T1_N5                C1                                 1
T1_N5                C2                                 2
T1_N5                C3
T1_N5                C4                                 3
&lt;/pre&gt;
위에서 얻은 결과를 &lt;b&gt;LISTAGG&lt;/b&gt; 함수를 이용하면 원하던 포맷의 결과를 얻을 수 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
-- partition outer join &amp; listagg
col col_list format a50
with x as (
	select
		i.index_name, 
		tc.column_id,
		ic.column_position,
		tc.column_name,
		decode(ic.column_position,null,&#039;&#039;,
			decode(i.uniqueness,&#039;UNIQUE&#039;,&#039;U&#039;,&#039;&#039;)) as is_unique
	from 
		(
			(
			select
				column_id,
				column_name
			from 
				dba_tab_columns
			where
				owner = &#039;TPACK&#039;
				and table_name = &#039;T1&#039;
			) tc
			left outer join
			(select 
				index_name,
				column_position,
				column_name
			from
				dba_ind_columns
			where
				table_owner = &#039;TPACK&#039;
				and table_name = &#039;T1&#039;
			) ic
			partition by (ic.index_name) 
			on (tc.column_name = ic.column_name)
			left outer join
			(select
				index_name,
				uniqueness
			from
				dba_indexes
			where
				table_owner = &#039;TPACK&#039;
				and table_name = &#039;T1&#039;
			) i
			on (i.index_name = ic.index_name)
		)
	order by
		ic.index_name, tc.column_id
)
select
	x.index_name,
	listagg(rpad(nvl(x.column_position||&#039;&#039;,&#039; &#039;)||x.is_unique, 5, &#039; &#039;), &#039;&#039;) 
		within group (order by x.column_id) 
		as col_list
from 
	x
group by
	x.index_name
;

INDEX_NAME           COL_LIST
-------------------- --------------------------------------------------
SYS_C0016792         1U
T1_N1                1    2
T1_N2                     1    2
T1_N3                          1
T1_N4                2    3    1
T1_N5                1    2         3
&lt;/pre&gt;
적다보니 너무 길어졌네요. &lt;b&gt;오라클이 제공하는 기능을 잘 이용하면 그다지 어렵지 않게(?) 정규화된 관계 모델로부터 우리가 인식하는 형식의 데이터로 표현&lt;/b&gt;할 수 있다는 정도의 의도로 봐주시면 되겠습니다. &lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-361-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/361&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<category>listagg</category>
			<category>Partition Outer Join</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/361</guid>
			<comments>http://ukja.tistory.com/361#entry361comment</comments>
			<pubDate>Tue, 07 Dec 2010 14:32:31 +0900</pubDate>
		</item>
		<item>
			<title>Column의 값을 Row로 변환하기</title>
			<link>http://ukja.tistory.com/360</link>
			<description>가장 과격한 형태의 비정규화 중 하나가 여러 개의 로우로 저장해야할 값들을 하나의 컬럼 값으로 병합(Concatenation)해서 저장하는 것입니다. 가령 이렇게 저장되어 있어야할 데이터를
&lt;pre class=&quot;brush: sql; &quot;&gt;
        C1
----------
        11
         2
       345
        89
      3334
        12
&lt;/pre&gt;
이렇게 저장하는 거죠.
&lt;pre class=&quot;brush: sql; &quot;&gt;
11,2,345,89,3334,12
&lt;/pre&gt;
이유야 어쨌든, 이렇게 저장된 데이터를 SQL에서 사용하기는 매우 어렵습니다. SQL은 기본적으로 하나의 데이터가 하나의 로우에 저장되어 있다는 전제하에서 가장 이상적으로 동작하기 때문입니다.
&lt;p/&gt;
아마 데이터를 위와 같이 저장한 것은 이런 쿼리 패턴을 염두에 두었기 때문일 것입니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
select ... from where id in (11,2,345,89,3334,12);
&lt;/pre&gt;
즉, IN 을 이용한 동적인 쿼리(Dynamic Query)를 생성해서 사용하게 됩니다. 과감한 비정규화를 수행한 대신 하드 파스의 부담을 안게 됩니다. 그리고 집합으로서 처리하는 것이 불가능하기 때문에 비슷한 모양의 쿼리를 반복적으로 수행하게 됩니다. 데이터 정합성이나 기타 모델링 관점에서의 고려는 물론 이미 배제된 상태구요. 
&lt;p/&gt;
위와 같이 저장된 데이터(11,2,345,89,3334,12)를 정상적인 SQL을 통해서 사용하려면 1) 값을 &quot;,&quot; 기준으로 분리한 다음 2) 그 값들을 로우의 형태로 바꾸어 주어야 합니다. 이때 보편적으로 사용되는 방법이 &lt;b&gt;피봇 테이블(대용량데이터베이스 책에서는 COPY_T 라는 이름으로 사용)을 사용&lt;/b&gt;해서 값을 여러 개 복사해서 로우로 만든 다음 각 로우에서 값을 추출하는 방법입니다. 다음과 같이 하는거죠.
&lt;pre class=&quot;brush: sql; &quot;&gt;
Row#1 : 11,2,345,89,3334,12 --&gt; 11 추출
Row#2 : 11,2,345,89,3334,12 --&gt; 2 추출
Row#3 : 11,2,345,89,3334,12 --&gt; 345 추출
Row#4 : 11,2,345,89,3334,12 --&gt; 89 추출
Row#5 : 11,2,345,89,3334,12 --&gt; 3334 추출
Row#6 : 11,2,345,89,3334,12 --&gt; 12 추출
&lt;/pre&gt;
위의 개념을 SQL 코드로 구현해보면 다음과 같습니다. 우선 다음과 같이 테이블을 만듭니다. 테이블 T2가 비정규화가 감행된 형태로 들어가있죠. 테이블 T1과 T2를 조인하는 것이 우리의 목표입니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
create table t1(c1 number);

insert into t1 values(11);
insert into t1 values(2);
insert into t1 values(345);
insert into t1 values(89);
insert into t1 values(3334);
insert into t1 values(12);

create table t2(id_array	varchar2(4000));
insert into t2 values(&#039;11,2,345&#039;);
insert into t2 values(&#039;89,3334,12&#039;);

&lt;/pre&gt;
우선 다음과 같이 PIVOT 테이블을 이용해 데이터를 카피하면서 SUBSTR을 통해 &quot;,&quot; 문자가 첫번째에 오는 경우만을 추출합니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; var b1 varchar2(100);
SQL&gt; exec :b1 := &#039;,&#039;||&#039;11,2,345,89,3334,12&#039;;

PL/SQL procedure successfully completed.

SQL&gt; select
  2  	     str,
  3  	     bi,
  4  	     ei,
  5  	     substr(x.str, bi+1, decode(ei,-1,length(x.str), ei-bi)) as id
  6  from
  7  	     (select
  8  		     rnum,
  9  		     substr(:b1, rnum) as str,
 10  		     instr(substr(:b1, rnum), &#039;,&#039;) as bi,
 11  		     instr(substr(:b1, rnum), &#039;,&#039;, 2)-1 as ei
 12  	     from
 13  		     (select level as rnum from dual
 14  		     connect by level &lt;= 100) pivot
 15  	     ) x
 16  where
 17  	     x.bi = 1
 18  ;

STR                                    BI         EI ID
------------------------------ ---------- ---------- ----------
,11,2,345,89,3334,12                    1          3 11
,2,345,89,3334,12                       1          2 2
,345,89,3334,12                         1          4 345
,89,3334,12                             1          3 89
,3334,12                                1          5 3334
,12                                     1         -1 12
&lt;/pre&gt;
위의 쿼리에서 얻는 BI(Begin Index), EI(End Index) 값을 이용해서 다음과 같이 T1에서 해당하는  값을 구할 수 있습니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select
  2  	     *
  3  from
  4  	     t1,
  5  	     (select
  6  		     substr(x.str, bi+1, decode(ei,-1,length(x.str), ei-bi)) as id
  7  	     from
  8  		     (select
  9  			     rnum,
 10  			     substr(:b1, rnum) as str,
 11  			     instr(substr(:b1, rnum), &#039;,&#039;) as bi,
 12  			     instr(substr(:b1, rnum), &#039;,&#039;, 2)-1 as ei
 13  		     from
 14  			     (select level as rnum from dual
 15  			     connect by level &lt;= 100) pivot
 16  		     ) x
 17  	     where
 18  		     x.bi = 1
 19  	     ) y
 20  where
 21  	     t1.c1 = y.id
 22  ;

        C1 ID
---------- ----------
        11 11
         2 2
       345 345
        89 89
      3334 3334
        12 12
&lt;/pre&gt;
위의 방법을 테이블 T2에 대해 적용하면 다음과 같이 테이블 T1과  테이블 T2를 조인할 수 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select
  2  	     *
  3  from
  4  	     t1,
  5  	     (select
  6  		     substr(x.str, bi+1, decode(ei,-1,length(x.str), ei-bi)) as id
  7  	     from
  8  		     (select
  9  			     rnum,
 10  			     substr(t2.id, rnum) as str,
 11  			     instr(substr(t2.id, rnum), &#039;,&#039;) as bi,
 12  			     instr(substr(t2.id, rnum), &#039;,&#039;, 2)-1 as ei
 13  		     from
 14  			     (select level as rnum from dual
 15  			     connect by level &lt;= 100) pivot,
 16  			     (select &#039;,&#039;||id_array as id from t2) t2
 17  		     ) x
 18  	     where
 19  		     x.bi = 1
 20  	     ) y
 21  where
 22  	     t1.c1 = y.id
 23  ;

        C1 ID
---------- ----------
        11 11
         2 2
       345 345
        89 89
      3334 3334
        12 12
&lt;/pre&gt;
PIVOT 테이블을 이용해서 데이터를 카피하는 방식은 일단 이해하기가 어렵고, 둘째 테이블 T2를 여러번 읽어야 하기 때문에 성능 면에서도 유리하다고 보기 어렵습니다. 
&lt;p/&gt;
그래서 개인적으로는 아래와 같은 방법이 더 좋다고 생각합니다. 아래와 같은 방법이란 &lt;b&gt;테이블 펑션을 이용&lt;/b&gt;하는 것입니다.
&lt;p/&gt;
아래와 같이 문자열을 받아서 로우 형태로 리터하는 테이블 펑션을 만듭니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; create or replace type varchar2_array is table of varchar2(100);
  2  /

Type created.

SQL&gt; -- table function
SQL&gt; create or replace function get_id(p_list in varchar2)
  2  return varchar2_array
  3  pipelined
  4  is
  5  	     v_temp	     varchar2(2000);
  6  	     bi 		     number := 0;
  7  	     ei 		     number := 0;
  8  
  9  begin
 10  	     if substr(p_list, 1, 1) &lt;&gt; &#039;,&#039; then
 11  		     v_temp := &#039;,&#039; || p_list;
 12  	     else
 13  		     v_temp := p_list;
 14  	     end if;
 15  
 16  	     loop
 17  		     bi := instr(p_list, &#039;,&#039;, ei+1, 1);
 18  		     ei := instr(p_list, &#039;,&#039;, ei+1, 2)-1;
 19  
 20  		     if ei &gt; 0 then
 21  			     pipe row(substr(v_temp, bi+1, ei-bi));
 22  		     else
 23  			     pipe row(substr(v_temp, bi+1));
 24  		     end if;
 25  
 26  		     exit when ei &lt; 0;
 27  	     end loop
 28  
 29  	     return;
 30  
 31  end get_id;
 32  /

Function created.
&lt;/pre&gt;
결과는 아래와 같습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select * from table(get_id(:b1));

COLUMN_VALUE
--------------------------------------------------------------------------------
11
2
345
89
3334
12
&lt;/pre&gt;
위에서 만든 테이블 펑션을 아래와 같이 사용하면 테이블 T1과 테이블 T2를 조인할 수 있습니다. PIVOT 테이블을 사용한 것과 동일한 결과를 얻을 수 있죠.
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select
  2  	     *
  3  from
  4  	     t1,
  5  	     (select
  6  		     column_value as id
  7  	      from
  8  		     t2, table(get_id(&#039;,&#039;||t2.id_array)) -- 조인 방식 유의
  9  	     ) y
 10  where
 11  	     t1.c1 = y.id
 12  ;

        C1 ID
---------- ----------
        11 11
         2 2
       345 345
        89 89
      3334 3334
        12 12
&lt;/pre&gt;
이외에도 여러 가지 방법이 있을텐데요. 결국 무리한 비정규화의 결과는 무리한 SQL 문장이 되는 셈입니다.
&lt;p/&gt;
우리가 &lt;b&gt;멋진 SQL 문장이다, 화려한 SQL 문장이다라고 할때는, 사실은 그 이면에는 잘못된 모델링으로 인해 발생한 불필요하게 복잡한 SQL 문장인 경우도 있다&lt;/b&gt;는 말이 됩니다. 소프트웨어 공학에서는 &quot;데이터 구조가 정교하면 코드가 간단해지고, 데이터 구조가 단순하면 코드가 복잡해진다&quot;라고 하죠. 
&lt;p/&gt;
가장 중요한 것은 모델링, 그 다음이 SQL 문장이라고 볼 수 있겠습니다.


&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-360-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/360&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/360</guid>
			<comments>http://ukja.tistory.com/360#entry360comment</comments>
			<pubDate>Fri, 03 Dec 2010 11:40:00 +0900</pubDate>
		</item>
		<item>
			<title>Recursive Subquery Factoring의 한가지 활용 예</title>
			<link>http://ukja.tistory.com/359</link>
			<description>Oracle 11gR2부터 &lt;b&gt;Recursive Subquery Factoring&lt;/b&gt;이라는 기능을 제공합니다. 이 기능을 이용하면 Connect By 구문을 대신할 수  있죠. 아래에 간단한 사용법이 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt;  select lpad(&#039; &#039;, 2 * level - 2, &#039; &#039;) || ename as ename
  2        , empno
  3        , mgr
  4        , level
  5     from emp
  6  connect by mgr = prior empno
  7    start with mgr is null
  8  /
&lt;/pre&gt;

&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; with emps (ename,empno,mgr,lvl) as
  2  ( select ename
  3         , empno
  4         , mgr
  5         , 1
  6      from emp
  7     where mgr is null
  8     union all
  9    select emp.ename
 10         , emp.empno
 11         , emp.mgr
 12         , emps.lvl + 1
 13      from emp
 14           join emps on (emp.mgr = emps.empno)
 15  ) search depth first by empno set a
 16  select lpad(&#039; &#039;, 2 * lvl - 2, &#039; &#039;) || ename as ename
 17       , empno
 18       , mgr
 19       , lvl
 20    from emps
 21    order by a
 22  /
&lt;/pre&gt;
굳이 Connect By로 잘 사용하고 있었던 것을 왜 다시 Recursive Subquery Factoring을 사용해야 하는지를 고민해보면 딱히 떠오르는 것이 없는데요. &lt;b&gt;다음과 같은 유형의 쿼리에서&lt;/b&gt; 유용하게 사용할 수 있을 것 같습니다.
&lt;p/&gt;
&lt;b&gt;1. &lt;/b&gt;다음과 같은 두 개의 테이블 T_MATERIAL과 T_COMPOSE가 있습니다. 테이블 T_MATERIAL은 &quot;약&quot;(material_type=Med) 또는 &quot;약의 성분&quot;(material_type=Mat) 데이터를 가지고 있습니다. 테이블 T_COMPOSE는 하나의 약이 어떤 하위 성분과 하위 약으로 이루어져 있는지의 관계를 나타냅니다. 하위 약은 다시 하위 약 또는 하위 성분을 가지므로 계층 구조가 됩니다. 그리고 각 하위 약 또는 하위 성분이 몇 %를 구성하고 있는지의 정보(contain_pct)를 가지고 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; create table t_material(
  2  	material_id		number,
  3  	material_name	varchar2(10),
  4  	material_type	varchar2(3) -- Med = medicine, Mat = material
  5  );

Table created.

SQL&gt; 
SQL&gt; create table t_compose (
  2  	medicine_id			number,
  3  	material_id			number,
  4  	contain_pct			number
  5  );

Table created.
&lt;/pre&gt;
이제 다음과 같이 데이터를 생성합니다.
&lt;pre class=&quot;brush: sql; &quot;&gt; 
SQL&gt; begin
  2  	insert into t_material values(1, &#039;medicine1&#039;, &#039;Med&#039;);
  3  	insert into t_material values(2, &#039;medicine2&#039;, &#039;Med&#039;);
  4  	insert into t_material values(3, &#039;material1&#039;, &#039;Mat&#039;);
  5  	insert into t_material values(4, &#039;medicine3&#039;, &#039;Med&#039;);
  6  	insert into t_material values(5, &#039;material2&#039;, &#039;Mat&#039;);
  7  	insert into t_material values(6, &#039;medicine4&#039;, &#039;Med&#039;);
  8  end;
  9  /

PL/SQL procedure successfully completed.

SQL&gt; 
SQL&gt; begin
  2  	insert into t_compose values(1, 2, 0.3); -- Med
  3  		insert into t_compose values(2, 6, 0.5);
  4  			insert into t_compose values(6, 3, 0.8);
  5  			insert into t_compose values(6, 5, 0.2);
  6  		insert into t_compose values(2, 5, 0.5);
  7  	insert into t_compose values(1, 3, 0.3); -- Mat
  8  	insert into t_compose values(1, 4, 0.2); -- Med
  9  		insert into t_compose values(4, 3, 0.7);
 10  		insert into t_compose values(4, 5, 0.3);
 11  	insert into t_compose values(1, 5, 0.2); -- Mat
 12  end;
 13  /

PL/SQL procedure successfully completed.
&lt;/pre&gt;
1번 약은 (2번 약 30% + 3번 성분 30% + 4번 약 20% + 5번 성분 20%) 으로 이루어져있죠.  2번 약은 (6번 약 50% + 5번 약 50%)로 이루어져 있고, 6번 약은 (3번 성분 80% + 5번 성분 20%)로 이루어져 있습니다. 이런 식으로 계층 구조를 이루고 있습니다.
&lt;p/&gt;
계층 구조를 지니면서 성분의 함량(contain_pct) 정보가 존재합니다. 여기서 이런 쿼리가 필요해집니다. &lt;b&gt;1번 약을 구성하는 각 성분의 함량은 어떻게 되는가?&lt;/b&gt; 즉, 1번 약을 구성하는 성분인 3번 성분(material1)과 5번 성분(material2)는 각각 몇 %인가?
&lt;p/&gt;
위와 같은 쿼리가 까다로운 것은 계층 구조를 따라 모든 노드의 값(여기서는 contain_pct)를 알아야하기 때문입니다. 간단하게 계산해보면 3번 성분(material1)의 함량을 구하려면 계층 구조를 따라가면서 &lt;b&gt;0.3*0.5*0.8 + 0.3 + 0.2*0.7 = 0.56 = 56%&lt;/b&gt;와 같은 계산이 필요합니다.
&lt;p/&gt;
Connect By 구문에서는 현재 값과 이전 값(부모 값)만을 알 수 있습니다. 이 한계를 극복하기 위해 나온 것이 &lt;b&gt;SYS_CONNECT_BY_PATH&lt;/b&gt;같은 함수죠. 아래와 같이 각 노드의 모든 함량 정보를 얻을 수 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; col pholder format a10
SQL&gt; col pct_path format a20
SQL&gt; select
  2  	lpad(&#039;-&#039;,level,&#039;-&#039;) as pholder,
  3  	medicine_id,
  4  	material_id,
  5  	contain_pct,
  6  	sys_connect_by_path(contain_pct,&#039;/&#039;) as pct_path
  7  from
  8  	t_compose
  9  connect by medicine_id = prior material_id
 10  start with medicine_id = 1
 11  ;

PHOLDER    MEDICINE_ID MATERIAL_ID CONTAIN_PCT PCT_PATH
---------- ----------- ----------- ----------- --------------------
-                    1           2          .3 /.3
--                   2           5          .5 /.3/.5
--                   2           6          .5 /.3/.5
---                  6           3          .8 /.3/.5/.8
---                  6           5          .2 /.3/.5/.2
-                    1           3          .3 /.3
-                    1           4          .2 /.2
--                   4           3          .7 /.2/.7
--                   4           5          .3 /.2/.3
-                    1           5          .2 /.2

10 rows selected.
&lt;/pre&gt;
위의 값을 실제로 계산하려면 다음과 같이 별도의 함수를 이용한 로직이 필요하게 됩니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; create or replace function get_total_pct(pct_path in varchar2)
  2  return number
  3  is
  4  	v_idx1		number := 0;
  5  	v_idx2		number;
  6  	v_temp		number;
  7  	v_total		number := 1;
  8  begin
  9  	v_idx1 := instr(pct_path, &#039;/&#039;);
 10  
 11  	loop
 12  
 13  		v_idx2 := instr(pct_path, &#039;/&#039;, v_idx1+1);
 14  		if v_idx2 = 0 then
 15  			v_idx2 := length(pct_path)+1;
 16  		end if;
 17  
 18  		v_temp := to_number(substr(pct_path, v_idx1+1, v_idx2-v_idx1-1));
 19  		v_total := v_total * v_temp;
 20  
 21  		v_idx1 := v_idx2;
 22  
 23  		exit when v_idx1 &gt; length(pct_path);
 24  
 25  	end loop;
 26  
 27  	return v_total;
 28  end;
 29  /

Function created.
&lt;/pre&gt;
CONNECT BY 구문과 SYS_CONNECT_BY_PATH 함수, 그리고 위에서 정의한 함수 GET_TOTAL_PCT를 이용하면 다음과 같이 원하는 값을 얻을 수 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; with c as (
  2  	select
  3  		material_id,
  4  		get_total_pct(sys_connect_by_path(contain_pct,&#039;/&#039;)) as comp_pct
  5  	from
  6  		t_compose
  7  	connect by medicine_id = prior material_id
  8  	start with medicine_id = 1
  9  )
 10  select
 11  	m.material_name,
 12  	sum(c.comp_pct) as total_pct
 13  from
 14  	c,
 15  	t_material m
 16  where
 17  	c.material_id = m.material_id
 18  	and m.material_type = &#039;Mat&#039;
 19  group by
 20  	m.material_name
 21  ;

MATERIAL_N  TOTAL_PCT
---------- ----------
material1         .56
material2         .44
&lt;/pre&gt;
(음... 더 멋진 방법이 있을 듯... )
&lt;p/&gt;
Recursive Subquery Factoring에서는 위의 작업을 보다 직관적으로 처리할 수 있습니다. 다음과 같이 부모의 값을 받아서 함량(contain_pct)을 계속 곱해가면 최종 자식 노드의 함량을 알 수 있죠. 그 값을 SUM 하면 함량의 합이 됩니다. 즉, &lt;b&gt;Recursive Subquery Factoring의 장점은 SYS_CONNECT_BY_PATH 같은 함수의 도움을 빌리지 않아도 모든 모드의 값을 이용할 수 있다는 것&lt;/b&gt;입니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; with recur_mat(comp_pct, material_id)
  2  as (
  3  	select
  4  		contain_pct,
  5  		material_id
  6  	from
  7  		t_compose
  8  	where
  9  		medicine_id = 1
 10  	union all
 11  	select
 12  		p.comp_pct * c.contain_pct,  -- 부모 * 현재 
 13  		c.material_id
 14  	from
 15  		recur_mat p,
 16  		t_compose c
 17  	where
 18  		c.medicine_id = p.material_id
 19  )
 20  select
 21  	m.material_name,
 22  	sum(r.comp_pct) as total_pct
 23  from
 24  	recur_mat r,
 25  	t_material m
 26  where
 27  	r.material_id = m.material_id
 28  	and m.material_type = &#039;Mat&#039;
 29  group by
 30  	m.material_name
 31  ;

MATERIAL_N  TOTAL_PCT
---------- ----------
material1         .56
material2         .44
&lt;/pre&gt;
아... 설명이 좀 구질구질했는데요. &lt;b&gt;Recursive Subquery Factoring&lt;/b&gt;을 이용함으로써 좀 더 작업이 간편해지는 몇 안되는 예제 중 하나라서 올려봅니다.
&lt;p/&gt;
앞으로 11gR2가 본격적으로 사용되면 활용 예제가 더 많이 소개될 것으로 기대합니다. 


&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-359-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/359&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<category>connect by</category>
			<category>recursive subquery factoring</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/359</guid>
			<comments>http://ukja.tistory.com/359#entry359comment</comments>
			<pubDate>Wed, 01 Dec 2010 17:46:16 +0900</pubDate>
		</item>
		<item>
			<title>오라클 실행 계획을 보는 새로운 방법</title>
			<link>http://ukja.tistory.com/358</link>
			<description>대부분의 오라클 클라이언트가 아래와 같은 포맷으로 실행 계획을 보여줍니다. 
&lt;p/&gt;
&lt;img src=&quot;http://t1.gstatic.com/images?q=tbn:ANd9GcQH4wVp2SQ6sk-DmGflnIuNp1Nn93w9HCjSC_Gs4DO79Uqm_gBU&quot;&gt;
&lt;p/&gt;
하지만 다음과 같은 &lt;b&gt;진짜 트리&lt;/b&gt; 모양으로 실행 계획을 보는 것이 더 편할 때도 있습니다.
&lt;p/&gt;
&lt;img src=&quot;http://t2.gstatic.com/images?q=tbn:ANd9GcQ6NKN-obO7cCzoJFiAPXNUXSFzUHP5v03dnUVX9eFLzIthAQJu8g&quot;&gt;
&lt;p/&gt;
아래 블로그 포스트를 보면 트리 모양으로 표현한 실행 계획의 가독성이 때로는 훨씬 높다는 것을 알 수 있습니다. (영어 해석 귀찮으신 분들은 그림만 보시면 됩니다. ^^)
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://iggyfernandez.wordpress.com/2010/11/27/sql-101-deep-left-trees-deep-right-trees-and-bushy-trees-oh-my/#comment-706&quot;&gt;SQL 101: Deep Left Trees, Deep Right Trees, and Bushy Trees! Oh, My!&lt;/a&gt;
&lt;/ul&gt;
흔히 온라인 쿼리는 &lt;b&gt;Left Deep 트리&lt;/b&gt;, 배치 쿼리는 &lt;b&gt;Right Deep 트리&lt;/b&gt; 형태를 따르는 경우가 많으며, 인라인 뷰를 사용하는 경우에는 &lt;b&gt;Bushy 트리&lt;/b&gt;로 유도할 수 있다는 식의 설명을 보는 경우가 있는데 위의 글에서 소개한 것과 같이 실행 계획 자체를 트리 모양으로 볼 수 있으면 좀 더 명확하게 이해할 수가 있겠군요.
&lt;p/&gt;
클라이언트 툴들이 좀 더 똑똑하고 비주얼해지면 좋겠습니다. 아니면 그런 툴들이 이미 있는데 제가 잘 모를 수도 있겠습니다.
&lt;p/&gt;
&lt;b&gt;PS)&lt;/b&gt; 아래 오동규님의 블로그 포스트를 같이 참조하시면 이해하는데 더 도움이 되겠습니다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://scidb.tistory.com/entry/Hash-%EC%A1%B0%EC%9D%B8%EC%9D%98-%ED%8A%9C%EB%8B%9D%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD&quot;&gt;Hash 조인의 튜닝시 주의사항(Work Area 의 튜닝)&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;http://scidb.tistory.com/entry/Hash-%EC%A1%B0%EC%9D%B8%EC%8B%9C-Bushy-tree-Plan&quot;&gt;Hash 조인시 Bushy tree Plan 유도하기
&lt;/ul&gt;

&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-358-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/358&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/358</guid>
			<comments>http://ukja.tistory.com/358#entry358comment</comments>
			<pubDate>Mon, 29 Nov 2010 19:04:07 +0900</pubDate>
		</item>
		<item>
			<title>조인 순서에 대한 간단한 테스트</title>
			<link>http://ukja.tistory.com/357</link>
			<description>조인 순서, 즉 &lt;b&gt;누가 드라이빙 테이블이 되어야 하느냐&lt;/b&gt;에 대한 간단하면서도 재미있는 테스트를 소개합니다.
&lt;p/&gt;
아래와 같이 마스터(T1) - 디테일(T2) 관계를 가지는 테이블이 있습니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select * from v$version where rownum = 1;

BANNER
--------------------------------------------------------------------------------
Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - Production


SQL&gt; create table t1(
  2  	     c1 number,
  3  	     c2 number,
  4  	     constraint t1_pk primary key (c1)
  5  );

Table created.

SQL&gt; create table t2(
  2  	     c1 number,
  3  	     c2 number,
  4  	     c3 number,
  5  	     constraint t2_pk primary key (c1, c2),
  6  	     constraint t2_fk foreign key (c1) references t1(c1)
  7  );

Table created.

SQL&gt; create index t2_n1 on t2(c3);

Index created.
&lt;/pre&gt;
마스터 T1은 10건입니다. 그리고 디테일 T2는 10,000건입니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt; 
SQL&gt; insert into t1
  2  select
  3  	     level,
  4  	     level
  5  from
  6  	     dual
  7  connect by level &lt;= 10
  8  ;

10 rows created.

SQL&gt; insert into t2
  2  select
  3  	     mod(level,10)+1,
  4  	     level,
  5  	     mod(level,1000)
  6  from
  7  	     dual
  8  connect by level &lt;= 10000
  9  ;

10000 rows created.

SQL&gt; exec dbms_stats.gather_table_stats(user, &#039;t1&#039;);

PL/SQL procedure successfully completed.

SQL&gt; exec dbms_stats.gather_table_stats(user, &#039;t2&#039;);

PL/SQL procedure successfully completed.
&lt;/pre&gt;
마스터 T1은 10건이고,  C3 = 1 에 해당하는 디테일 T2도 10건입니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select count(*) from t1;

  COUNT(*)
----------
        10

SQL&gt; select count(*) from t2 where c3 = 1;

  COUNT(*)
----------
        10
&lt;/pre&gt;
&lt;b&gt;여기서 질문!&lt;/b&gt; 두 테이블을 NL 조인으로 조인하는 경우 드라이빙 테이블은 무엇이 되어야 할까요?
&lt;ul&gt;
 &lt;li&gt;테이블 T1은 크기가 작으므로 T1이 드라이빙이 되어야 한다.
 &lt;li&gt;테이블 T2가 필터링이 좋으므로(10000건 중 10건) T2가 드라이빙이 되어야 한다.
 &lt;li&gt;둘다 실제 건수는 10건이므로 전혀 무관하다.
&lt;/ul&gt;
아래 결과를 보기전에 잠깐 생각을 해보시기 바랍니다...
&lt;p/&gt;
아래에 결과가 있습니다. 
&lt;pre class=&quot;brush: sql; &quot;&gt;
SQL&gt; select /*+ gather_plan_statistics
  2  		     leading(t1) use_nl(t2) index(t2) index(t2 t2(c3)) */
  3  	     t1.c1, t1.c2, t2.c2, t2.c3
  4  from
  5  	     t1, t2
  6  where
  7  	     t1.c1 = t2.c1
  8  	     and t2.c3 = 1
  9  ;


         C1         C2         C2         C3
---------- ---------- ---------- ----------
         2          2          1          1
         2          2       1001          1
         2          2       2001          1
         2          2       3001          1
         2          2       4001          1
         2          2       5001          1
         2          2       8001          1
         2          2       9001          1
         2          2       6001          1
         2          2       7001          1

10 rows selected.

-----------------------------------------------------------------------------------
| Id  | Operation                    | Name  | Starts | E-Rows | A-Rows | Buffers |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |       |      1 |        |     10 |     118 |
|   1 |  NESTED LOOPS                |       |      1 |        |     10 |     118 |
|   2 |   NESTED LOOPS               |       |      1 |     10 |    100 |      18 |
|   3 |    TABLE ACCESS FULL         | T1    |      1 |     10 |     10 |       8 |
|*  4 |    INDEX RANGE SCAN          | T2_N1 |     10 |     10 |    100 |      10 |
|*  5 |   TABLE ACCESS BY INDEX ROWID| T2    |    100 |      1 |     10 |     100 |
-----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;T2&quot;.&quot;C3&quot;=1)
   5 - filter(&quot;T1&quot;.&quot;C1&quot;=&quot;T2&quot;.&quot;C1&quot;)


SQL&gt; select /*+ gather_plan_statistics
  2  		     leading(t1) use_nl(t2) index(t2 t2(c1, c2)) */
  3  	     t1.c1, t1.c2, t2.c2, t2.c3
  4  from
  5  	     t1, t2
  6  where
  7  	     t1.c1 = t2.c1
  8  	     and t2.c3 = 1
  9  ;

        C1         C2         C2         C3
---------- ---------- ---------- ----------
         2          2          1          1
         2          2       1001          1
         2          2       2001          1
         2          2       3001          1
         2          2       4001          1
         2          2       5001          1
         2          2       6001          1
         2          2       7001          1
         2          2       8001          1
         2          2       9001          1

10 rows selected.


-----------------------------------------------------------------------------------
| Id  | Operation                    | Name  | Starts | E-Rows | A-Rows | Buffers |
-----------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |       |      1 |        |     10 |     278 |
|   1 |  NESTED LOOPS                |       |      1 |        |     10 |     278 |
|   2 |   NESTED LOOPS               |       |      1 |     10 |  10000 |      57 |
|   3 |    TABLE ACCESS FULL         | T1    |      1 |     10 |     10 |       8 |
|*  4 |    INDEX RANGE SCAN          | T2_PK |     10 |   1000 |  10000 |      49 |
|*  5 |   TABLE ACCESS BY INDEX ROWID| T2    |  10000 |      1 |     10 |     221 |
-----------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;T1&quot;.&quot;C1&quot;=&quot;T2&quot;.&quot;C1&quot;)
   5 - filter(&quot;T2&quot;.&quot;C3&quot;=1)


SQL&gt; select /*+ gather_plan_statistics
  2  		     leading(t2) use_nl(t1) index(t2) */
  3  	     t1.c1, t1.c2, t2.c2, t2.c3
  4  from
  5  	     t1, t2
  6  where
  7  	     t1.c1 = t2.c1
  8  	     and t2.c3 = 1
  9  ;

        C1         C2         C2         C3
---------- ---------- ---------- ----------
         2          2          1          1
         2          2       1001          1
         2          2       2001          1
         2          2       3001          1
         2          2       4001          1
         2          2       5001          1
         2          2       8001          1
         2          2       9001          1
         2          2       6001          1
         2          2       7001          1

10 rows selected.


------------------------------------------------------------------------------------
| Id  | Operation                     | Name  | Starts | E-Rows | A-Rows | Buffers |
------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |       |      1 |        |     10 |      27 |
|   1 |  NESTED LOOPS                 |       |      1 |        |     10 |      27 |
|   2 |   NESTED LOOPS                |       |      1 |     10 |     10 |      17 |
|   3 |    TABLE ACCESS BY INDEX ROWID| T2    |      1 |     10 |     10 |      13 |
|*  4 |     INDEX RANGE SCAN          | T2_N1 |      1 |     10 |     10 |       3 |
|*  5 |    INDEX UNIQUE SCAN          | T1_PK |     10 |      1 |     10 |       4 |
|   6 |   TABLE ACCESS BY INDEX ROWID | T1    |     10 |      1 |     10 |      10 |
------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access(&quot;T2&quot;.&quot;C3&quot;=1)
   5 - access(&quot;T1&quot;.&quot;C1&quot;=&quot;T2&quot;.&quot;C1&quot;)

&lt;/pre&gt;
예상하신대론가요? 
&lt;p/&gt;
&lt;b&gt;해석은 각자의 몫! @_@&lt;/b&gt;
&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-357-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/357&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>SQL 튜닝</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/357</guid>
			<comments>http://ukja.tistory.com/357#entry357comment</comments>
			<pubDate>Thu, 25 Nov 2010 17:35:15 +0900</pubDate>
		</item>
		<item>
			<title>오라클의 자동 메모리 크기 변경 기능을 써야 할까요?</title>
			<link>http://ukja.tistory.com/356</link>
			<description>오라클이 버전업되면서 가장 신경쓰는 것 중 하나가 &lt;b&gt;관리의 자동화&lt;/b&gt;입니다. 
&lt;p/&gt;
그 중 대표적인 것이 메모리 자동 관리입니다. Oracle 10g에서는 SGA 및 하부 컴포넌트(공유 풀과 버퍼 캐시 등)의 크기를 자동으로 조정하는 SGA 크기 관리 기능이 추가되었고, 11g에서는 PAT(PGA Aggregate Target)의 크기까지 관리해주는 기능이 추가되었죠. 
&lt;p/&gt;
제가 가지는 한가지 의문 중 하나는, &lt;b&gt;메모리 자동 관리 기능을 써야 하나?&lt;/b&gt;입니다.
&lt;p/&gt;
결론은 애석하게도 &lt;b&gt;부정적&lt;/b&gt;입니다.
&lt;ul&gt;
&lt;li&gt;공유 풀과 버퍼 캐시의 크기가 변경되는 과정에서 불필요한 경합(래치 경합과 뮤텍스 경합)이 발생할 확률이 높습니다.
&lt;li&gt;특정 컴포넌트(가령 공유 풀)의 크기가 불필요하게 커지는 현상이 생길 수 있습니다.
&lt;li&gt;11g의 자동 메모리 관리 기능을 사용하면 PAT(PGA Aggregate Target)의 값이 바뀔 수 있고, 이로 인해 실행 계획이 변경되는 쿼리들이 생길 수 있습니다.
&lt;/ul&gt;
엔터프라이즈 급의 데이터베이스라면 매뉴얼한 최적화 과정이 반드시 필요합니다. 여기에는 메모리 크기 설정도 포함됩니다. 따라서 오라클 엔진에게 자동 메모리 관리 기능을 맡김으로써 불필요한 위험을 초래할 필요는 없다고 봅니다.
&lt;p/&gt;
일정한 스킬을 보유한 DBA 그룹이 없는 중소 규모의 데이터베이스라면 자동 메모리 관리 기능이 유용할 수도 있을 것입니다. 단, 이런 경우라도 위에서 언급한 문제들이 언제든지 발생할 수 있기 때문에 여전히 보수적인 자세를 취할 필요가 있겠지요. 
&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-356-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/356&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>기타</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/356</guid>
			<comments>http://ukja.tistory.com/356#entry356comment</comments>
			<pubDate>Wed, 24 Nov 2010 11:17:39 +0900</pubDate>
		</item>
		<item>
			<title>[공지] 인터파크에서 [오라클 성능 Q&amp;A] 출판 이벤트를 진행한다고 합니다.</title>
			<link>http://ukja.tistory.com/355</link>
			<description>저렴하게 구입할 수 있는 기회라고 생각되어 공지 올립니다. 
&lt;a href=&quot;http://book.interpark.com/product/BookDisplay.do?_method=Detail&amp;sc.shopNo=0000400000&amp;dispNo=&amp;sc.prdNo=207032870&amp;bkid1=category&amp;bkid2=ct028023&amp;bkid3=c1&amp;bkid4=001
&quot;&gt;&lt;img src=&quot;http://wiki.ex-em.com/images/Ask_exem_1.jpg&quot;&gt;&lt;/a&gt;
&lt;p/&gt;
자세한 내용은 아래를 참조하세요.
&lt;ul&gt;
&lt;li&gt;출간을 기념하여 인터파크 도서에서 더블 적립 이벤트를 실시합니다. 
&lt;li&gt;이벤트 기한은 &lt;b&gt;11월 23일 ~ 12월 10일&lt;/b&gt;입니다.
&lt;li&gt;현재 인터파크 도서에서 10%할인( -2,500원), 5%적립(-1,130P)에 판매중입니다. 고객분들은 22,500원에 결재하시고, 1,130P의 적립금을 받게 됩니다. 
&lt;li&gt;이번 이벤트 기회에 구입하시게 되면, &lt;b&gt;추가 적립 2,000원&lt;/b&gt;을 적립해 드립니다. 적립금은 이벤트 종료 후, 12월 13일에 일괄적으로 해당 ID에 지급됩니다. 
&lt;li&gt;인터파크 도서에서 구입하신 후, 아래 추가 적립금 신청하기를 클릭하시어, 주문번호를 남겨주시면 더블적립 이벤트 종료 후에, 일괄적으로 적립해 드리도록 하겠습니다. 
&lt;/ul&gt;
아래 링크를 이용하시면 됩니다.
&lt;p/&gt;
&lt;a href=&quot;http://book.interpark.com/product/BookDisplay.do?_method=Detail&amp;sc.shopNo=0000400000&amp;dispNo=&amp;sc.prdNo=207032870&amp;bkid1=category&amp;bkid2=ct028023&amp;bkid3=c1&amp;bkid4=001&quot;&gt;[바로 구매하기] &lt;/a&gt;
&lt;p/&gt;
&lt;a href=&quot;https://spreadsheets.google.com/viewform?formkey=dFhTOFdyM0FoUUJfSmlHSG5oc2p1dVE6MQ&quot;&gt;[적립금 신청하기] &lt;/a&gt;
&lt;p/&gt;
이런 더블 적립 이벤트도 가끔 하는군요. ㅎㅎ
&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-355-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/355&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>기타</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/355</guid>
			<comments>http://ukja.tistory.com/355#entry355comment</comments>
			<pubDate>Tue, 23 Nov 2010 14:20:42 +0900</pubDate>
		</item>
		<item>
			<title>오라클 ACE와 함께 하는 [오라클 성능 Q&amp;A] 출간!</title>
			<link>http://ukja.tistory.com/354</link>
			<description>&lt;a href=&quot;http://ask.ex-em.com&quot;&gt;Ask 엑셈&lt;/a&gt;의 운영을 시작한 것은 제가 오라클을 본격적으로 공부하면서 가장 큰 도움을 얻었던 &lt;a href=&quot;http://asktom.oracle.com&quot;&gt;Ask Tom&lt;/a&gt;에서 받은 자극때문이었습니다. 저런 실용적이면서도 높은 수준의 논의가 온라인으로 이루어지다니!
&lt;p/&gt;
Ask 엑셈은 여러가지 한계를 드러내기도 했지만(그리고 그 한계는 제 자신의 한계이기도 합니다), 지난 1년 반동안의 운영으로 제법 만족할 만한 수준의 질문과 답변들이 쌓이고 있습니다. 그리고 약 1년 동안의 질문과 답변 중 공유할만한 것들을 모아서 책으로 냈습니다.(아직 서점에 풀릴려면 시간이 좀 더 필요합니다만...)
&lt;p/&gt;
&lt;a href=&quot;http://wiki.ex-em.com/index.php/Ask_exem_1&quot;&gt;&lt;img src=&quot;http://wiki.ex-em.com/images/Ask_exem_1.jpg&quot;&gt;
&lt;/br&gt;
&lt;b&gt;오라클 ACE와 함께 하는 [오라클 성능 Q&amp;A]&lt;/b&gt;
&lt;/a&gt;
&lt;/p&gt;
이전에 냈던 약간은 무겁고, 체계적인 내용에서 벗어나서 실제로 많은 분들이 궁금해했던 내용을 정리하면 조금 더 재미있게 지식을 주고 받을 수 있지 않을까하는 생각입니다. B급 영화 한편을 보는 느낌이라고 할까요? 그렇게 봐주시면 좋겠습니다. 
&lt;p/&gt;
부담없이 재미있게 읽을 수 있는 오라클 성능 관련 책을 찾으신다면(이런게 가능할까요? ㅎㅎ), 이 책을 한번 펼쳐보셔도 좋겠습니다.
&lt;p/&gt;
&lt;p/&gt;
&lt;b&gt;PS)&lt;/b&gt;
위의 책을 마무리하면서 현재 다음 번 책을 준비하고 있습니다. 제목은 아마 &lt;b&gt;[오라클 성능 트러블슈팅의 기초]&lt;/b&gt;가 될 것 같습니다. 목차는 다음과 같습니다.
&lt;ol&gt;
&lt;li&gt;기본개념 및 툴
&lt;li&gt;시스템, 세션, SQL 분석
&lt;li&gt;대기이벤트 분석
&lt;li&gt;힙 메모리 분석
&lt;li&gt;콜 트리 분석
&lt;li&gt;기타 유틸리티
&lt;/ol&gt;
아... 무거운 주제인데요. 가능한 재미있게 내용을 전달할 수 있도록 노력 중입니다. 건투를 빌며!

&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-354-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/354&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>기타</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/354</guid>
			<comments>http://ukja.tistory.com/354#entry354comment</comments>
			<pubDate>Thu, 18 Nov 2010 17:43:15 +0900</pubDate>
		</item>
		<item>
			<title>아우터 조인 제거(Outer Join Elimination)</title>
			<link>http://ukja.tistory.com/353</link>
			<description>아우터 조인에서 다음과 같은 패턴의 오류가 종종 발생하는 것 같습니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
select *
from t1, t2
where t1.c1 = t2.c1 (+)
         and t2.c2 = 1
;
&lt;/pre&gt;
위의 쿼리의 문제는 무엇일까요?
&lt;p/&gt;
&lt;p/&gt;
아우터 조인 자체가 불필요하다는 것입니다. 아우터 조인에 의해서 얻은 데이터 중 t1에만 있고 t2에는 없는 데이터의 t2.c2는 NULL입니다. 따라서 &lt;b&gt;t2.c2 = 1 조건이 있다는 것은 아우터 조인에 의해 생긴 데이터중 t2가 존재하지 않는(NULL인) 데이터를 제거한다&lt;/b&gt;는 것과 같은 의미입니다. 즉 위의 쿼리는 아래 쿼리와 논리적으로 동일합니다.
&lt;pre class=&quot;brush: sql; &quot;&gt;
select *
from t1, t2
where t1.c1 = t2.c1
         and t2.c2 = 1
;
&lt;/pre&gt;
하지만 아우터 조인의 고유의 특성 때문에 위의 두 쿼리는 전혀 다른 실행 계획을 가지게 됩니다.
&lt;p/&gt;
아우터 조인의 특징 중 하나는 &lt;b&gt;조인의 방향이 고정&lt;/b&gt;되어 있다는 것입니다.
&lt;p/&gt;
가령 { where t1.c1 = t2.c1(+) }으로 정의되었다면, 반드시 테이블 t1이 드라이빙 테이블이 됩니다. 따라서 { t2.c2 = 1 } 조건은 드라이빙 조건으로 사용될 수 없죠. 따라서 Hash Join + Table Full Scan이 선택될 확률이 매우 높습니다.
&lt;p/&gt;
반면에 { where t1.c1 = t2.c1 }으로 정의되었다면, 테이블 t1과 t2 중 로우 수가 작은 것이 드라이빙 테이블이 될 것입니다. 따라서 { t2.c2 = 1 } 조건이 드라이빙 조건이 될 수 있습니다. 따라서 테이블 t2를 드라이빙으로 하는 Nested Loops Join + Index Range Scan이 선택될 활률이 높습니다. 
&lt;p/&gt;
단, 여기서 오라클이 두 가지 편법을 사용합니다.
&lt;ol&gt;
 &lt;li&gt;아우터 조인(Outer Join)을 이너 조인(Inner Join)으로 바꿀려고 시도합니다. 이것을 아우터 조인 제거(Outer Join Elimination)라고 합니다. 위에서 예로 든 아우터 쿼리는 아우터 조인 제거의 대상이 됩니다.
 &lt;li&gt;조인 순서를 바꿀려고 시도합니다. { where t1.c1 = t2.c1(+) } 조인은 항상 t1 -&gt; t2 의 순서를 따라야하지만, Hash Outer Join인 경우에 한해서는 t2를 드라이빙으로 바꿀 수 있습니다. 즉 가능한 적은 크기의 데이터가 드라이빙 위치에 오도록 바꿀 수 있습니다.
&lt;/ol&gt;
위의 두가지 편법에 의해 어느 정도 문제가 해결되기는 하지만, 조인 방향이 고정되어 있다는 아우터 조인의 특성에 기인하는 본질적인 문제는 항상 조심해야합니다. 아우터 조인을 잘못 사용하면 성능이 느리다다는 불평 중 상당 수가 이 특징으로 인해 나타나는 것으로 봅니다. 
&lt;p/&gt;
아우터 조인의 특성으로 인해 발생하는 재미있는 문제가 Ask 엑셈에 등록되어 있어서 소개합니다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://121.254.172.39:8080/pls/apex/f?p=101:11:0::::P11_QUESTION_ID:10832200346565265&quot;&gt;Left Outer Join의 실행 계획이 원하는 대로 풀리지 않습니다.&lt;/a&gt;
&lt;/ul&gt;
위에서 소개한 개념을 이해한 뒤라면 매우 재미있게 읽을 수 있을 것 같습니다. 


&lt;div class=&quot;entry-ccl&quot; style=&quot;clear: both; text-align: right; margin-bottom: 10px&quot;&gt;
	&lt;img id=&quot;ccl-icon-353-0&quot; class=&quot;entry-ccl-by&quot; src=&quot;http://i1.daumcdn.net/cfs.tistory/v/0/static/admin/editor/ccl_black01.png&quot; alt=&quot;저작자 표시&quot;/&gt;
	&lt;!--
	&lt;rdf:RDF xmlns=&quot;http://web.resource.org/cc/&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;&gt;
		&lt;Work rdf:about=&quot;&quot;&gt;
			&lt;license rdf:resource=&quot;http://creativecommons.org/licenses/by-fr/2.0/kr/&quot; /&gt;
		&lt;/Work&gt;
		&lt;License rdf:about=&quot;http://creativecommons.org/licenses/by-fr/&quot;&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Reproduction&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/Distribution&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Notice&quot;/&gt;
			&lt;requires rdf:resource=&quot;http://web.resource.org/cc/Attribution&quot;/&gt;
			&lt;permits rdf:resource=&quot;http://web.resource.org/cc/DerivativeWorks&quot;/&gt;
		&lt;/License&gt;
	&lt;/rdf:RDF&gt;
	--&gt;
&lt;/div&gt;
&lt;div style=&quot;text-align:left; padding-top:10px;&quot;&gt;
&lt;iframe src=&quot;http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Fukja.tistory.com/353&amp;amp;layout=standard&amp;amp;show_faces=true&amp;amp;width=310&amp;amp;action=like&amp;amp;font=tahoma&amp;amp;colorscheme=light&amp;amp;height=65&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:310px; height:65px;&quot; allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</description>
			<category>옵티마이저</category>
			<category>outer join</category>
			<category>아우터 조인</category>
			<author>욱짜</author>
			<guid>http://ukja.tistory.com/353</guid>
			<comments>http://ukja.tistory.com/353#entry353comment</comments>
			<pubDate>Tue, 09 Nov 2010 13:12:46 +0900</pubDate>
		</item>
	</channel>
</rss>
